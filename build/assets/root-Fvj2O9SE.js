const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-DU1IfKY5.js","assets/jsx-runtime-IZdvEyt_.js","assets/downloader-C-_U3ak8.js","assets/index-DiXcXsr5.js","assets/index-BquAYmyk.js","assets/button-CzfLTIHt.js","assets/index-C-2rzX6a.js","assets/index-BTwtRxOU.js","assets/Combination-BC6FEbU4.js","assets/useSdk-Bk9IxULM.js","assets/usePortalUrl-Bjyn0q0k.js","assets/index-BpxO7BrF.js","assets/index-O1NGHMyc.js","assets/components-DMYkXxdw.js","assets/index-CfDxhBvB.js","assets/index-7xjrsmwg.js","assets/useTheme-Wun3lQOi.js","assets/index-CXs_k2So.js","assets/index-B2actZrY.js","assets/icons-DfV8n6Ey.js","assets/popover-Dc2H5Ola.js","assets/usePluginMeta-BNkMCdOH.js","assets/usePortalMeta-BrKLDHxF.js","assets/useActiveService-BbjXW4qB.js","assets/check-DZlwGSeQ.js","assets/copy-Doo_mHf9.js","assets/index-Dv9Lz1jY.js","assets/skeleton-DwNK_yGs.js","assets/sandbox-DrWkn_pL.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var _a2, _queue3, _carryoverConcurrencyCount, _isIntervalIgnored, _intervalCount, _intervalCap, _interval, _intervalEnd, _intervalId, _timeoutId, _queue4, _queueClass, _pending, _concurrency, _isPaused, _throwOnTimeout, _PQueue_instances, doesIntervalAllowAnother_get, doesConcurrentAllowAnother_get, next_fn, onResumeInterval_fn, isIntervalPaused_get, tryToStartAnother_fn, initializeIntervalIfNeeded_fn, onInterval_fn, processQueue_fn, throwOnAbort_fn, onEvent_fn, _DefaultCar_instances, walkDag_fn, _CarPreprocessorPlugin_instances, createCarStreamMemory_fn, processor_fn, isIPFSFile_fn, createHelia_fn, isCarFile_fn, _IDBBlockstore_instances, encode_fn, decode_fn, _IDBDatastore_instances, queryIt_fn, _b, _listeners, _c, _d, _e, _PinsImpl_instances, walkDag_fn2, updatePinnedBlock_fn, _f, _string, _tuples, _stringTuples, _path, _attempts, _errors, _invalidBlocks, _successes, _pendingResponses, _TrustlessGateway_instances, uniqueBlockId_fn, _DefaultDelegatedRoutingV1HttpApiClient_instances, conformToPeerSchema_fn, _g, _h, _HeliaRemotePinner_instances, getPinArg_fn, _writer, _i, _j, _k, _l, _m, _head, _tail, _size, _queue5, _isLocked, _helia, _pinner, _remoteClient, _restProvider, _fileTree, _lastPinSet, _lastPinSetDefer, _lastPinSetMutex, _IPFS_instances, getAuthHeaders_fn;
import { r as reactExports, j as jsxRuntimeExports, R as React, g as getDefaultExportFromCjs, c as commonjsGlobal } from "./jsx-runtime-IZdvEyt_.js";
import { G, R as Rt, q as qo, B as Buffer2, g as global, P as Pe, x as xo, T as Te, z as zt, i as ic } from "./index-DU1IfKY5.js";
import { P as Primitive$1, d as dispatchDiscreteCustomEvent, C as Cross2Icon } from "./index-DiXcXsr5.js";
import { r as reactDomExports } from "./index-BquAYmyk.js";
import { c as createContextScope, u as useControllableState, P as Presence, a as useCallbackRef, b as composeEventHandlers, d as useLayoutEffect2 } from "./index-C-2rzX6a.js";
import { u as useComposedRefs, c as cn$1, a as cva, t as twMerge, b as clsx, S as Slot, B as Button$1, d as buttonVariants$1 } from "./button-CzfLTIHt.js";
import { c as createCollection, V as VisuallyHidden } from "./index-BTwtRxOU.js";
import { B as Branch, R as Root$1, P as Portal, c as createLucideIcon } from "./Combination-BC6FEbU4.js";
import { A as AccountError, a as axios, u as useSdk } from "./useSdk-Bk9IxULM.js";
import { u as useLocation, d as useMatches, e as useNavigate, f as useParams, O as Outlet } from "./index-O1NGHMyc.js";
import { f as useRemixContext, _ as _extends, L as Link, M as Meta, h as Links, S as Scripts } from "./components-DMYkXxdw.js";
import { g as getGetServices, a as getAddService, b as getResetServices } from "./index-7xjrsmwg.js";
import { d as dashboardStore, B as BasePlugin, T as TooltipProvider, a as Tooltip, b as TooltipTrigger, c as TooltipContent, D as DropdownMenu, e as DropdownMenuTrigger, f as DropdownMenuContent, g as DropdownMenuItem, h as getSdk, w as withTheme, u as useUploader } from "./useTheme-Wun3lQOi.js";
import { C as CID, b as baseX, r as rfc4648, f as from$1, t as toString$5, a as fromString$2, c as coerce, d as create$2, e as base32, g as base58, h as fromHex, i as decode$d, j as base58btc, k as base32$1, l as base32upper, u as useActiveService, I as IPFS_SUBFOLDER_ROUTE, S as SERVICE_ROUTE } from "./useActiveService-BbjXW4qB.js";
import { p as process$1, b as baseStore, f as fetchPortalMeta, u as useBaseStore } from "./usePortalUrl-Bjyn0q0k.js";
import { F as FileIcon, C as ClockIcon, a as CircleLockIcon, b as CloudUploadSolidIcon } from "./icons-DfV8n6Ey.js";
import { P as Popover, a as PopoverTrigger, b as PopoverContent } from "./popover-Dc2H5Ola.js";
import { C as Check } from "./check-DZlwGSeQ.js";
import { C as Copy } from "./copy-Doo_mHf9.js";
import { c as createColumnHelper } from "./index-Dv9Lz1jY.js";
import { S as Skeleton } from "./skeleton-DwNK_yGs.js";
import { u as useScrollRestoration } from "./index-CfDxhBvB.js";
function _mergeNamespaces(n, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e = m2[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d2 = Object.getOwnPropertyDescriptor(e, k);
          if (d2) {
            Object.defineProperty(n, k, d2.get ? d2 : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
/**
 * @remix-run/react v2.11.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
let STORAGE_KEY = "positions";
function ScrollRestoration({
  getKey,
  ...props
}) {
  let {
    isSpaMode
  } = useRemixContext();
  let location = useLocation();
  let matches = useMatches();
  useScrollRestoration({
    getKey,
    storageKey: STORAGE_KEY
  });
  let key = reactExports.useMemo(
    () => {
      if (!getKey) return null;
      let userKey = getKey(location, matches);
      return userKey !== location.key ? userKey : null;
    },
    // Nah, we only need this the first time for the SSR render
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (isSpaMode) {
    return null;
  }
  let restoreScroll = ((STORAGE_KEY2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key2 = Math.random().toString(32).slice(2);
      window.history.replaceState({
        key: key2
      }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(STORAGE_KEY2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(STORAGE_KEY2);
    }
  }).toString();
  return /* @__PURE__ */ reactExports.createElement("script", _extends({}, props, {
    suppressHydrationWarning: true,
    dangerouslySetInnerHTML: {
      __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)}, ${JSON.stringify(key)})`
    }
  }));
}
const stylesheet = "/assets/tailwind-DDIbT5eL.css";
var PROVIDER_NAME = "ToastProvider";
var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
var ToastProvider$1 = (props) => {
  const {
    __scopeToast,
    label = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props;
  const [viewport, setViewport] = reactExports.useState(null);
  const [toastCount, setToastCount] = reactExports.useState(0);
  const isFocusedToastEscapeKeyDownRef = reactExports.useRef(false);
  const isClosePausedRef = reactExports.useRef(false);
  if (!label.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange: setViewport,
      onToastAdd: reactExports.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: reactExports.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider$1.displayName = PROVIDER_NAME;
var VIEWPORT_NAME = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems = useCollection(__scopeToast);
    const wrapperRef = reactExports.useRef(null);
    const headFocusProxyRef = reactExports.useRef(null);
    const tailFocusProxyRef = reactExports.useRef(null);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        var _a3;
        const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) (_a3 = ref.current) == null ? void 0 : _a3.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [hotkey]);
    reactExports.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = reactExports.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems]
    );
    reactExports.useEffect(() => {
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown = (event) => {
          var _a3, _b2, _c2;
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              (_a3 = headFocusProxyRef.current) == null ? void 0 : _a3.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? (_b2 = headFocusProxyRef.current) == null ? void 0 : _b2.focus() : (_c2 = tailFocusProxyRef.current) == null ? void 0 : _c2.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown);
        return () => viewport.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems, getSortedTabbableCandidates]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport$1.displayName = VIEWPORT_NAME;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VisuallyHidden,
      {
        "aria-hidden": true,
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          var _a3;
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !((_a3 = context.viewport) == null ? void 0 : _a3.contains(prevFocusedElement));
          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open = true, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef(props.onPause),
        onResume: useCallbackRef(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x: x2, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x2}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y2}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x: x2, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x2}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y2}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast$1.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const pointerStartRef = reactExports.useRef(null);
    const swipeDeltaRef = reactExports.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = reactExports.useRef(0);
    const closeTimerRemainingTimeRef = reactExports.useRef(duration);
    const closeTimerRef = reactExports.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef(() => {
      var _a3;
      const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
      if (isFocusInToast) (_a3 = context.viewport) == null ? void 0 : _a3.focus();
      onClose();
    });
    const startTimer = reactExports.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    reactExports.useEffect(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume == null ? void 0 : onResume();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause == null ? void 0 : onPause();
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration, onPause, onResume, startTimer]);
    reactExports.useEffect(() => {
      if (open && !context.isClosePausedRef.current) startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]);
    reactExports.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = reactExports.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$1,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive$1.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x2 = event.clientX - pointerStartRef.current.x;
                  const y2 = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp(0, x2) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp(0, y2) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x2) > moveStartBuffer || Math.abs(y2) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast2 = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast2.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = reactExports.useState(false);
  const [isAnnounced, setIsAnnounced] = reactExports.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  reactExports.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    context.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME = "ToastTitle";
var ToastTitle$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle$1.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "ToastDescription";
var ToastDescription$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive$1.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription$1.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "ToastAction";
var ToastAction$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose$1, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction$1.displayName = ACTION_NAME;
var CLOSE_NAME = "ToastClose";
var ToastClose$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive$1.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose$1.displayName = CLOSE_NAME;
var ToastAnnounceExclude = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive$1.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText) textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent(name2, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name2, { bubbles: true, cancelable: true, detail });
  if (handler) currentTarget.addEventListener(name2, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef(callback);
  useLayoutEffect2(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider = ToastProvider$1;
var Viewport = ToastViewport$1;
var Root2 = Toast$1;
var Title = ToastTitle$1;
var Description = ToastDescription$1;
var Action = ToastAction$1;
var Close = ToastClose$1;
const ToastProvider = Provider;
const ToastViewport = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Viewport,
  {
    ref,
    className: cn$1(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    ),
    ...props
  }
));
ToastViewport.displayName = Viewport.displayName;
const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
const Toast = reactExports.forwardRef(({ className, variant, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root2,
    {
      ref,
      className: cn$1(toastVariants({ variant }), className),
      ...props
    }
  );
});
Toast.displayName = Root2.displayName;
const ToastAction = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Action,
  {
    ref,
    className: cn$1(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    ),
    ...props
  }
));
ToastAction.displayName = Action.displayName;
const ToastClose = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Close,
  {
    ref,
    className: cn$1(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    ),
    "toast-close": "",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Cross2Icon, { className: "h-4 w-4" })
  }
));
ToastClose.displayName = Close.displayName;
const ToastTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Title,
  {
    ref,
    className: cn$1("text-sm font-semibold [&+div]:text-xs", className),
    ...props
  }
));
ToastTitle.displayName = Title.displayName;
const ToastDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Description,
  {
    ref,
    className: cn$1("text-sm opacity-90", className),
    ...props
  }
));
ToastDescription.displayName = Description.displayName;
const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1e6;
let count = 0;
function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}
const toastTimeouts = /* @__PURE__ */ new Map();
const addToRemoveQueue = (toastId) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }
  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId
    });
  }, TOAST_REMOVE_DELAY);
  toastTimeouts.set(toastId, timeout);
};
const reducer = (state, action) => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT)
      };
    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map(
          (t) => t.id === action.toast.id ? { ...t, ...action.toast } : t
        )
      };
    case "DISMISS_TOAST": {
      const { toastId } = action;
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast2) => {
          addToRemoveQueue(toast2.id);
        });
      }
      return {
        ...state,
        toasts: state.toasts.map(
          (t) => t.id === toastId || toastId === void 0 ? {
            ...t,
            open: false
          } : t
        )
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === void 0) {
        return {
          ...state,
          toasts: []
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId)
      };
  }
};
const listeners = [];
let memoryState = { toasts: [] };
function dispatch(action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}
function toast({ ...props }) {
  const id2 = genId();
  const update = (props2) => dispatch({
    type: "UPDATE_TOAST",
    toast: { ...props2, id: id2 }
  });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id2 });
  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id: id2,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      }
    }
  });
  return {
    id: id2,
    dismiss,
    update
  };
}
function useToast() {
  const [state, setState] = reactExports.useState(memoryState);
  reactExports.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index2 = listeners.indexOf(setState);
      if (index2 > -1) {
        listeners.splice(index2, 1);
      }
    };
  }, [state]);
  return {
    ...state,
    toast,
    dismiss: (toastId) => dispatch({ type: "DISMISS_TOAST", toastId })
  };
}
function Toaster() {
  const { toasts } = useToast();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastProvider, { children: [
    toasts.map(
      ({ id: id2, title, description, action, cancelMutation, ...props }) => {
        const undoButton = cancelMutation ? /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAction, { altText: "Undo", onClick: cancelMutation, children: "Undo" }) : void 0;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Toast, { ...props, variant: "default", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-1", children: [
            title && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastTitle, { children: title }),
            description && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastDescription, { children: description })
          ] }),
          action,
          undoButton,
          /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, {})
        ] }, id2);
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToastViewport, {})
  ] });
}
var g$1 = (e, r) => {
  let t = {}, a = r.replace(/^\/|\/$/g, ""), n = e.replace(/^\/|\/$/g, ""), o = a.split("/"), u = n.split("/");
  return o.forEach((i, s2) => {
    var p;
    i.startsWith(":") && ((p = u[s2]) == null ? void 0 : p.length) > 0 && (t[i.replace(":", "")] = u[s2]);
  }), t;
};
var h$2 = (e) => {
  if (typeof e > "u") return e;
  let r = Number(e);
  return `${r}` === e ? r : e;
};
var x = { addQueryPrefix: true, skipNulls: true, arrayFormat: "indices", encode: false, encodeValuesOnly: true }, E = { go: () => {
  let { search: e, hash: r } = useLocation(), t = useNavigate();
  return reactExports.useCallback(({ to: n, type: o, query: u, hash: i, options: { keepQuery: s2, keepHash: p } = {} }) => {
    let c = { ...s2 && e && G.parse(e, { ignoreQueryPrefix: true }), ...u };
    c.to && (c.to = encodeURIComponent(`${c.to}`));
    let f2 = Object.keys(c).length > 0, l = `#${(i || p && r || "").replace(/^#/, "")}`, T = l.length > 1, C = `${n || ""}${f2 ? G.stringify(c, x) : ""}${T ? l : ""}`;
    return o === "path" ? C : t(C, { replace: o === "replace" });
  }, [r, e, t]);
}, back: () => {
  let e = useNavigate();
  return () => {
    e(-1);
  };
}, parse: () => {
  let e = useParams(), { pathname: r, search: t } = useLocation(), { resources: a } = reactExports.useContext(Rt), { resource: n, action: o, matchedRoute: u } = React.useMemo(() => qo(r, a), [a, r]), i = u && r ? g$1(r, u) : {}, s2 = i.id;
  return reactExports.useCallback(() => {
    let c = G.parse(t, { ignoreQueryPrefix: true }), f2 = { ...i, ...e, ...c };
    return { ...n && { resource: n }, ...o && { action: o }, ...s2 && { id: decodeURIComponent(s2) }, ...(e == null ? void 0 : e.id) && { id: decodeURIComponent(e.id) }, pathname: r, params: { ...f2, current: h$2(f2.current), pageSize: h$2(f2.pageSize), to: f2.to ? decodeURIComponent(f2.to) : void 0 } };
  }, [r, t, e, n, o, i, s2]);
}, Link: React.forwardRef(function(r, t) {
  return React.createElement(Link, { ...r, ref: t });
}) };
const notificationProvider = () => {
  return {
    open: ({
      key,
      message: message2,
      description,
      undoableTimeout,
      cancelMutation,
      action,
      type
    }) => {
      toast({
        variant: type,
        key,
        title: message2,
        description,
        duration: undoableTimeout,
        action,
        cancelMutation
      });
    },
    close: () => {
    }
  };
};
const createAccountProvider = (sdk, restProvider) => {
  return {
    ...restProvider,
    async update(params) {
      if (params.resource === "account") {
        if (params.variables.email && params.variables.password) {
          const ret = await (sdk == null ? void 0 : sdk.account().updateEmail(params.variables.email, params.variables.password));
          if (ret instanceof Error) {
            return Promise.reject(ret);
          }
          return {
            data: {
              email: params.variables.email
            }
          };
        }
        return {
          data: {}
        };
      }
      return restProvider.update(params);
    },
    async deleteOne(params) {
      if (params.resource === "account") {
        const ret = await (sdk == null ? void 0 : sdk.account().requestAccountDeletion());
        if (ret instanceof Error) {
          return Promise.reject(ret);
        }
        return {
          data: {}
        };
      }
      return restProvider.deleteOne(params);
    },
    getApiUrl: () => sdk.account().apiUrl,
    custom: async (params) => {
      const { url, method, payload, headers } = params;
      if (url.includes("/subscription") || url.includes("/otp") || url.includes("/usage") || url.includes("/key")) {
        return restProvider.custom({
          url,
          method,
          payload,
          headers: {
            Authorization: `Bearer ${sdk.account().jwtToken}`,
            ...headers
          }
        });
      }
      throw new Error("Unsupported custom operation");
    }
  };
};
const maybeSetupAuth = (sdk) => {
  let jwt = sdk.account().jwtToken;
  if (jwt) {
    sdk.setAuthToken(jwt);
  }
};
const handleResponse = (result) => {
  var _a3;
  if (result.ret instanceof AccountError) {
    return {
      success: false,
      error: result.ret,
      redirectTo: result.redirectToError
    };
  }
  if (result.ret) {
    (_a3 = result.successCb) == null ? void 0 : _a3.call(result);
    return {
      success: true,
      successNotification: result.successNotification,
      redirectTo: result.redirectToSuccess
    };
  }
  return {
    success: false,
    redirectTo: result.redirectToError
  };
};
const handleCheckResponse = (result) => {
  const response = handleResponse(result);
  const success = response.success;
  delete response.success;
  return {
    ...response,
    authenticated: success
  };
};
const createPortalAuthProvider = (sdk) => {
  return {
    async login(params) {
      try {
        if ("otp" in params) {
          const response = await sdk.account().validateOtp({ otp: params.otp });
          if (response == null ? void 0 : response.token) {
            sdk.setAuthToken(response.token);
            return handleResponse({
              ret: true,
              redirectToSuccess: params.redirectTo ?? "/dashboard",
              successCb: () => {
                sdk.setAuthToken(response.token);
              },
              successNotification: {
                message: "Login Successful",
                description: "You have successfully logged in with 2FA."
              }
            });
          } else {
            return handleResponse({
              ret: new AccountError("Invalid OTP", 400),
              redirectToError: "/otp"
            });
          }
        } else {
          const response = await sdk.account().login(params);
          const loginResponse = response;
          if (response instanceof AccountError) {
            return handleResponse({
              ret: loginResponse
            });
          }
          if (loginResponse.otp) {
            return handleResponse({
              ret: true,
              redirectToSuccess: `/otp?to=${encodeURIComponent(params.redirectTo ?? "/dashboard")}`,
              successNotification: {
                message: "Two-Factor Authentication Required",
                description: "Please enter your 2FA code to complete login."
              }
            });
          } else {
            sdk.setAuthToken(loginResponse.token);
            return handleResponse({
              ret: true,
              redirectToSuccess: params.redirectTo ?? "/dashboard",
              successCb: () => {
                sdk.setAuthToken(loginResponse.token);
              },
              successNotification: {
                message: "Login Successful",
                description: "You have successfully logged in."
              }
            });
          }
        }
      } catch (error) {
        return handleResponse({
          ret: error,
          redirectToError: "/login"
        });
      }
    },
    async logout() {
      const ret = await sdk.account().logout();
      if (ret && false) {
        localStorage.removeItem("jwt");
      }
      return handleResponse({ ret, redirectToSuccess: "/login" });
    },
    async check() {
      maybeSetupAuth(sdk);
      const ret = await sdk.account().ping();
      maybeSetupAuth(sdk);
      return handleCheckResponse({
        ret,
        redirectToError: "/login",
        successCb: () => maybeSetupAuth(sdk)
      });
    },
    async onError() {
      return {};
    },
    async register(params) {
      const ret = await sdk.account().register({
        email: params.email,
        password: params.password,
        first_name: params.firstName,
        last_name: params.lastName
      });
      return handleResponse({
        ret,
        redirectToSuccess: "/login",
        successNotification: {
          message: "Registration Successful",
          description: "You have successfully registered. Please check your email to verify your account."
        }
      });
    },
    async forgotPassword(params) {
      try {
        let ret;
        if (params && params.password) {
          ret = await sdk.account().confirmPasswordReset({
            token: params.token,
            password: params.password,
            email: params.email
          });
          return handleResponse({
            ret,
            successNotification: {
              message: "Password Reset Successful",
              description: "Your password has been successfully reset. You can now log in with your new password."
            }
          });
        } else {
          ret = await sdk.account().requestPasswordReset({ email: params.email });
          return handleResponse({
            ret,
            successNotification: {
              message: "Password Reset Requested",
              description: "If an account exists for this email, you will receive password reset instructions. If it doesn't appear within a few minutes, check your spam folder."
            }
          });
        }
      } catch (error) {
        return handleResponse({
          ret: error
        });
      }
    },
    async updatePassword(params) {
      maybeSetupAuth(sdk);
      const ret = await sdk.account().updatePassword(params.currentPassword, params.password);
      return handleResponse({
        ret,
        successNotification: {
          message: "Password Updated",
          description: "Your password has been updated successfully."
        }
      });
    },
    async getPermissions() {
      return { success: true };
    },
    async getIdentity() {
      maybeSetupAuth(sdk);
      const ret = await sdk.account().info();
      if (!ret) {
        return { identity: null };
      }
      const acct = ret;
      return {
        id: acct.id,
        firstName: acct.first_name,
        lastName: acct.last_name,
        email: acct.email,
        verified: acct.verified,
        otp: acct.otp
      };
    }
  };
};
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (newInputs[i] !== lastInputs[i]) {
      return false;
    }
  }
  return true;
}
function useMemoOne(getResult, inputs) {
  var initial = reactExports.useState(function() {
    return {
      inputs,
      result: getResult()
    };
  })[0];
  var isFirstRun = reactExports.useRef(true);
  var committed = reactExports.useRef(initial);
  var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));
  var cache2 = useCache ? committed.current : {
    inputs,
    result: getResult()
  };
  reactExports.useEffect(function() {
    isFirstRun.current = false;
    committed.current = cache2;
  }, [cache2]);
  return cache2.result;
}
function useCallbackOne(callback, inputs) {
  return useMemoOne(function() {
    return callback;
  }, inputs);
}
var useMemo = useMemoOne;
var useCallback = useCallbackOne;
function useAuthProvider(sdk) {
  return useMemo(() => {
    if (!sdk) return void 0;
    return createPortalAuthProvider(sdk);
  }, [sdk]);
}
function useCheckAuth(authProvider) {
  return useCallback(async () => {
    if (!authProvider) return false;
    try {
      const ret = await authProvider.check();
      return ret.authenticated;
    } catch {
      return false;
    }
  }, [authProvider]);
}
function useInitializeProviders() {
  const getServices = getGetServices();
  return useCallback(
    async (isAuth) => {
      const newProviders = { default: void 0 };
      for (const svc of getServices()) {
        newProviders[svc.id()] = await svc.dataProvider();
      }
      return newProviders;
    },
    [getServices]
  );
}
function useInitializeResources() {
  const getServices = getGetServices();
  return useCallback(
    (isAuth) => {
      return getServices().filter(() => isAuth).flatMap(
        (svc) => svc.resources().map((resource) => ({
          ...resource,
          meta: {
            ...resource.meta,
            dataProviderName: svc.id()
          }
        }))
      );
    },
    [getServices]
  );
}
class BaseService {
}
function getUploadManager() {
  return dashboardStore.getState().uploader;
}
function _classPrivateFieldLooseBase$4(e, t) {
  if (!{}.hasOwnProperty.call(e, t)) throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id$4 = 0;
function _classPrivateFieldLooseKey$4(e) {
  return "__private_" + id$4++ + "_" + e;
}
var _uppy = /* @__PURE__ */ _classPrivateFieldLooseKey$4("uppy");
var _events = /* @__PURE__ */ _classPrivateFieldLooseKey$4("events");
class EventManager {
  constructor(uppy) {
    Object.defineProperty(this, _uppy, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _events, {
      writable: true,
      value: []
    });
    _classPrivateFieldLooseBase$4(this, _uppy)[_uppy] = uppy;
  }
  on(event, fn) {
    _classPrivateFieldLooseBase$4(this, _events)[_events].push([event, fn]);
    return _classPrivateFieldLooseBase$4(this, _uppy)[_uppy].on(event, fn);
  }
  remove() {
    for (const [event, fn] of _classPrivateFieldLooseBase$4(this, _events)[_events].splice(0)) {
      _classPrivateFieldLooseBase$4(this, _uppy)[_uppy].off(event, fn);
    }
  }
  onFilePause(fileID, cb) {
    this.on("upload-pause", (file, isPaused) => {
      if (fileID === (file == null ? void 0 : file.id)) {
        cb(isPaused);
      }
    });
  }
  onFileRemove(fileID, cb) {
    this.on("file-removed", (file) => {
      if (fileID === file.id) cb(file.id);
    });
  }
  onPause(fileID, cb) {
    this.on("upload-pause", (file, isPaused) => {
      if (fileID === (file == null ? void 0 : file.id)) {
        cb(isPaused);
      }
    });
  }
  onRetry(fileID, cb) {
    this.on("upload-retry", (file) => {
      if (fileID === (file == null ? void 0 : file.id)) {
        cb();
      }
    });
  }
  onRetryAll(fileID, cb) {
    this.on("retry-all", () => {
      if (!_classPrivateFieldLooseBase$4(this, _uppy)[_uppy].getFile(fileID)) return;
      cb();
    });
  }
  onPauseAll(fileID, cb) {
    this.on("pause-all", () => {
      if (!_classPrivateFieldLooseBase$4(this, _uppy)[_uppy].getFile(fileID)) return;
      cb();
    });
  }
  onCancelAll(fileID, eventHandler) {
    var _this = this;
    this.on("cancel-all", function() {
      if (!_classPrivateFieldLooseBase$4(_this, _uppy)[_uppy].getFile(fileID)) return;
      eventHandler(...arguments);
    });
  }
  onResumeAll(fileID, cb) {
    this.on("resume-all", () => {
      if (!_classPrivateFieldLooseBase$4(this, _uppy)[_uppy].getFile(fileID)) return;
      cb();
    });
  }
}
function _classPrivateFieldLooseBase$3(e, t) {
  if (!{}.hasOwnProperty.call(e, t)) throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id$3 = 0;
function _classPrivateFieldLooseKey$3(e) {
  return "__private_" + id$3++ + "_" + e;
}
function createCancelError(cause) {
  return new Error("Cancelled", {
    cause
  });
}
function abortOn(signal) {
  if (signal != null) {
    var _this$then;
    const abortPromise = () => this.abort(signal.reason);
    signal.addEventListener("abort", abortPromise, {
      once: true
    });
    const removeAbortListener = () => {
      signal.removeEventListener("abort", abortPromise);
    };
    (_this$then = this.then) == null || _this$then.call(this, removeAbortListener, removeAbortListener);
  }
  return this;
}
var _activeRequests = /* @__PURE__ */ _classPrivateFieldLooseKey$3("activeRequests");
var _queuedHandlers = /* @__PURE__ */ _classPrivateFieldLooseKey$3("queuedHandlers");
var _paused = /* @__PURE__ */ _classPrivateFieldLooseKey$3("paused");
var _pauseTimer = /* @__PURE__ */ _classPrivateFieldLooseKey$3("pauseTimer");
var _downLimit = /* @__PURE__ */ _classPrivateFieldLooseKey$3("downLimit");
var _upperLimit = /* @__PURE__ */ _classPrivateFieldLooseKey$3("upperLimit");
var _rateLimitingTimer = /* @__PURE__ */ _classPrivateFieldLooseKey$3("rateLimitingTimer");
var _call = /* @__PURE__ */ _classPrivateFieldLooseKey$3("call");
var _queueNext = /* @__PURE__ */ _classPrivateFieldLooseKey$3("queueNext");
var _next = /* @__PURE__ */ _classPrivateFieldLooseKey$3("next");
var _queue = /* @__PURE__ */ _classPrivateFieldLooseKey$3("queue");
var _dequeue = /* @__PURE__ */ _classPrivateFieldLooseKey$3("dequeue");
var _resume = /* @__PURE__ */ _classPrivateFieldLooseKey$3("resume");
var _increaseLimit = /* @__PURE__ */ _classPrivateFieldLooseKey$3("increaseLimit");
class RateLimitedQueue {
  constructor(limit) {
    Object.defineProperty(this, _dequeue, {
      value: _dequeue2
    });
    Object.defineProperty(this, _queue, {
      value: _queue2
    });
    Object.defineProperty(this, _next, {
      value: _next2
    });
    Object.defineProperty(this, _queueNext, {
      value: _queueNext2
    });
    Object.defineProperty(this, _call, {
      value: _call2
    });
    Object.defineProperty(this, _activeRequests, {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, _queuedHandlers, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _paused, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _pauseTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _downLimit, {
      writable: true,
      value: 1
    });
    Object.defineProperty(this, _upperLimit, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _rateLimitingTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _resume, {
      writable: true,
      value: () => this.resume()
    });
    Object.defineProperty(this, _increaseLimit, {
      writable: true,
      value: () => {
        if (_classPrivateFieldLooseBase$3(this, _paused)[_paused]) {
          _classPrivateFieldLooseBase$3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase$3(this, _increaseLimit)[_increaseLimit], 0);
          return;
        }
        _classPrivateFieldLooseBase$3(this, _downLimit)[_downLimit] = this.limit;
        this.limit = Math.ceil((_classPrivateFieldLooseBase$3(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase$3(this, _downLimit)[_downLimit]) / 2);
        for (let i = _classPrivateFieldLooseBase$3(this, _downLimit)[_downLimit]; i <= this.limit; i++) {
          _classPrivateFieldLooseBase$3(this, _queueNext)[_queueNext]();
        }
        if (_classPrivateFieldLooseBase$3(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase$3(this, _downLimit)[_downLimit] > 3) {
          _classPrivateFieldLooseBase$3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase$3(this, _increaseLimit)[_increaseLimit], 2e3);
        } else {
          _classPrivateFieldLooseBase$3(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase$3(this, _downLimit)[_downLimit] / 2);
        }
      }
    });
    if (typeof limit !== "number" || limit === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit;
    }
  }
  run(fn, queueOptions) {
    if (!_classPrivateFieldLooseBase$3(this, _paused)[_paused] && _classPrivateFieldLooseBase$3(this, _activeRequests)[_activeRequests] < this.limit) {
      return _classPrivateFieldLooseBase$3(this, _call)[_call](fn);
    }
    return _classPrivateFieldLooseBase$3(this, _queue)[_queue](fn, queueOptions);
  }
  wrapSyncFunction(fn, queueOptions) {
    var _this = this;
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const queuedRequest = _this.run(() => {
        fn(...args);
        queueMicrotask(() => queuedRequest.done());
        return () => {
        };
      }, queueOptions);
      return {
        abortOn,
        abort() {
          queuedRequest.abort();
        }
      };
    };
  }
  wrapPromiseFunction(fn, queueOptions) {
    var _this2 = this;
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      let queuedRequest;
      const outerPromise = new Promise((resolve2, reject) => {
        queuedRequest = _this2.run(() => {
          let cancelError;
          let innerPromise;
          try {
            innerPromise = Promise.resolve(fn(...args));
          } catch (err) {
            innerPromise = Promise.reject(err);
          }
          innerPromise.then((result) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve2(result);
            }
          }, (err) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err);
            }
          });
          return (cause) => {
            cancelError = createCancelError(cause);
          };
        }, queueOptions);
      });
      outerPromise.abort = (cause) => {
        queuedRequest.abort(cause);
      };
      outerPromise.abortOn = abortOn;
      return outerPromise;
    };
  }
  resume() {
    _classPrivateFieldLooseBase$3(this, _paused)[_paused] = false;
    clearTimeout(_classPrivateFieldLooseBase$3(this, _pauseTimer)[_pauseTimer]);
    for (let i = 0; i < this.limit; i++) {
      _classPrivateFieldLooseBase$3(this, _queueNext)[_queueNext]();
    }
  }
  /**
   * Freezes the queue for a while or indefinitely.
   *
   * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.
   *                                    If omitted, the queue won't resume automatically.
   */
  pause(duration) {
    if (duration === void 0) {
      duration = null;
    }
    _classPrivateFieldLooseBase$3(this, _paused)[_paused] = true;
    clearTimeout(_classPrivateFieldLooseBase$3(this, _pauseTimer)[_pauseTimer]);
    if (duration != null) {
      _classPrivateFieldLooseBase$3(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase$3(this, _resume)[_resume], duration);
    }
  }
  /**
   * Pauses the queue for a duration, and lower the limit of concurrent requests
   * when the queue resumes. When the queue resumes, it tries to progressively
   * increase the limit in `this.#increaseLimit` until another call is made to
   * `this.rateLimit`.
   * Call this function when using the RateLimitedQueue for network requests and
   * the remote server responds with 429 HTTP code.
   *
   * @param {number} duration in milliseconds.
   */
  rateLimit(duration) {
    clearTimeout(_classPrivateFieldLooseBase$3(this, _rateLimitingTimer)[_rateLimitingTimer]);
    this.pause(duration);
    if (this.limit > 1 && Number.isFinite(this.limit)) {
      _classPrivateFieldLooseBase$3(this, _upperLimit)[_upperLimit] = this.limit - 1;
      this.limit = _classPrivateFieldLooseBase$3(this, _downLimit)[_downLimit];
      _classPrivateFieldLooseBase$3(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase$3(this, _increaseLimit)[_increaseLimit], duration);
    }
  }
  get isPaused() {
    return _classPrivateFieldLooseBase$3(this, _paused)[_paused];
  }
}
function _call2(fn) {
  _classPrivateFieldLooseBase$3(this, _activeRequests)[_activeRequests] += 1;
  let done = false;
  let cancelActive;
  try {
    cancelActive = fn();
  } catch (err) {
    _classPrivateFieldLooseBase$3(this, _activeRequests)[_activeRequests] -= 1;
    throw err;
  }
  return {
    abort: (cause) => {
      if (done) return;
      done = true;
      _classPrivateFieldLooseBase$3(this, _activeRequests)[_activeRequests] -= 1;
      cancelActive == null || cancelActive(cause);
      _classPrivateFieldLooseBase$3(this, _queueNext)[_queueNext]();
    },
    done: () => {
      if (done) return;
      done = true;
      _classPrivateFieldLooseBase$3(this, _activeRequests)[_activeRequests] -= 1;
      _classPrivateFieldLooseBase$3(this, _queueNext)[_queueNext]();
    }
  };
}
function _queueNext2() {
  queueMicrotask(() => _classPrivateFieldLooseBase$3(this, _next)[_next]());
}
function _next2() {
  if (_classPrivateFieldLooseBase$3(this, _paused)[_paused] || _classPrivateFieldLooseBase$3(this, _activeRequests)[_activeRequests] >= this.limit) {
    return;
  }
  if (_classPrivateFieldLooseBase$3(this, _queuedHandlers)[_queuedHandlers].length === 0) {
    return;
  }
  const next = _classPrivateFieldLooseBase$3(this, _queuedHandlers)[_queuedHandlers].shift();
  if (next == null) {
    throw new Error("Invariant violation: next is null");
  }
  const handler = _classPrivateFieldLooseBase$3(this, _call)[_call](next.fn);
  next.abort = handler.abort;
  next.done = handler.done;
}
function _queue2(fn, options2) {
  const handler = {
    fn,
    priority: (options2 == null ? void 0 : options2.priority) || 0,
    abort: () => {
      _classPrivateFieldLooseBase$3(this, _dequeue)[_dequeue](handler);
    },
    done: () => {
      throw new Error("Cannot mark a queued request as done: this indicates a bug");
    }
  };
  const index2 = _classPrivateFieldLooseBase$3(this, _queuedHandlers)[_queuedHandlers].findIndex((other) => {
    return handler.priority > other.priority;
  });
  if (index2 === -1) {
    _classPrivateFieldLooseBase$3(this, _queuedHandlers)[_queuedHandlers].push(handler);
  } else {
    _classPrivateFieldLooseBase$3(this, _queuedHandlers)[_queuedHandlers].splice(index2, 0, handler);
  }
  return handler;
}
function _dequeue2(handler) {
  const index2 = _classPrivateFieldLooseBase$3(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);
  if (index2 !== -1) {
    _classPrivateFieldLooseBase$3(this, _queuedHandlers)[_queuedHandlers].splice(index2, 1);
  }
}
const internalRateLimitedQueue = Symbol("__queue");
class NetworkError extends Error {
  constructor(error, xhr) {
    if (xhr === void 0) {
      xhr = null;
    }
    super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);
    this.cause = error;
    this.isNetworkError = true;
    this.request = xhr;
  }
}
function isNetworkError$1(xhr) {
  if (!xhr) {
    return false;
  }
  return xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0;
}
function _classPrivateFieldLooseBase$2(e, t) {
  if (!{}.hasOwnProperty.call(e, t)) throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id$2 = 0;
function _classPrivateFieldLooseKey$2(e) {
  return "__private_" + id$2++ + "_" + e;
}
var _aliveTimer = /* @__PURE__ */ _classPrivateFieldLooseKey$2("aliveTimer");
var _isDone = /* @__PURE__ */ _classPrivateFieldLooseKey$2("isDone");
var _onTimedOut = /* @__PURE__ */ _classPrivateFieldLooseKey$2("onTimedOut");
var _timeout = /* @__PURE__ */ _classPrivateFieldLooseKey$2("timeout");
class ProgressTimeout {
  constructor(timeout, timeoutHandler) {
    Object.defineProperty(this, _aliveTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isDone, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _onTimedOut, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _timeout, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase$2(this, _timeout)[_timeout] = timeout;
    _classPrivateFieldLooseBase$2(this, _onTimedOut)[_onTimedOut] = () => timeoutHandler(timeout);
  }
  progress() {
    if (_classPrivateFieldLooseBase$2(this, _isDone)[_isDone]) return;
    if (_classPrivateFieldLooseBase$2(this, _timeout)[_timeout] > 0) {
      clearTimeout(_classPrivateFieldLooseBase$2(this, _aliveTimer)[_aliveTimer]);
      _classPrivateFieldLooseBase$2(this, _aliveTimer)[_aliveTimer] = setTimeout(_classPrivateFieldLooseBase$2(this, _onTimedOut)[_onTimedOut], _classPrivateFieldLooseBase$2(this, _timeout)[_timeout]);
    }
  }
  done() {
    if (!_classPrivateFieldLooseBase$2(this, _isDone)[_isDone]) {
      clearTimeout(_classPrivateFieldLooseBase$2(this, _aliveTimer)[_aliveTimer]);
      _classPrivateFieldLooseBase$2(this, _aliveTimer)[_aliveTimer] = void 0;
      _classPrivateFieldLooseBase$2(this, _isDone)[_isDone] = true;
    }
  }
}
const noop$2 = () => {
};
function fetcher(url, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    body = null,
    headers = {},
    method = "GET",
    onBeforeRequest = noop$2,
    onUploadProgress = noop$2,
    shouldRetry: shouldRetry2 = () => true,
    onAfterResponse = noop$2,
    onTimeout = noop$2,
    responseType,
    retries = 3,
    signal = null,
    timeout = 3e4,
    withCredentials = false
  } = options2;
  const delay = (attempt) => 0.3 * 2 ** (attempt - 1) * 1e3;
  const timer = new ProgressTimeout(timeout, onTimeout);
  function requestWithRetry(retryCount) {
    if (retryCount === void 0) {
      retryCount = 0;
    }
    return new Promise(async (resolve2, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open(method, url, true);
      xhr.withCredentials = withCredentials;
      if (responseType) {
        xhr.responseType = responseType;
      }
      signal == null || signal.addEventListener("abort", () => {
        xhr.abort();
        reject(new DOMException("Aborted", "AbortError"));
      });
      xhr.onload = async () => {
        await onAfterResponse(xhr, retryCount);
        if (xhr.status >= 200 && xhr.status < 300) {
          timer.done();
          resolve2(xhr);
        } else if (shouldRetry2(xhr) && retryCount < retries) {
          setTimeout(() => {
            requestWithRetry(retryCount + 1).then(resolve2, reject);
          }, delay(retryCount));
        } else {
          timer.done();
          reject(new NetworkError(xhr.statusText, xhr));
        }
      };
      xhr.onerror = () => {
        if (shouldRetry2(xhr) && retryCount < retries) {
          setTimeout(() => {
            requestWithRetry(retryCount + 1).then(resolve2, reject);
          }, delay(retryCount));
        } else {
          timer.done();
          reject(new NetworkError(xhr.statusText, xhr));
        }
      };
      xhr.upload.onprogress = (event) => {
        timer.progress();
        onUploadProgress(event);
      };
      if (headers) {
        Object.keys(headers).forEach((key) => {
          xhr.setRequestHeader(key, headers[key]);
        });
      }
      await onBeforeRequest(xhr, retryCount);
      xhr.send(body);
    });
  }
  return requestWithRetry();
}
function filterNonFailedFiles(files) {
  const hasError = (file) => "error" in file && !!file.error;
  return files.filter((file) => !hasError(file));
}
function filterFilesToEmitUploadStarted(files) {
  return files.filter((file) => {
    var _file$progress;
    return !((_file$progress = file.progress) != null && _file$progress.uploadStarted) || !file.isRestored;
  });
}
function getAllowedMetaFields(fields, meta) {
  if (fields === true) {
    return Object.keys(meta);
  }
  if (Array.isArray(fields)) {
    return fields;
  }
  return [];
}
const locale = {
  strings: {
    // Shown in the Informer if an upload is being canceled because it stalled for too long.
    uploadStalled: "Upload has not made any progress for %{seconds} seconds. You may want to retry it."
  }
};
function _classPrivateFieldLooseBase$1(e, t) {
  if (!{}.hasOwnProperty.call(e, t)) throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id$1 = 0;
function _classPrivateFieldLooseKey$1(e) {
  return "__private_" + id$1++ + "_" + e;
}
const packageJson$1 = {
  "version": "4.0.2"
};
function buildResponseError(xhr, err) {
  let error = err;
  if (!error) error = new Error("Upload error");
  if (typeof error === "string") error = new Error(error);
  if (!(error instanceof Error)) {
    error = Object.assign(new Error("Upload error"), {
      data: error
    });
  }
  if (isNetworkError$1(xhr)) {
    error = new NetworkError(error, xhr);
    return error;
  }
  error.request = xhr;
  return error;
}
function setTypeInBlob(file) {
  const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);
  return dataWithUpdatedType;
}
const defaultOptions$e = {
  formData: true,
  fieldName: "file",
  method: "post",
  allowedMetaFields: true,
  bundle: false,
  headers: {},
  timeout: 30 * 1e3,
  limit: 5,
  withCredentials: false,
  responseType: ""
};
var _getFetcher = /* @__PURE__ */ _classPrivateFieldLooseKey$1("getFetcher");
var _uploadLocalFile$1 = /* @__PURE__ */ _classPrivateFieldLooseKey$1("uploadLocalFile");
var _uploadBundle = /* @__PURE__ */ _classPrivateFieldLooseKey$1("uploadBundle");
var _getCompanionClientArgs$1 = /* @__PURE__ */ _classPrivateFieldLooseKey$1("getCompanionClientArgs");
var _uploadFiles$1 = /* @__PURE__ */ _classPrivateFieldLooseKey$1("uploadFiles");
var _handleUpload$1 = /* @__PURE__ */ _classPrivateFieldLooseKey$1("handleUpload");
class XHRUpload extends BasePlugin {
  constructor(uppy, _opts) {
    super(uppy, {
      ...defaultOptions$e,
      fieldName: _opts.bundle ? "files[]" : "file",
      ..._opts
    });
    Object.defineProperty(this, _uploadFiles$1, {
      value: _uploadFiles2$1
    });
    Object.defineProperty(this, _getCompanionClientArgs$1, {
      value: _getCompanionClientArgs2$1
    });
    Object.defineProperty(this, _uploadBundle, {
      value: _uploadBundle2
    });
    Object.defineProperty(this, _uploadLocalFile$1, {
      value: _uploadLocalFile2$1
    });
    Object.defineProperty(this, _getFetcher, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _handleUpload$1, {
      writable: true,
      value: async (fileIDs) => {
        if (fileIDs.length === 0) {
          this.uppy.log("[XHRUpload] No files to upload!");
          return;
        }
        if (this.opts.limit === 0 && !this.opts[internalRateLimitedQueue]) {
          this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0", "warning");
        }
        this.uppy.log("[XHRUpload] Uploading...");
        const files = this.uppy.getFilesByIds(fileIDs);
        const filesFiltered = filterNonFailedFiles(files);
        const filesToEmit = filterFilesToEmitUploadStarted(filesFiltered);
        this.uppy.emit("upload-start", filesToEmit);
        if (this.opts.bundle) {
          const isSomeFileRemote = filesFiltered.some((file) => file.isRemote);
          if (isSomeFileRemote) {
            throw new Error("Cant upload remote files when the `bundle: true` option is set");
          }
          if (typeof this.opts.headers === "function") {
            throw new TypeError("`headers` may not be a function when the `bundle: true` option is set");
          }
          await _classPrivateFieldLooseBase$1(this, _uploadBundle)[_uploadBundle](filesFiltered);
        } else {
          await _classPrivateFieldLooseBase$1(this, _uploadFiles$1)[_uploadFiles$1](filesFiltered);
        }
      }
    });
    this.type = "uploader";
    this.id = this.opts.id || "XHRUpload";
    this.defaultLocale = locale;
    this.i18nInit();
    if (internalRateLimitedQueue in this.opts) {
      this.requests = this.opts[internalRateLimitedQueue];
    } else {
      this.requests = new RateLimitedQueue(this.opts.limit);
    }
    if (this.opts.bundle && !this.opts.formData) {
      throw new Error("`opts.formData` must be true when `opts.bundle` is enabled.");
    }
    if (this.opts.bundle && typeof this.opts.headers === "function") {
      throw new Error("`opts.headers` can not be a function when the `bundle: true` option is set.");
    }
    if ((_opts == null ? void 0 : _opts.allowedMetaFields) === void 0 && "metaFields" in this.opts) {
      throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`.");
    }
    this.uploaderEvents = /* @__PURE__ */ Object.create(null);
    _classPrivateFieldLooseBase$1(this, _getFetcher)[_getFetcher] = (files) => {
      return async (url, options2) => {
        try {
          var _this$opts$getRespons, _this$opts, _body2;
          const res = await fetcher(url, {
            ...options2,
            onBeforeRequest: this.opts.onBeforeRequest,
            shouldRetry: this.opts.shouldRetry,
            onAfterResponse: this.opts.onAfterResponse,
            onTimeout: (timeout) => {
              const seconds = Math.ceil(timeout / 1e3);
              const error = new Error(this.i18n("uploadStalled", {
                seconds
              }));
              this.uppy.emit("upload-stalled", error, files);
            },
            onUploadProgress: (event) => {
              if (event.lengthComputable) {
                for (const file of files) {
                  var _file$progress$upload;
                  this.uppy.emit("upload-progress", file, {
                    uploadStarted: (_file$progress$upload = file.progress.uploadStarted) != null ? _file$progress$upload : 0,
                    bytesUploaded: event.loaded / event.total * file.size,
                    bytesTotal: file.size
                  });
                }
              }
            }
          });
          let body = await ((_this$opts$getRespons = (_this$opts = this.opts).getResponseData) == null ? void 0 : _this$opts$getRespons.call(_this$opts, res));
          try {
            var _body;
            (_body = body) != null ? _body : body = JSON.parse(res.responseText);
          } catch (cause) {
            throw new Error("@uppy/xhr-upload expects a JSON response (with a `url` property). To parse non-JSON responses, use `getResponseData` to turn your response into JSON.", {
              cause
            });
          }
          const uploadURL = typeof ((_body2 = body) == null ? void 0 : _body2.url) === "string" ? body.url : void 0;
          for (const file of files) {
            this.uppy.emit("upload-success", file, {
              status: res.status,
              body,
              uploadURL
            });
          }
          return res;
        } catch (error) {
          if (error.name === "AbortError") {
            return void 0;
          }
          if (error instanceof NetworkError) {
            const request = error.request;
            for (const file of files) {
              this.uppy.emit("upload-error", file, buildResponseError(request, error));
            }
          }
          throw error;
        }
      };
    };
  }
  getOptions(file) {
    const overrides = this.uppy.getState().xhrUpload;
    const {
      headers
    } = this.opts;
    const opts = {
      ...this.opts,
      ...overrides || {},
      ...file.xhrUpload || {},
      headers: {}
    };
    if (typeof headers === "function") {
      opts.headers = headers(file);
    } else {
      Object.assign(opts.headers, this.opts.headers);
    }
    if (overrides) {
      Object.assign(opts.headers, overrides.headers);
    }
    if (file.xhrUpload) {
      Object.assign(opts.headers, file.xhrUpload.headers);
    }
    return opts;
  }
  // eslint-disable-next-line class-methods-use-this
  addMetadata(formData, meta, opts) {
    const allowedMetaFields = getAllowedMetaFields(opts.allowedMetaFields, meta);
    allowedMetaFields.forEach((item) => {
      const value = meta[item];
      if (Array.isArray(value)) {
        value.forEach((subItem) => formData.append(item, subItem));
      } else {
        formData.append(item, value);
      }
    });
  }
  createFormDataUpload(file, opts) {
    const formPost = new FormData();
    this.addMetadata(formPost, file.meta, opts);
    const dataWithUpdatedType = setTypeInBlob(file);
    if (file.name) {
      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);
    } else {
      formPost.append(opts.fieldName, dataWithUpdatedType);
    }
    return formPost;
  }
  createBundledUpload(files, opts) {
    const formPost = new FormData();
    const {
      meta
    } = this.uppy.getState();
    this.addMetadata(formPost, meta, opts);
    files.forEach((file) => {
      const options2 = this.getOptions(file);
      const dataWithUpdatedType = setTypeInBlob(file);
      if (file.name) {
        formPost.append(options2.fieldName, dataWithUpdatedType, file.name);
      } else {
        formPost.append(options2.fieldName, dataWithUpdatedType);
      }
    });
    return formPost;
  }
  install() {
    if (this.opts.bundle) {
      const {
        capabilities
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          individualCancellation: false
        }
      });
    }
    this.uppy.addUploader(_classPrivateFieldLooseBase$1(this, _handleUpload$1)[_handleUpload$1]);
  }
  uninstall() {
    if (this.opts.bundle) {
      const {
        capabilities
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          individualCancellation: true
        }
      });
    }
    this.uppy.removeUploader(_classPrivateFieldLooseBase$1(this, _handleUpload$1)[_handleUpload$1]);
  }
}
async function _uploadLocalFile2$1(file) {
  const events2 = new EventManager(this.uppy);
  const controller = new AbortController();
  const uppyFetch = this.requests.wrapPromiseFunction(async () => {
    const opts = this.getOptions(file);
    const fetch2 = _classPrivateFieldLooseBase$1(this, _getFetcher)[_getFetcher]([file]);
    const body = opts.formData ? this.createFormDataUpload(file, opts) : file.data;
    return fetch2(opts.endpoint, {
      ...opts,
      body,
      signal: controller.signal
    });
  });
  events2.onFileRemove(file.id, () => controller.abort());
  events2.onCancelAll(file.id, () => {
    controller.abort();
  });
  try {
    await uppyFetch().abortOn(controller.signal);
  } catch (error) {
    if (error.message !== "Cancelled") {
      throw error;
    }
  } finally {
    events2.remove();
  }
}
async function _uploadBundle2(files) {
  const controller = new AbortController();
  const uppyFetch = this.requests.wrapPromiseFunction(async () => {
    var _this$uppy$getState$x;
    const optsFromState = (_this$uppy$getState$x = this.uppy.getState().xhrUpload) != null ? _this$uppy$getState$x : {};
    const fetch2 = _classPrivateFieldLooseBase$1(this, _getFetcher)[_getFetcher](files);
    const body = this.createBundledUpload(files, {
      ...this.opts,
      ...optsFromState
    });
    return fetch2(this.opts.endpoint, {
      // headers can't be a function with bundle: true
      ...this.opts,
      body,
      signal: controller.signal
    });
  });
  function abort() {
    controller.abort();
  }
  this.uppy.once("cancel-all", abort);
  try {
    await uppyFetch().abortOn(controller.signal);
  } catch (error) {
    if (error.message !== "Cancelled") {
      throw error;
    }
  } finally {
    this.uppy.off("cancel-all", abort);
  }
}
function _getCompanionClientArgs2$1(file) {
  var _file$remote;
  const opts = this.getOptions(file);
  const allowedMetaFields = getAllowedMetaFields(opts.allowedMetaFields, file.meta);
  return {
    ...(_file$remote = file.remote) == null ? void 0 : _file$remote.body,
    protocol: "multipart",
    endpoint: opts.endpoint,
    size: file.data.size,
    fieldname: opts.fieldName,
    metadata: Object.fromEntries(allowedMetaFields.map((name2) => [name2, file.meta[name2]])),
    httpMethod: opts.method,
    useFormData: opts.formData,
    headers: opts.headers
  };
}
async function _uploadFiles2$1(files) {
  await Promise.allSettled(files.map((file) => {
    if (file.isRemote) {
      const getQueue = () => this.requests;
      const controller = new AbortController();
      const removedHandler = (removedFile) => {
        if (removedFile.id === file.id) controller.abort();
      };
      this.uppy.on("file-removed", removedHandler);
      const uploadPromise = this.uppy.getRequestClientForFile(file).uploadRemoteFile(file, _classPrivateFieldLooseBase$1(this, _getCompanionClientArgs$1)[_getCompanionClientArgs$1](file), {
        signal: controller.signal,
        getQueue
      });
      this.requests.wrapSyncFunction(() => {
        this.uppy.off("file-removed", removedHandler);
      }, {
        priority: -1
      })();
      return uploadPromise;
    }
    return _classPrivateFieldLooseBase$1(this, _uploadLocalFile$1)[_uploadLocalFile$1](file);
  }));
}
XHRUpload.VERSION = packageJson$1.version;
const version = "3.7.7";
const VERSION = version;
const _hasBuffer = typeof Buffer2 === "function";
const _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
const _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
const _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
const _tidyB64 = (s2) => s2.replace(/[^A-Za-z0-9\+\/]/g, "");
const btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
const _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer2.from(bin, "binary").toString("base64") : btoaPolyfill;
const _fromUint8Array = _hasBuffer ? (u8a) => Buffer2.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
const cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
const utob = (u) => u.replace(re_utob, cb_utob);
const _encode = _hasBuffer ? (s2) => Buffer2.from(s2, "utf8").toString("base64") : _TE ? (s2) => _fromUint8Array(_TE.encode(s2)) : (s2) => _btoa(utob(s2));
const encode$9 = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
const encodeURI = (src) => encode$9(src, true);
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp2 = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp2 - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
const btou = (b) => b.replace(re_btou, cb_btou);
const atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
const _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer2.from(asc, "base64").toString("binary") : atobPolyfill;
const _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer2.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
const toUint8Array = (a) => _toUint8Array(_unURI(a));
const _decode = _hasBuffer ? (a) => Buffer2.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
const decode$c = (src) => _decode(_unURI(src));
const isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s2 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s2) || !/[^\s0-9a-zA-Z\-_]/.test(s2);
};
const _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
const extendString = function() {
  const _add = (name2, body) => Object.defineProperty(String.prototype, name2, _noEnum(body));
  _add("fromBase64", function() {
    return decode$c(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode$9(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode$9(this, true);
  });
  _add("toBase64URL", function() {
    return encode$9(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
const extendUint8Array = function() {
  const _add = (name2, body) => Object.defineProperty(Uint8Array.prototype, name2, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
const extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
const gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode$c,
  toBase64: encode$9,
  encode: encode$9,
  encodeURI,
  encodeURL: encodeURI,
  utob,
  btou,
  decode: decode$c,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};
var requiresPort = function required(port2, protocol) {
  protocol = protocol.split(":")[0];
  port2 = +port2;
  if (!port2) return false;
  switch (protocol) {
    case "http":
    case "ws":
      return port2 !== 80;
    case "https":
    case "wss":
      return port2 !== 443;
    case "ftp":
      return port2 !== 21;
    case "gopher":
      return port2 !== 70;
    case "file":
      return false;
  }
  return port2 !== 0;
};
const index = /* @__PURE__ */ getDefaultExportFromCjs(requiresPort);
const __CJS__import__0__ = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [requiresPort]);
var querystringify$1 = {};
var has$1 = Object.prototype.hasOwnProperty, undef;
function decode$b(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, " "));
  } catch (e) {
    return null;
  }
}
function encode$8(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}
function querystring$1(query) {
  var parser2 = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
  while (part = parser2.exec(query)) {
    var key = decode$b(part[1]), value = decode$b(part[2]);
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }
  return result;
}
function querystringify(obj, prefix) {
  prefix = prefix || "";
  var pairs = [], value, key;
  if ("string" !== typeof prefix) prefix = "?";
  for (key in obj) {
    if (has$1.call(obj, key)) {
      value = obj[key];
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = "";
      }
      key = encode$8(key);
      value = encode$8(value);
      if (key === null || value === null) continue;
      pairs.push(key + "=" + value);
    }
  }
  return pairs.length ? prefix + pairs.join("&") : "";
}
var stringify = querystringify$1.stringify = querystringify;
var parse$2 = querystringify$1.parse = querystring$1;
const __CJS__import__1__ = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: querystringify$1,
  parse: parse$2,
  stringify
}, [querystringify$1]);
var module = { exports: {} };
var required2 = index || __CJS__import__0__, qs = querystringify$1 || __CJS__import__1__, controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, CRHTLF = /[\n\r\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, port = /:\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;
function trimLeft(str) {
  return (str ? str : "").toString().replace(controlOrWhitespace, "");
}
var rules = [
  ["#", "hash"],
  // Extract from the back.
  ["?", "query"],
  // Extract from the back.
  function sanitize(address, url) {
    return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
  },
  ["/", "pathname"],
  // Extract from the back.
  ["@", "auth", 1],
  // Extract from the front.
  [NaN, "host", void 0, 1, 1],
  // Set left over value.
  [/:(\d*)$/, "port", void 0, 1],
  // RegExp the back.
  [NaN, "hostname", void 0, 1, 1]
  // Set left over.
];
var ignore = { hash: 1, query: 1 };
function lolcation(loc) {
  var globalVar;
  if (typeof window !== "undefined") globalVar = window;
  else if (typeof global !== "undefined") globalVar = global;
  else if (typeof self !== "undefined") globalVar = self;
  else globalVar = {};
  var location = globalVar.location || {};
  loc = loc || location;
  var finaldestination = {}, type = typeof loc, key;
  if ("blob:" === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ("string" === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ("object" === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }
    if (finaldestination.slashes === void 0) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }
  return finaldestination;
}
function isSpecial(scheme) {
  return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
}
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, "");
  location = location || {};
  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : "";
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;
  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4];
    }
  }
  if (protocol === "file:") {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }
  return {
    protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount,
    rest
  };
}
function resolve$7(relative, base) {
  if (relative === "") return base;
  var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last2 = path[i - 1], unshift = false, up = 0;
  while (i--) {
    if (path[i] === ".") {
      path.splice(i, 1);
    } else if (path[i] === "..") {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }
  if (unshift) path.unshift("");
  if (last2 === "." || last2 === "..") path.push("");
  return path.join("/");
}
function Url(address, location, parser2) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, "");
  if (!(this instanceof Url)) {
    return new Url(address, location, parser2);
  }
  var relative, extracted, parse2, instruction, index2, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
  if ("object" !== type && "string" !== type) {
    parser2 = location;
    location = null;
  }
  if (parser2 && "function" !== typeof parser2) parser2 = qs.parse;
  location = lolcation(location);
  extracted = extractProtocol(address || "", location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || "";
  address = extracted.rest;
  if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
    instructions[3] = [/(.*)/, "pathname"];
  }
  for (; i < instructions.length; i++) {
    instruction = instructions[i];
    if (typeof instruction === "function") {
      address = instruction(address, url);
      continue;
    }
    parse2 = instruction[0];
    key = instruction[1];
    if (parse2 !== parse2) {
      url[key] = address;
    } else if ("string" === typeof parse2) {
      index2 = parse2 === "@" ? address.lastIndexOf(parse2) : address.indexOf(parse2);
      if (~index2) {
        if ("number" === typeof instruction[2]) {
          url[key] = address.slice(0, index2);
          address = address.slice(index2 + instruction[2]);
        } else {
          url[key] = address.slice(index2);
          address = address.slice(0, index2);
        }
      }
    } else if (index2 = parse2.exec(address)) {
      url[key] = index2[1];
      address = address.slice(0, index2.index);
    }
    url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }
  if (parser2) url.query = parser2(url.query);
  if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
    url.pathname = resolve$7(url.pathname, location.pathname);
  }
  if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
    url.pathname = "/" + url.pathname;
  }
  if (!required2(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = "";
  }
  url.username = url.password = "";
  if (url.auth) {
    index2 = url.auth.indexOf(":");
    if (~index2) {
      url.username = url.auth.slice(0, index2);
      url.username = encodeURIComponent(decodeURIComponent(url.username));
      url.password = url.auth.slice(index2 + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password));
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }
    url.auth = url.password ? url.username + ":" + url.password : url.username;
  }
  url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
  url.href = url.toString();
}
function set(part, value, fn) {
  var url = this;
  switch (part) {
    case "query":
      if ("string" === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }
      url[part] = value;
      break;
    case "port":
      url[part] = value;
      if (!required2(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = "";
      } else if (value) {
        url.host = url.hostname + ":" + value;
      }
      break;
    case "hostname":
      url[part] = value;
      if (url.port) value += ":" + url.port;
      url.host = value;
      break;
    case "host":
      url[part] = value;
      if (port.test(value)) {
        value = value.split(":");
        url.port = value.pop();
        url.hostname = value.join(":");
      } else {
        url.hostname = value;
        url.port = "";
      }
      break;
    case "protocol":
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;
    case "pathname":
    case "hash":
      if (value) {
        var char = part === "pathname" ? "/" : "#";
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;
    case "username":
    case "password":
      url[part] = encodeURIComponent(value);
      break;
    case "auth":
      var index2 = value.indexOf(":");
      if (~index2) {
        url.username = value.slice(0, index2);
        url.username = encodeURIComponent(decodeURIComponent(url.username));
        url.password = value.slice(index2 + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }
  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];
    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }
  url.auth = url.password ? url.username + ":" + url.password : url.username;
  url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
  url.href = url.toString();
  return url;
}
function toString$4(stringify2) {
  if (!stringify2 || "function" !== typeof stringify2) stringify2 = qs.stringify;
  var query, url = this, host = url.host, protocol = url.protocol;
  if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
  var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
  if (url.username) {
    result += url.username;
    if (url.password) result += ":" + url.password;
    result += "@";
  } else if (url.password) {
    result += ":" + url.password;
    result += "@";
  } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
    result += "@";
  }
  if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
    host += ":";
  }
  result += host + url.pathname;
  query = "object" === typeof url.query ? stringify2(url.query) : url.query;
  if (query) result += "?" !== query.charAt(0) ? "?" + query : query;
  if (url.hash) result += url.hash;
  return result;
}
Url.prototype = { set, toString: toString$4 };
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;
module.exports = Url;
const __CJS__export_default__ = (module.exports == null ? {} : module.exports).default || module.exports;
function _typeof$8(o) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$8(o);
}
function _createClass$8(Constructor, protoProps, staticProps) {
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _callSuper$1(t, o, e) {
  return o = _getPrototypeOf$1(o), _possibleConstructorReturn$1(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$8(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2)) return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf$1(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf$1(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(t, e, r) {
  if (_isNativeReflectConstruct$1()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf$1(p, r.prototype), p;
}
function _isNativeReflectConstruct$1() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e) {
    return typeof fn === "function";
  }
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1(o, p);
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
var DetailedError = /* @__PURE__ */ function(_Error) {
  _inherits$1(DetailedError2, _Error);
  function DetailedError2(message2) {
    var _this;
    var causingErr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var req = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    var res = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    _classCallCheck$8(this, DetailedError2);
    _this = _callSuper$1(this, DetailedError2, [message2]);
    _this.originalRequest = req;
    _this.originalResponse = res;
    _this.causingError = causingErr;
    if (causingErr != null) {
      message2 += ", caused by ".concat(causingErr.toString());
    }
    if (req != null) {
      var requestId = req.getHeader("X-Request-ID") || "n/a";
      var method = req.getMethod();
      var url = req.getURL();
      var status = res ? res.getStatus() : "n/a";
      var body = res ? res.getBody() || "" : "n/a";
      message2 += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
    }
    _this.message = message2;
    return _this;
  }
  return _createClass$8(DetailedError2);
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function log$f(msg) {
  return;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0;
    var v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function _regeneratorRuntime$1() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime$1 = function _regeneratorRuntime2() {
    return e;
  };
  var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
    t2[e2] = r2.value;
  }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
  function define(t2, e2, r2) {
    return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
  }
  try {
    define({}, "");
  } catch (t2) {
    define = function define2(t3, e2, r2) {
      return t3[e2] = r2;
    };
  }
  function wrap2(t2, e2, r2, n2) {
    var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
    return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
  }
  function tryCatch(t2, e2, r2) {
    try {
      return { type: "normal", arg: t2.call(e2, r2) };
    } catch (t3) {
      return { type: "throw", arg: t3 };
    }
  }
  e.wrap = wrap2;
  var h2 = "suspendedStart", l = "suspendedYield", f2 = "executing", s2 = "completed", y2 = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var p = {};
  define(p, a, function() {
    return this;
  });
  var d2 = Object.getPrototypeOf, v = d2 && d2(d2(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t2) {
    ["next", "throw", "return"].forEach(function(e2) {
      define(t2, e2, function(t3) {
        return this._invoke(e2, t3);
      });
    });
  }
  function AsyncIterator(t2, e2) {
    function invoke(r3, o2, i2, a2) {
      var c2 = tryCatch(t2[r3], t2, o2);
      if ("throw" !== c2.type) {
        var u2 = c2.arg, h3 = u2.value;
        return h3 && "object" == _typeof$7(h3) && n.call(h3, "__await") ? e2.resolve(h3.__await).then(function(t3) {
          invoke("next", t3, i2, a2);
        }, function(t3) {
          invoke("throw", t3, i2, a2);
        }) : e2.resolve(h3).then(function(t3) {
          u2.value = t3, i2(u2);
        }, function(t3) {
          return invoke("throw", t3, i2, a2);
        });
      }
      a2(c2.arg);
    }
    var r2;
    o(this, "_invoke", { value: function value(t3, n2) {
      function callInvokeWithMethodAndArg() {
        return new e2(function(e3, r3) {
          invoke(t3, n2, e3, r3);
        });
      }
      return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } });
  }
  function makeInvokeMethod(e2, r2, n2) {
    var o2 = h2;
    return function(i2, a2) {
      if (o2 === f2) throw new Error("Generator is already running");
      if (o2 === s2) {
        if ("throw" === i2) throw a2;
        return { value: t, done: true };
      }
      for (n2.method = i2, n2.arg = a2; ; ) {
        var c2 = n2.delegate;
        if (c2) {
          var u2 = maybeInvokeDelegate(c2, n2);
          if (u2) {
            if (u2 === y2) continue;
            return u2;
          }
        }
        if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
        else if ("throw" === n2.method) {
          if (o2 === h2) throw o2 = s2, n2.arg;
          n2.dispatchException(n2.arg);
        } else "return" === n2.method && n2.abrupt("return", n2.arg);
        o2 = f2;
        var p2 = tryCatch(e2, r2, n2);
        if ("normal" === p2.type) {
          if (o2 = n2.done ? s2 : l, p2.arg === y2) continue;
          return { value: p2.arg, done: n2.done };
        }
        "throw" === p2.type && (o2 = s2, n2.method = "throw", n2.arg = p2.arg);
      }
    };
  }
  function maybeInvokeDelegate(e2, r2) {
    var n2 = r2.method, o2 = e2.iterator[n2];
    if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y2;
    var i2 = tryCatch(o2, e2.iterator, r2.arg);
    if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y2;
    var a2 = i2.arg;
    return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y2) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y2);
  }
  function pushTryEntry(t2) {
    var e2 = { tryLoc: t2[0] };
    1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
  }
  function resetTryEntry(t2) {
    var e2 = t2.completion || {};
    e2.type = "normal", delete e2.arg, t2.completion = e2;
  }
  function Context(t2) {
    this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(e2) {
    if (e2 || "" === e2) {
      var r2 = e2[a];
      if (r2) return r2.call(e2);
      if ("function" == typeof e2.next) return e2;
      if (!isNaN(e2.length)) {
        var o2 = -1, i2 = function next() {
          for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
          return next.value = t, next.done = true, next;
        };
        return i2.next = i2;
      }
    }
    throw new TypeError(_typeof$7(e2) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g2, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
    var e2 = "function" == typeof t2 && t2.constructor;
    return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
  }, e.mark = function(t2) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g2), t2;
  }, e.awrap = function(t2) {
    return { __await: t2 };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
    void 0 === i2 && (i2 = Promise);
    var a2 = new AsyncIterator(wrap2(t2, r2, n2, o2), i2);
    return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
      return t3.done ? t3.value : a2.next();
    });
  }, defineIteratorMethods(g2), define(g2, u, "Generator"), define(g2, a, function() {
    return this;
  }), define(g2, "toString", function() {
    return "[object Generator]";
  }), e.keys = function(t2) {
    var e2 = Object(t2), r2 = [];
    for (var n2 in e2) r2.push(n2);
    return r2.reverse(), function next() {
      for (; r2.length; ) {
        var t3 = r2.pop();
        if (t3 in e2) return next.value = t3, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
  }, stop: function stop2() {
    this.done = true;
    var t2 = this.tryEntries[0].completion;
    if ("throw" === t2.type) throw t2.arg;
    return this.rval;
  }, dispatchException: function dispatchException(e2) {
    if (this.done) throw e2;
    var r2 = this;
    function handle(n2, o3) {
      return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
    }
    for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
      var i2 = this.tryEntries[o2], a2 = i2.completion;
      if ("root" === i2.tryLoc) return handle("end");
      if (i2.tryLoc <= this.prev) {
        var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
        if (c2 && u2) {
          if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
          if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
        } else if (c2) {
          if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
        } else {
          if (!u2) throw new Error("try statement without catch or finally");
          if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
        }
      }
    }
  }, abrupt: function abrupt(t2, e2) {
    for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
      var o2 = this.tryEntries[r2];
      if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
        var i2 = o2;
        break;
      }
    }
    i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
    var a2 = i2 ? i2.completion : {};
    return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y2) : this.complete(a2);
  }, complete: function complete(t2, e2) {
    if ("throw" === t2.type) throw t2.arg;
    return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y2;
  }, finish: function finish(t2) {
    for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
      var r2 = this.tryEntries[e2];
      if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y2;
    }
  }, "catch": function _catch(t2) {
    for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
      var r2 = this.tryEntries[e2];
      if (r2.tryLoc === t2) {
        var n2 = r2.completion;
        if ("throw" === n2.type) {
          var o2 = n2.arg;
          resetTryEntry(r2);
        }
        return o2;
      }
    }
    throw new Error("illegal catch attempt");
  }, delegateYield: function delegateYield(e2, r2, n2) {
    return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y2;
  } }, e;
}
function asyncGeneratorStep$1(gen, resolve2, reject, _next3, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve2(value);
  } else {
    Promise.resolve(value).then(_next3, _throw);
  }
}
function _asyncToGenerator$1(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve2, reject) {
      var gen = fn.apply(self2, args);
      function _next3(value) {
        asyncGeneratorStep$1(gen, resolve2, reject, _next3, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep$1(gen, resolve2, reject, _next3, _throw, "throw", err);
      }
      _next3(void 0);
    });
  };
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len2) {
  if (len2 == null || len2 > arr.length) len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f2 = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f2 = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f2 = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f2 && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _typeof$7(o) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$7(o);
}
function ownKeys$1(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), true).forEach(function(r2) {
      _defineProperty$1(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey$7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$7(descriptor.key), descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$7(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$7(t) {
  var i = _toPrimitive$7(t, "string");
  return "symbol" == _typeof$7(i) ? i : String(i);
}
function _toPrimitive$7(t, r) {
  if ("object" != _typeof$7(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof$7(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var PROTOCOL_TUS_V1 = "tus-v1";
var PROTOCOL_IETF_DRAFT_03 = "ietf-draft-03";
var defaultOptions$d = {
  endpoint: null,
  uploadUrl: null,
  metadata: {},
  fingerprint: null,
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  onUploadUrlAvailable: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  onBeforeRequest: null,
  onAfterResponse: null,
  onShouldRetry: defaultOnShouldRetry,
  chunkSize: Infinity,
  retryDelays: [0, 1e3, 3e3, 5e3],
  parallelUploads: 1,
  parallelUploadBoundaries: null,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false,
  urlStorage: null,
  fileReader: null,
  httpStack: null,
  protocol: PROTOCOL_TUS_V1
};
var BaseUpload = /* @__PURE__ */ function() {
  function BaseUpload2(file, options2) {
    _classCallCheck$7(this, BaseUpload2);
    if ("resume" in options2) {
      console.log("tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.");
    }
    this.options = options2;
    this.options.chunkSize = Number(this.options.chunkSize);
    this._urlStorage = this.options.urlStorage;
    this.file = file;
    this.url = null;
    this._req = null;
    this._fingerprint = null;
    this._urlStorageKey = null;
    this._offset = null;
    this._aborted = false;
    this._size = null;
    this._source = null;
    this._retryAttempt = 0;
    this._retryTimeout = null;
    this._offsetBeforeRetry = 0;
    this._parallelUploads = null;
    this._parallelUploadUrls = null;
  }
  _createClass$7(BaseUpload2, [{
    key: "findPreviousUploads",
    value: function findPreviousUploads() {
      var _this = this;
      return this.options.fingerprint(this.file, this.options).then(function(fingerprint2) {
        return _this._urlStorage.findUploadsByFingerprint(fingerprint2);
      });
    }
  }, {
    key: "resumeFromPreviousUpload",
    value: function resumeFromPreviousUpload(previousUpload) {
      this.url = previousUpload.uploadUrl || null;
      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
      this._urlStorageKey = previousUpload.urlStorageKey;
    }
  }, {
    key: "start",
    value: function start2() {
      var _this2 = this;
      var file = this.file;
      if (!file) {
        this._emitError(new Error("tus: no file or stream to upload provided"));
        return;
      }
      if (![PROTOCOL_TUS_V1, PROTOCOL_IETF_DRAFT_03].includes(this.options.protocol)) {
        this._emitError(new Error("tus: unsupported protocol ".concat(this.options.protocol)));
        return;
      }
      if (!this.options.endpoint && !this.options.uploadUrl && !this.url) {
        this._emitError(new Error("tus: neither an endpoint or an upload URL is provided"));
        return;
      }
      var retryDelays = this.options.retryDelays;
      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== "[object Array]") {
        this._emitError(new Error("tus: the `retryDelays` option must either be an array or null"));
        return;
      }
      if (this.options.parallelUploads > 1) {
        for (var _i2 = 0, _arr = ["uploadUrl", "uploadSize", "uploadLengthDeferred"]; _i2 < _arr.length; _i2++) {
          var optionName = _arr[_i2];
          if (this.options[optionName]) {
            this._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
            return;
          }
        }
      }
      if (this.options.parallelUploadBoundaries) {
        if (this.options.parallelUploads <= 1) {
          this._emitError(new Error("tus: cannot use the `parallelUploadBoundaries` option when `parallelUploads` is disabled"));
          return;
        }
        if (this.options.parallelUploads !== this.options.parallelUploadBoundaries.length) {
          this._emitError(new Error("tus: the `parallelUploadBoundaries` must have the same length as the value of `parallelUploads`"));
          return;
        }
      }
      this.options.fingerprint(file, this.options).then(function(fingerprint2) {
        _this2._fingerprint = fingerprint2;
        if (_this2._source) {
          return _this2._source;
        }
        return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
      }).then(function(source) {
        _this2._source = source;
        if (_this2.options.uploadLengthDeferred) {
          _this2._size = null;
        } else if (_this2.options.uploadSize != null) {
          _this2._size = Number(_this2.options.uploadSize);
          if (Number.isNaN(_this2._size)) {
            _this2._emitError(new Error("tus: cannot convert `uploadSize` option into a number"));
            return;
          }
        } else {
          _this2._size = _this2._source.size;
          if (_this2._size == null) {
            _this2._emitError(new Error("tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option"));
            return;
          }
        }
        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
          _this2._startParallelUpload();
        } else {
          _this2._startSingleUpload();
        }
      })["catch"](function(err) {
        _this2._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */
  }, {
    key: "_startParallelUpload",
    value: function _startParallelUpload() {
      var _this$options$paralle, _this3 = this;
      var totalSize = this._size;
      var totalProgress = 0;
      this._parallelUploads = [];
      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads;
      var parts = (_this$options$paralle = this.options.parallelUploadBoundaries) !== null && _this$options$paralle !== void 0 ? _this$options$paralle : splitSizeIntoParts(this._source.size, partCount);
      if (this._parallelUploadUrls) {
        parts.forEach(function(part, index2) {
          part.uploadUrl = _this3._parallelUploadUrls[index2] || null;
        });
      }
      this._parallelUploadUrls = new Array(parts.length);
      var uploads = parts.map(function(part, index2) {
        var lastPartProgress = 0;
        return _this3._source.slice(part.start, part.end).then(function(_ref) {
          var value = _ref.value;
          return new Promise(function(resolve2, reject) {
            var options2 = _objectSpread$1(_objectSpread$1({}, _this3.options), {}, {
              // If available, the partial upload should be resumed from a previous URL.
              uploadUrl: part.uploadUrl || null,
              // We take manually care of resuming for partial uploads, so they should
              // not be stored in the URL storage.
              storeFingerprintForResuming: false,
              removeFingerprintOnSuccess: false,
              // Reset the parallelUploads option to not cause recursion.
              parallelUploads: 1,
              // Reset this option as we are not doing a parallel upload.
              parallelUploadBoundaries: null,
              // Add the header to indicate the this is a partial upload.
              headers: _objectSpread$1(_objectSpread$1({}, _this3.options.headers), {}, {
                "Upload-Concat": "partial"
              }),
              // Reject or resolve the promise if the upload errors or completes.
              onSuccess: resolve2,
              onError: reject,
              // Based in the progress for this partial upload, calculate the progress
              // for the entire final upload.
              onProgress: function onProgress(newPartProgress) {
                totalProgress = totalProgress - lastPartProgress + newPartProgress;
                lastPartProgress = newPartProgress;
                _this3._emitProgress(totalProgress, totalSize);
              },
              // Wait until every partial upload has an upload URL, so we can add
              // them to the URL storage.
              onUploadUrlAvailable: function onUploadUrlAvailable() {
                _this3._parallelUploadUrls[index2] = upload.url;
                if (_this3._parallelUploadUrls.filter(function(u) {
                  return Boolean(u);
                }).length === parts.length) {
                  _this3._saveUploadInUrlStorage();
                }
              }
            });
            var upload = new BaseUpload2(value, options2);
            upload.start();
            _this3._parallelUploads.push(upload);
          });
        });
      });
      var req;
      Promise.all(uploads).then(function() {
        req = _this3._openRequest("POST", _this3.options.endpoint);
        req.setHeader("Upload-Concat", "final;".concat(_this3._parallelUploadUrls.join(" ")));
        var metadata = encodeMetadata(_this3.options.metadata);
        if (metadata !== "") {
          req.setHeader("Upload-Metadata", metadata);
        }
        return _this3._sendRequest(req, null);
      }).then(function(res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this3._emitHttpError(req, res, "tus: unexpected response while creating upload");
          return;
        }
        var location = res.getHeader("Location");
        if (location == null) {
          _this3._emitHttpError(req, res, "tus: invalid or missing Location header");
          return;
        }
        _this3.url = resolveUrl(_this3.options.endpoint, location);
        log$f("Created upload at ".concat(_this3.url));
        _this3._emitSuccess();
      })["catch"](function(err) {
        _this3._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */
  }, {
    key: "_startSingleUpload",
    value: function _startSingleUpload() {
      this._aborted = false;
      if (this.url != null) {
        log$f("Resuming upload from previous URL: ".concat(this.url));
        this._resumeUpload();
        return;
      }
      if (this.options.uploadUrl != null) {
        log$f("Resuming upload from provided URL: ".concat(this.options.uploadUrl));
        this.url = this.options.uploadUrl;
        this._resumeUpload();
        return;
      }
      this._createUpload();
    }
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */
  }, {
    key: "abort",
    value: function abort(shouldTerminate) {
      var _this4 = this;
      if (this._parallelUploads != null) {
        this._parallelUploads.forEach(function(upload) {
          upload.abort(shouldTerminate);
        });
      }
      if (this._req !== null) {
        this._req.abort();
      }
      this._aborted = true;
      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }
      if (!shouldTerminate || this.url == null) {
        return Promise.resolve();
      }
      return BaseUpload2.terminate(this.url, this.options).then(function() {
        return _this4._removeFromUrlStorage();
      });
    }
  }, {
    key: "_emitHttpError",
    value: function _emitHttpError(req, res, message2, causingErr) {
      this._emitError(new DetailedError(message2, causingErr, req, res));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      var _this5 = this;
      if (this._aborted) return;
      if (this.options.retryDelays != null) {
        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;
        if (shouldResetDelays) {
          this._retryAttempt = 0;
        }
        if (shouldRetry(err, this._retryAttempt, this.options)) {
          var delay = this.options.retryDelays[this._retryAttempt++];
          this._offsetBeforeRetry = this._offset;
          this._retryTimeout = setTimeout(function() {
            _this5.start();
          }, delay);
          return;
        }
      }
      if (typeof this.options.onError === "function") {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */
  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (this.options.removeFingerprintOnSuccess) {
        this._removeFromUrlStorage();
      }
      if (typeof this.options.onSuccess === "function") {
        this.options.onSuccess();
      }
    }
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */
  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === "function") {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */
  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === "function") {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */
  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this6 = this;
      if (!this.options.endpoint) {
        this._emitError(new Error("tus: unable to create upload because no endpoint is provided"));
        return;
      }
      var req = this._openRequest("POST", this.options.endpoint);
      if (this.options.uploadLengthDeferred) {
        req.setHeader("Upload-Defer-Length", 1);
      } else {
        req.setHeader("Upload-Length", this._size);
      }
      var metadata = encodeMetadata(this.options.metadata);
      if (metadata !== "") {
        req.setHeader("Upload-Metadata", metadata);
      }
      var promise;
      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        promise = this._addChunkToRequest(req);
      } else {
        if (this.options.protocol === PROTOCOL_IETF_DRAFT_03) {
          req.setHeader("Upload-Complete", "?0");
        }
        promise = this._sendRequest(req, null);
      }
      promise.then(function(res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this6._emitHttpError(req, res, "tus: unexpected response while creating upload");
          return;
        }
        var location = res.getHeader("Location");
        if (location == null) {
          _this6._emitHttpError(req, res, "tus: invalid or missing Location header");
          return;
        }
        _this6.url = resolveUrl(_this6.options.endpoint, location);
        log$f("Created upload at ".concat(_this6.url));
        if (typeof _this6.options.onUploadUrlAvailable === "function") {
          _this6.options.onUploadUrlAvailable();
        }
        if (_this6._size === 0) {
          _this6._emitSuccess();
          _this6._source.close();
          return;
        }
        _this6._saveUploadInUrlStorage().then(function() {
          if (_this6.options.uploadDataDuringCreation) {
            _this6._handleUploadResponse(req, res);
          } else {
            _this6._offset = 0;
            _this6._performUpload();
          }
        });
      })["catch"](function(err) {
        _this6._emitHttpError(req, null, "tus: failed to create upload", err);
      });
    }
    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */
  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this7 = this;
      var req = this._openRequest("HEAD", this.url);
      var promise = this._sendRequest(req, null);
      promise.then(function(res) {
        var status = res.getStatus();
        if (!inStatusCategory(status, 200)) {
          if (status === 423) {
            _this7._emitHttpError(req, res, "tus: upload is currently locked; retry later");
            return;
          }
          if (inStatusCategory(status, 400)) {
            _this7._removeFromUrlStorage();
          }
          if (!_this7.options.endpoint) {
            _this7._emitHttpError(req, res, "tus: unable to resume upload (new upload cannot be created without an endpoint)");
            return;
          }
          _this7.url = null;
          _this7._createUpload();
          return;
        }
        var offset = parseInt(res.getHeader("Upload-Offset"), 10);
        if (Number.isNaN(offset)) {
          _this7._emitHttpError(req, res, "tus: invalid or missing offset value");
          return;
        }
        var length2 = parseInt(res.getHeader("Upload-Length"), 10);
        if (Number.isNaN(length2) && !_this7.options.uploadLengthDeferred && _this7.options.protocol === PROTOCOL_TUS_V1) {
          _this7._emitHttpError(req, res, "tus: invalid or missing length value");
          return;
        }
        if (typeof _this7.options.onUploadUrlAvailable === "function") {
          _this7.options.onUploadUrlAvailable();
        }
        _this7._saveUploadInUrlStorage().then(function() {
          if (offset === length2) {
            _this7._emitProgress(length2, length2);
            _this7._emitSuccess();
            return;
          }
          _this7._offset = offset;
          _this7._performUpload();
        });
      })["catch"](function(err) {
        _this7._emitHttpError(req, null, "tus: failed to resume upload", err);
      });
    }
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */
  }, {
    key: "_performUpload",
    value: function _performUpload() {
      var _this8 = this;
      if (this._aborted) {
        return;
      }
      var req;
      if (this.options.overridePatchMethod) {
        req = this._openRequest("POST", this.url);
        req.setHeader("X-HTTP-Method-Override", "PATCH");
      } else {
        req = this._openRequest("PATCH", this.url);
      }
      req.setHeader("Upload-Offset", this._offset);
      var promise = this._addChunkToRequest(req);
      promise.then(function(res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this8._emitHttpError(req, res, "tus: unexpected response while uploading chunk");
          return;
        }
        _this8._handleUploadResponse(req, res);
      })["catch"](function(err) {
        if (_this8._aborted) {
          return;
        }
        _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset ".concat(_this8._offset), err);
      });
    }
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */
  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(req) {
      var _this9 = this;
      var start2 = this._offset;
      var end = this._offset + this.options.chunkSize;
      req.setProgressHandler(function(bytesSent) {
        _this9._emitProgress(start2 + bytesSent, _this9._size);
      });
      req.setHeader("Content-Type", "application/offset+octet-stream");
      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }
      return this._source.slice(start2, end).then(function(_ref2) {
        var value = _ref2.value, done = _ref2.done;
        var valueSize = value && value.size ? value.size : 0;
        if (_this9.options.uploadLengthDeferred && done) {
          _this9._size = _this9._offset + valueSize;
          req.setHeader("Upload-Length", _this9._size);
        }
        var newSize = _this9._offset + valueSize;
        if (!_this9.options.uploadLengthDeferred && done && newSize !== _this9._size) {
          return Promise.reject(new Error("upload was configured with a size of ".concat(_this9._size, " bytes, but the source is done after ").concat(newSize, " bytes")));
        }
        if (value === null) {
          return _this9._sendRequest(req);
        }
        if (_this9.options.protocol === PROTOCOL_IETF_DRAFT_03) {
          req.setHeader("Upload-Complete", done ? "?1" : "?0");
        }
        _this9._emitProgress(_this9._offset, _this9._size);
        return _this9._sendRequest(req, value);
      });
    }
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */
  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(req, res) {
      var offset = parseInt(res.getHeader("Upload-Offset"), 10);
      if (Number.isNaN(offset)) {
        this._emitHttpError(req, res, "tus: invalid or missing offset value");
        return;
      }
      this._emitProgress(offset, this._size);
      this._emitChunkComplete(offset - this._offset, offset, this._size);
      this._offset = offset;
      if (offset === this._size) {
        this._emitSuccess();
        this._source.close();
        return;
      }
      this._performUpload();
    }
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */
  }, {
    key: "_openRequest",
    value: function _openRequest(method, url) {
      var req = openRequest(method, url, this.options);
      this._req = req;
      return req;
    }
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */
  }, {
    key: "_removeFromUrlStorage",
    value: function _removeFromUrlStorage() {
      var _this10 = this;
      if (!this._urlStorageKey) return;
      this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function(err) {
        _this10._emitError(err);
      });
      this._urlStorageKey = null;
    }
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */
  }, {
    key: "_saveUploadInUrlStorage",
    value: function _saveUploadInUrlStorage() {
      var _this11 = this;
      if (!this.options.storeFingerprintForResuming || !this._fingerprint || this._urlStorageKey !== null) {
        return Promise.resolve();
      }
      var storedUpload = {
        size: this._size,
        metadata: this.options.metadata,
        creationTime: (/* @__PURE__ */ new Date()).toString()
      };
      if (this._parallelUploads) {
        storedUpload.parallelUploadUrls = this._parallelUploadUrls;
      } else {
        storedUpload.uploadUrl = this.url;
      }
      return this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function(urlStorageKey) {
        _this11._urlStorageKey = urlStorageKey;
      });
    }
    /**
     * Send a request with the provided body.
     *
     * @api private
     */
  }, {
    key: "_sendRequest",
    value: function _sendRequest(req) {
      var body = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return sendRequest(req, body, this.options);
    }
  }], [{
    key: "terminate",
    value: function terminate(url) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var req = openRequest("DELETE", url, options2);
      return sendRequest(req, null, options2).then(function(res) {
        if (res.getStatus() === 204) {
          return;
        }
        throw new DetailedError("tus: unexpected response while terminating upload", null, req, res);
      })["catch"](function(err) {
        if (!(err instanceof DetailedError)) {
          err = new DetailedError("tus: failed to terminate upload", err, req, null);
        }
        if (!shouldRetry(err, 0, options2)) {
          throw err;
        }
        var delay = options2.retryDelays[0];
        var remainingDelays = options2.retryDelays.slice(1);
        var newOptions = _objectSpread$1(_objectSpread$1({}, options2), {}, {
          retryDelays: remainingDelays
        });
        return new Promise(function(resolve2) {
          return setTimeout(resolve2, delay);
        }).then(function() {
          return BaseUpload2.terminate(url, newOptions);
        });
      });
    }
  }]);
  return BaseUpload2;
}();
function encodeMetadata(metadata) {
  return Object.entries(metadata).map(function(_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], value = _ref4[1];
    return "".concat(key, " ").concat(gBase64.encode(String(value)));
  }).join(",");
}
function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}
function openRequest(method, url, options2) {
  var req = options2.httpStack.createRequest(method, url);
  if (options2.protocol === PROTOCOL_IETF_DRAFT_03) {
    req.setHeader("Upload-Draft-Interop-Version", "5");
  } else {
    req.setHeader("Tus-Resumable", "1.0.0");
  }
  var headers = options2.headers || {};
  Object.entries(headers).forEach(function(_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2), name2 = _ref6[0], value = _ref6[1];
    req.setHeader(name2, value);
  });
  if (options2.addRequestId) {
    var requestId = uuid();
    req.setHeader("X-Request-ID", requestId);
  }
  return req;
}
function sendRequest(_x, _x2, _x3) {
  return _sendRequest2.apply(this, arguments);
}
function _sendRequest2() {
  _sendRequest2 = _asyncToGenerator$1(/* @__PURE__ */ _regeneratorRuntime$1().mark(function _callee(req, body, options2) {
    var res;
    return _regeneratorRuntime$1().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!(typeof options2.onBeforeRequest === "function")) {
            _context.next = 3;
            break;
          }
          _context.next = 3;
          return options2.onBeforeRequest(req);
        case 3:
          _context.next = 5;
          return req.send(body);
        case 5:
          res = _context.sent;
          if (!(typeof options2.onAfterResponse === "function")) {
            _context.next = 9;
            break;
          }
          _context.next = 9;
          return options2.onAfterResponse(req, res);
        case 9:
          return _context.abrupt("return", res);
        case 10:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _sendRequest2.apply(this, arguments);
}
function isOnline() {
  var online = true;
  if (typeof navigator !== "undefined" && navigator.onLine === false) {
    online = false;
  }
  return online;
}
function shouldRetry(err, retryAttempt, options2) {
  if (options2.retryDelays == null || retryAttempt >= options2.retryDelays.length || err.originalRequest == null) {
    return false;
  }
  if (options2 && typeof options2.onShouldRetry === "function") {
    return options2.onShouldRetry(err, retryAttempt, options2);
  }
  return defaultOnShouldRetry(err);
}
function defaultOnShouldRetry(err) {
  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();
}
function resolveUrl(origin, link) {
  return new __CJS__export_default__(link, origin).toString();
}
function splitSizeIntoParts(totalSize, partCount) {
  var partSize = Math.floor(totalSize / partCount);
  var parts = [];
  for (var i = 0; i < partCount; i++) {
    parts.push({
      start: partSize * i,
      end: partSize * (i + 1)
    });
  }
  parts[partCount - 1].end = totalSize;
  return parts;
}
BaseUpload.defaultOptions = defaultOptions$d;
function _typeof$6(o) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$6(o);
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$6(descriptor.key), descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$6(t) {
  var i = _toPrimitive$6(t, "string");
  return "symbol" == _typeof$6(i) ? i : String(i);
}
function _toPrimitive$6(t, r) {
  if ("object" != _typeof$6(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$6(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var NoopUrlStorage = /* @__PURE__ */ function() {
  function NoopUrlStorage2() {
    _classCallCheck$6(this, NoopUrlStorage2);
  }
  _createClass$6(NoopUrlStorage2, [{
    key: "listAllUploads",
    value: function listAllUploads() {
      return Promise.resolve([]);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint2) {
      return Promise.resolve([]);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint2, upload) {
      return Promise.resolve(null);
    }
  }]);
  return NoopUrlStorage2;
}();
function _typeof$5(o) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$5(o);
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$5(descriptor.key), descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$5(t) {
  var i = _toPrimitive$5(t, "string");
  return "symbol" == _typeof$5(i) ? i : String(i);
}
function _toPrimitive$5(t, r) {
  if ("object" != _typeof$5(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$5(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var hasStorage = false;
try {
  hasStorage = "localStorage" in window;
  var key = "tusSupport";
  var originalValue = localStorage.getItem(key);
  localStorage.setItem(key, originalValue);
  if (originalValue === null) localStorage.removeItem(key);
} catch (e) {
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}
var canStoreURLs = hasStorage;
var WebStorageUrlStorage = /* @__PURE__ */ function() {
  function WebStorageUrlStorage2() {
    _classCallCheck$5(this, WebStorageUrlStorage2);
  }
  _createClass$5(WebStorageUrlStorage2, [{
    key: "findAllUploads",
    value: function findAllUploads() {
      var results = this._findEntries("tus::");
      return Promise.resolve(results);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint2) {
      var results = this._findEntries("tus::".concat(fingerprint2, "::"));
      return Promise.resolve(results);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      localStorage.removeItem(urlStorageKey);
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint2, upload) {
      var id2 = Math.round(Math.random() * 1e12);
      var key = "tus::".concat(fingerprint2, "::").concat(id2);
      localStorage.setItem(key, JSON.stringify(upload));
      return Promise.resolve(key);
    }
  }, {
    key: "_findEntries",
    value: function _findEntries(prefix) {
      var results = [];
      for (var i = 0; i < localStorage.length; i++) {
        var _key = localStorage.key(i);
        if (_key.indexOf(prefix) !== 0) continue;
        try {
          var upload = JSON.parse(localStorage.getItem(_key));
          upload.urlStorageKey = _key;
          results.push(upload);
        } catch (e) {
        }
      }
      return results;
    }
  }]);
  return WebStorageUrlStorage2;
}();
function _typeof$4(o) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$4(o);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$4(descriptor.key), descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$4(t) {
  var i = _toPrimitive$4(t, "string");
  return "symbol" == _typeof$4(i) ? i : String(i);
}
function _toPrimitive$4(t, r) {
  if ("object" != _typeof$4(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$4(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var XHRHttpStack = /* @__PURE__ */ function() {
  function XHRHttpStack2() {
    _classCallCheck$4(this, XHRHttpStack2);
  }
  _createClass$4(XHRHttpStack2, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      return new Request(method, url);
    }
  }, {
    key: "getName",
    value: function getName() {
      return "XHRHttpStack";
    }
  }]);
  return XHRHttpStack2;
}();
var Request = /* @__PURE__ */ function() {
  function Request2(method, url) {
    _classCallCheck$4(this, Request2);
    this._xhr = new XMLHttpRequest();
    this._xhr.open(method, url, true);
    this._method = method;
    this._url = url;
    this._headers = {};
  }
  _createClass$4(Request2, [{
    key: "getMethod",
    value: function getMethod2() {
      return this._method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this._url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this._xhr.setRequestHeader(header, value);
      this._headers[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._headers[header];
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      if (!("upload" in this._xhr)) {
        return;
      }
      this._xhr.upload.onprogress = function(e) {
        if (!e.lengthComputable) {
          return;
        }
        progressHandler(e.loaded);
      };
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;
      var body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return new Promise(function(resolve2, reject) {
        _this._xhr.onload = function() {
          resolve2(new Response$1(_this._xhr));
        };
        _this._xhr.onerror = function(err) {
          reject(err);
        };
        _this._xhr.send(body);
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._xhr.abort();
      return Promise.resolve();
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);
  return Request2;
}();
var Response$1 = /* @__PURE__ */ function() {
  function Response2(xhr) {
    _classCallCheck$4(this, Response2);
    this._xhr = xhr;
  }
  _createClass$4(Response2, [{
    key: "getStatus",
    value: function getStatus() {
      return this._xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._xhr.getResponseHeader(header);
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._xhr.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);
  return Response2;
}();
var isReactNative$1 = function isReactNative() {
  return typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
};
function uriToBlob(uri) {
  return new Promise(function(resolve2, reject) {
    var xhr = new XMLHttpRequest();
    xhr.responseType = "blob";
    xhr.onload = function() {
      var blob = xhr.response;
      resolve2(blob);
    };
    xhr.onerror = function(err) {
      reject(err);
    };
    xhr.open("GET", uri);
    xhr.send();
  });
}
var isCordova$1 = function isCordova() {
  return typeof window !== "undefined" && (typeof window.PhoneGap !== "undefined" || typeof window.Cordova !== "undefined" || typeof window.cordova !== "undefined");
};
function readAsByteArray(chunk) {
  return new Promise(function(resolve2, reject) {
    var reader = new FileReader();
    reader.onload = function() {
      var value = new Uint8Array(reader.result);
      resolve2({
        value
      });
    };
    reader.onerror = function(err) {
      reject(err);
    };
    reader.readAsArrayBuffer(chunk);
  });
}
function _typeof$3(o) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$3(o);
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$3(descriptor.key), descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$3(t) {
  var i = _toPrimitive$3(t, "string");
  return "symbol" == _typeof$3(i) ? i : String(i);
}
function _toPrimitive$3(t, r) {
  if ("object" != _typeof$3(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$3(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var FileSource = /* @__PURE__ */ function() {
  function FileSource2(file) {
    _classCallCheck$3(this, FileSource2);
    this._file = file;
    this.size = file.size;
  }
  _createClass$3(FileSource2, [{
    key: "slice",
    value: function slice2(start2, end) {
      if (isCordova$1()) {
        return readAsByteArray(this._file.slice(start2, end));
      }
      var value = this._file.slice(start2, end);
      var done = end >= this.size;
      return Promise.resolve({
        value,
        done
      });
    }
  }, {
    key: "close",
    value: function close() {
    }
  }]);
  return FileSource2;
}();
function _typeof$2(o) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$2(o);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$2(t) {
  var i = _toPrimitive$2(t, "string");
  return "symbol" == _typeof$2(i) ? i : String(i);
}
function _toPrimitive$2(t, r) {
  if ("object" != _typeof$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$2(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function len(blobOrArray) {
  if (blobOrArray === void 0) return 0;
  if (blobOrArray.size !== void 0) return blobOrArray.size;
  return blobOrArray.length;
}
function concat$3(a, b) {
  if (a.concat) {
    return a.concat(b);
  }
  if (a instanceof Blob) {
    return new Blob([a, b], {
      type: a.type
    });
  }
  if (a.set) {
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }
  throw new Error("Unknown data type");
}
var StreamSource = /* @__PURE__ */ function() {
  function StreamSource2(reader) {
    _classCallCheck$2(this, StreamSource2);
    this._buffer = void 0;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }
  _createClass$2(StreamSource2, [{
    key: "slice",
    value: function slice2(start2, end) {
      if (start2 < this._bufferOffset) {
        return Promise.reject(new Error("Requested data is before the reader's current offset"));
      }
      return this._readUntilEnoughDataOrDone(start2, end);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start2, end) {
      var _this = this;
      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);
      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start2, end);
        var done = value == null ? this._done : false;
        return Promise.resolve({
          value,
          done
        });
      }
      return this._reader.read().then(function(_ref) {
        var value2 = _ref.value, done2 = _ref.done;
        if (done2) {
          _this._done = true;
        } else if (_this._buffer === void 0) {
          _this._buffer = value2;
        } else {
          _this._buffer = concat$3(_this._buffer, value2);
        }
        return _this._readUntilEnoughDataOrDone(start2, end);
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start2, end) {
      if (start2 > this._bufferOffset) {
        this._buffer = this._buffer.slice(start2 - this._bufferOffset);
        this._bufferOffset = start2;
      }
      var hasAllDataBeenRead = len(this._buffer) === 0;
      if (this._done && hasAllDataBeenRead) {
        return null;
      }
      return this._buffer.slice(0, end - start2);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);
  return StreamSource2;
}();
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime2() {
    return e;
  };
  var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
    t2[e2] = r2.value;
  }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
  function define(t2, e2, r2) {
    return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
  }
  try {
    define({}, "");
  } catch (t2) {
    define = function define2(t3, e2, r2) {
      return t3[e2] = r2;
    };
  }
  function wrap2(t2, e2, r2, n2) {
    var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
    return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
  }
  function tryCatch(t2, e2, r2) {
    try {
      return { type: "normal", arg: t2.call(e2, r2) };
    } catch (t3) {
      return { type: "throw", arg: t3 };
    }
  }
  e.wrap = wrap2;
  var h2 = "suspendedStart", l = "suspendedYield", f2 = "executing", s2 = "completed", y2 = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var p = {};
  define(p, a, function() {
    return this;
  });
  var d2 = Object.getPrototypeOf, v = d2 && d2(d2(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t2) {
    ["next", "throw", "return"].forEach(function(e2) {
      define(t2, e2, function(t3) {
        return this._invoke(e2, t3);
      });
    });
  }
  function AsyncIterator(t2, e2) {
    function invoke(r3, o2, i2, a2) {
      var c2 = tryCatch(t2[r3], t2, o2);
      if ("throw" !== c2.type) {
        var u2 = c2.arg, h3 = u2.value;
        return h3 && "object" == _typeof$1(h3) && n.call(h3, "__await") ? e2.resolve(h3.__await).then(function(t3) {
          invoke("next", t3, i2, a2);
        }, function(t3) {
          invoke("throw", t3, i2, a2);
        }) : e2.resolve(h3).then(function(t3) {
          u2.value = t3, i2(u2);
        }, function(t3) {
          return invoke("throw", t3, i2, a2);
        });
      }
      a2(c2.arg);
    }
    var r2;
    o(this, "_invoke", { value: function value(t3, n2) {
      function callInvokeWithMethodAndArg() {
        return new e2(function(e3, r3) {
          invoke(t3, n2, e3, r3);
        });
      }
      return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } });
  }
  function makeInvokeMethod(e2, r2, n2) {
    var o2 = h2;
    return function(i2, a2) {
      if (o2 === f2) throw new Error("Generator is already running");
      if (o2 === s2) {
        if ("throw" === i2) throw a2;
        return { value: t, done: true };
      }
      for (n2.method = i2, n2.arg = a2; ; ) {
        var c2 = n2.delegate;
        if (c2) {
          var u2 = maybeInvokeDelegate(c2, n2);
          if (u2) {
            if (u2 === y2) continue;
            return u2;
          }
        }
        if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
        else if ("throw" === n2.method) {
          if (o2 === h2) throw o2 = s2, n2.arg;
          n2.dispatchException(n2.arg);
        } else "return" === n2.method && n2.abrupt("return", n2.arg);
        o2 = f2;
        var p2 = tryCatch(e2, r2, n2);
        if ("normal" === p2.type) {
          if (o2 = n2.done ? s2 : l, p2.arg === y2) continue;
          return { value: p2.arg, done: n2.done };
        }
        "throw" === p2.type && (o2 = s2, n2.method = "throw", n2.arg = p2.arg);
      }
    };
  }
  function maybeInvokeDelegate(e2, r2) {
    var n2 = r2.method, o2 = e2.iterator[n2];
    if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y2;
    var i2 = tryCatch(o2, e2.iterator, r2.arg);
    if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y2;
    var a2 = i2.arg;
    return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y2) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y2);
  }
  function pushTryEntry(t2) {
    var e2 = { tryLoc: t2[0] };
    1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
  }
  function resetTryEntry(t2) {
    var e2 = t2.completion || {};
    e2.type = "normal", delete e2.arg, t2.completion = e2;
  }
  function Context(t2) {
    this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(e2) {
    if (e2 || "" === e2) {
      var r2 = e2[a];
      if (r2) return r2.call(e2);
      if ("function" == typeof e2.next) return e2;
      if (!isNaN(e2.length)) {
        var o2 = -1, i2 = function next() {
          for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
          return next.value = t, next.done = true, next;
        };
        return i2.next = i2;
      }
    }
    throw new TypeError(_typeof$1(e2) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g2, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
    var e2 = "function" == typeof t2 && t2.constructor;
    return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
  }, e.mark = function(t2) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g2), t2;
  }, e.awrap = function(t2) {
    return { __await: t2 };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
    void 0 === i2 && (i2 = Promise);
    var a2 = new AsyncIterator(wrap2(t2, r2, n2, o2), i2);
    return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
      return t3.done ? t3.value : a2.next();
    });
  }, defineIteratorMethods(g2), define(g2, u, "Generator"), define(g2, a, function() {
    return this;
  }), define(g2, "toString", function() {
    return "[object Generator]";
  }), e.keys = function(t2) {
    var e2 = Object(t2), r2 = [];
    for (var n2 in e2) r2.push(n2);
    return r2.reverse(), function next() {
      for (; r2.length; ) {
        var t3 = r2.pop();
        if (t3 in e2) return next.value = t3, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
  }, stop: function stop2() {
    this.done = true;
    var t2 = this.tryEntries[0].completion;
    if ("throw" === t2.type) throw t2.arg;
    return this.rval;
  }, dispatchException: function dispatchException(e2) {
    if (this.done) throw e2;
    var r2 = this;
    function handle(n2, o3) {
      return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
    }
    for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
      var i2 = this.tryEntries[o2], a2 = i2.completion;
      if ("root" === i2.tryLoc) return handle("end");
      if (i2.tryLoc <= this.prev) {
        var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
        if (c2 && u2) {
          if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
          if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
        } else if (c2) {
          if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
        } else {
          if (!u2) throw new Error("try statement without catch or finally");
          if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
        }
      }
    }
  }, abrupt: function abrupt(t2, e2) {
    for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
      var o2 = this.tryEntries[r2];
      if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
        var i2 = o2;
        break;
      }
    }
    i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
    var a2 = i2 ? i2.completion : {};
    return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y2) : this.complete(a2);
  }, complete: function complete(t2, e2) {
    if ("throw" === t2.type) throw t2.arg;
    return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y2;
  }, finish: function finish(t2) {
    for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
      var r2 = this.tryEntries[e2];
      if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y2;
    }
  }, "catch": function _catch(t2) {
    for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
      var r2 = this.tryEntries[e2];
      if (r2.tryLoc === t2) {
        var n2 = r2.completion;
        if ("throw" === n2.type) {
          var o2 = n2.arg;
          resetTryEntry(r2);
        }
        return o2;
      }
    }
    throw new Error("illegal catch attempt");
  }, delegateYield: function delegateYield(e2, r2, n2) {
    return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y2;
  } }, e;
}
function asyncGeneratorStep(gen, resolve2, reject, _next3, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve2(value);
  } else {
    Promise.resolve(value).then(_next3, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve2, reject) {
      var gen = fn.apply(self2, args);
      function _next3(value) {
        asyncGeneratorStep(gen, resolve2, reject, _next3, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve2, reject, _next3, _throw, "throw", err);
      }
      _next3(void 0);
    });
  };
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$1(t) {
  var i = _toPrimitive$1(t, "string");
  return "symbol" == _typeof$1(i) ? i : String(i);
}
function _toPrimitive$1(t, r) {
  if ("object" != _typeof$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$1(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var FileReader$1 = /* @__PURE__ */ function() {
  function FileReader2() {
    _classCallCheck$1(this, FileReader2);
  }
  _createClass$1(FileReader2, [{
    key: "openFile",
    value: function() {
      var _openFile = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(input, chunkSize) {
        var blob;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(isReactNative$1() && input && typeof input.uri !== "undefined")) {
                _context.next = 11;
                break;
              }
              _context.prev = 1;
              _context.next = 4;
              return uriToBlob(input.uri);
            case 4:
              blob = _context.sent;
              return _context.abrupt("return", new FileSource(blob));
            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](1);
              throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. ".concat(_context.t0));
            case 11:
              if (!(typeof input.slice === "function" && typeof input.size !== "undefined")) {
                _context.next = 13;
                break;
              }
              return _context.abrupt("return", Promise.resolve(new FileSource(input)));
            case 13:
              if (!(typeof input.read === "function")) {
                _context.next = 18;
                break;
              }
              chunkSize = Number(chunkSize);
              if (Number.isFinite(chunkSize)) {
                _context.next = 17;
                break;
              }
              return _context.abrupt("return", Promise.reject(new Error("cannot create source for stream without a finite value for the `chunkSize` option")));
            case 17:
              return _context.abrupt("return", Promise.resolve(new StreamSource(input, chunkSize)));
            case 18:
              return _context.abrupt("return", Promise.reject(new Error("source object may only be an instance of File, Blob, or Reader in this environment")));
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[1, 8]]);
      }));
      function openFile(_x, _x2) {
        return _openFile.apply(this, arguments);
      }
      return openFile;
    }()
  }]);
  return FileReader2;
}();
function fingerprint(file, options2) {
  if (isReactNative$1()) {
    return Promise.resolve(reactNativeFingerprint(file, options2));
  }
  return Promise.resolve(["tus-br", file.name, file.type, file.size, file.lastModified, options2.endpoint].join("-"));
}
function reactNativeFingerprint(file, options2) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : "noexif";
  return ["tus-rn", file.name || "noname", file.size || "nosize", exifHash, options2.endpoint].join("/");
}
function hashCode(str) {
  var hash2 = 0;
  if (str.length === 0) {
    return hash2;
  }
  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + _char;
    hash2 &= hash2;
  }
  return hash2;
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var defaultOptions$c = _objectSpread(_objectSpread({}, BaseUpload.defaultOptions), {}, {
  httpStack: new XHRHttpStack(),
  fileReader: new FileReader$1(),
  urlStorage: canStoreURLs ? new WebStorageUrlStorage() : new NoopUrlStorage(),
  fingerprint
});
var Upload = /* @__PURE__ */ function(_BaseUpload) {
  _inherits(Upload2, _BaseUpload);
  function Upload2() {
    var file = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Upload2);
    options2 = _objectSpread(_objectSpread({}, defaultOptions$c), options2);
    return _callSuper(this, Upload2, [file, options2]);
  }
  _createClass(Upload2, null, [{
    key: "terminate",
    value: function terminate(url) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      options2 = _objectSpread(_objectSpread({}, defaultOptions$c), options2);
      return BaseUpload.terminate(url, options2);
    }
  }]);
  return Upload2;
}(BaseUpload);
function has(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}
function isCordova2() {
  return typeof window !== "undefined" && // @ts-expect-error may exist
  (typeof window.PhoneGap !== "undefined" || // @ts-expect-error may exist
  typeof window.Cordova !== "undefined" || // @ts-expect-error may exist
  typeof window.cordova !== "undefined");
}
function isReactNative2() {
  return typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
}
function getFingerprint(uppyFile) {
  return (file, options2) => {
    if (isCordova2() || isReactNative2()) {
      return defaultOptions$c.fingerprint(file, options2);
    }
    const uppyFingerprint = ["tus", uppyFile.id, options2.endpoint].join("-");
    return Promise.resolve(uppyFingerprint);
  };
}
function _classPrivateFieldLooseBase(e, t) {
  if (!{}.hasOwnProperty.call(e, t)) throw new TypeError("attempted to use private field on non-instance");
  return e;
}
var id = 0;
function _classPrivateFieldLooseKey(e) {
  return "__private_" + id++ + "_" + e;
}
const packageJson = {
  "version": "4.0.0"
};
const tusDefaultOptions = {
  endpoint: "",
  uploadUrl: null,
  metadata: {},
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  chunkSize: Infinity,
  retryDelays: [100, 1e3, 3e3, 5e3],
  parallelUploads: 1,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false
};
const defaultOptions$b = {
  limit: 20,
  retryDelays: tusDefaultOptions.retryDelays,
  withCredentials: false,
  allowedMetaFields: true
};
var _retryDelayIterator = /* @__PURE__ */ _classPrivateFieldLooseKey("retryDelayIterator");
var _uploadLocalFile = /* @__PURE__ */ _classPrivateFieldLooseKey("uploadLocalFile");
var _getCompanionClientArgs = /* @__PURE__ */ _classPrivateFieldLooseKey("getCompanionClientArgs");
var _uploadFiles = /* @__PURE__ */ _classPrivateFieldLooseKey("uploadFiles");
var _handleUpload = /* @__PURE__ */ _classPrivateFieldLooseKey("handleUpload");
class Tus extends BasePlugin {
  constructor(uppy, _opts) {
    var _this$opts$rateLimite, _this$opts$retryDelay;
    super(uppy, {
      ...defaultOptions$b,
      ..._opts
    });
    Object.defineProperty(this, _uploadFiles, {
      value: _uploadFiles2
    });
    Object.defineProperty(this, _getCompanionClientArgs, {
      value: _getCompanionClientArgs2
    });
    Object.defineProperty(this, _uploadLocalFile, {
      value: _uploadLocalFile2
    });
    Object.defineProperty(this, _retryDelayIterator, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _handleUpload, {
      writable: true,
      value: async (fileIDs) => {
        if (fileIDs.length === 0) {
          this.uppy.log("[Tus] No files to upload");
          return;
        }
        if (this.opts.limit === 0) {
          this.uppy.log("[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0", "warning");
        }
        this.uppy.log("[Tus] Uploading...");
        const filesToUpload = this.uppy.getFilesByIds(fileIDs);
        await _classPrivateFieldLooseBase(this, _uploadFiles)[_uploadFiles](filesToUpload);
      }
    });
    this.type = "uploader";
    this.id = this.opts.id || "Tus";
    if ((_opts == null ? void 0 : _opts.allowedMetaFields) === void 0 && "metaFields" in this.opts) {
      throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`.");
    }
    if ("autoRetry" in _opts) {
      throw new Error("The `autoRetry` option was deprecated and has been removed.");
    }
    this.requests = (_this$opts$rateLimite = this.opts.rateLimitedQueue) != null ? _this$opts$rateLimite : new RateLimitedQueue(this.opts.limit);
    _classPrivateFieldLooseBase(this, _retryDelayIterator)[_retryDelayIterator] = (_this$opts$retryDelay = this.opts.retryDelays) == null ? void 0 : _this$opts$retryDelay.values();
    this.uploaders = /* @__PURE__ */ Object.create(null);
    this.uploaderEvents = /* @__PURE__ */ Object.create(null);
  }
  /**
   * Clean up all references for a file's upload: the tus.Upload instance,
   * any events related to the file, and the Companion WebSocket connection.
   */
  resetUploaderReferences(fileID, opts) {
    const uploader = this.uploaders[fileID];
    if (uploader) {
      uploader.abort();
      if (opts != null && opts.abort) {
        uploader.abort(true);
      }
      this.uploaders[fileID] = null;
    }
    if (this.uploaderEvents[fileID]) {
      this.uploaderEvents[fileID].remove();
      this.uploaderEvents[fileID] = null;
    }
  }
  /**
   * Store the uploadUrl on the file options, so that when Golden Retriever
   * restores state, we will continue uploading to the correct URL.
   */
  onReceiveUploadUrl(file, uploadURL) {
    const currentFile = this.uppy.getFile(file.id);
    if (!currentFile) return;
    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {
      this.uppy.log("[Tus] Storing upload url");
      this.uppy.setFileState(currentFile.id, {
        tus: {
          ...currentFile.tus,
          uploadUrl: uploadURL
        }
      });
    }
  }
  install() {
    this.uppy.setState({
      capabilities: {
        ...this.uppy.getState().capabilities,
        resumableUploads: true
      }
    });
    this.uppy.addUploader(_classPrivateFieldLooseBase(this, _handleUpload)[_handleUpload]);
  }
  uninstall() {
    this.uppy.setState({
      capabilities: {
        ...this.uppy.getState().capabilities,
        resumableUploads: false
      }
    });
    this.uppy.removeUploader(_classPrivateFieldLooseBase(this, _handleUpload)[_handleUpload]);
  }
}
function _uploadLocalFile2(file) {
  this.resetUploaderReferences(file.id);
  return new Promise((resolve2, reject) => {
    let queuedRequest;
    let qRequest;
    let upload;
    const opts = {
      ...this.opts,
      ...file.tus || {}
    };
    if (typeof opts.headers === "function") {
      opts.headers = opts.headers(file);
    }
    const {
      onShouldRetry,
      onBeforeRequest,
      ...commonOpts
    } = opts;
    const uploadOptions = {
      ...tusDefaultOptions,
      ...commonOpts
    };
    uploadOptions.fingerprint = getFingerprint(file);
    uploadOptions.onBeforeRequest = async (req) => {
      const xhr = req.getUnderlyingObject();
      xhr.withCredentials = !!opts.withCredentials;
      let userProvidedPromise;
      if (typeof onBeforeRequest === "function") {
        userProvidedPromise = onBeforeRequest(req, file);
      }
      if (has(queuedRequest, "shouldBeRequeued")) {
        if (!queuedRequest.shouldBeRequeued) return Promise.reject();
        let done;
        const p = new Promise((res) => {
          done = res;
        });
        queuedRequest = this.requests.run(() => {
          if (file.isPaused) {
            queuedRequest.abort();
          }
          done();
          return () => {
          };
        });
        await Promise.all([p, userProvidedPromise]);
        return void 0;
      }
      return userProvidedPromise;
    };
    uploadOptions.onError = (err) => {
      var _queuedRequest;
      this.uppy.log(err);
      const xhr = err.originalRequest != null ? err.originalRequest.getUnderlyingObject() : null;
      if (isNetworkError$1(xhr)) {
        err = new NetworkError(err, xhr);
      }
      this.resetUploaderReferences(file.id);
      (_queuedRequest = queuedRequest) == null || _queuedRequest.abort();
      this.uppy.emit("upload-error", file, err);
      if (typeof opts.onError === "function") {
        opts.onError(err);
      }
      reject(err);
    };
    uploadOptions.onProgress = (bytesUploaded, bytesTotal) => {
      var _latestFile$progress$;
      this.onReceiveUploadUrl(file, upload.url);
      if (typeof opts.onProgress === "function") {
        opts.onProgress(bytesUploaded, bytesTotal);
      }
      const latestFile = this.uppy.getFile(file.id);
      this.uppy.emit("upload-progress", latestFile, {
        uploadStarted: (_latestFile$progress$ = latestFile.progress.uploadStarted) != null ? _latestFile$progress$ : 0,
        bytesUploaded,
        bytesTotal
      });
    };
    uploadOptions.onSuccess = () => {
      var _upload$url;
      const uploadResp = {
        uploadURL: (_upload$url = upload.url) != null ? _upload$url : void 0,
        status: 200,
        body: {}
      };
      this.resetUploaderReferences(file.id);
      queuedRequest.done();
      this.uppy.emit("upload-success", this.uppy.getFile(file.id), uploadResp);
      if (upload.url) {
        const {
          name: name2
        } = upload.file;
        this.uppy.log(`Download ${name2} from ${upload.url}`);
      }
      if (typeof opts.onSuccess === "function") {
        opts.onSuccess();
      }
      resolve2(upload);
    };
    const defaultOnShouldRetry2 = (err) => {
      var _err$originalResponse;
      const status = err == null || (_err$originalResponse = err.originalResponse) == null ? void 0 : _err$originalResponse.getStatus();
      if (status === 429) {
        if (!this.requests.isPaused) {
          var _classPrivateFieldLoo;
          const next = (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _retryDelayIterator)[_retryDelayIterator]) == null ? void 0 : _classPrivateFieldLoo.next();
          if (next == null || next.done) {
            return false;
          }
          this.requests.rateLimit(next.value);
        }
      } else if (status != null && status > 400 && status < 500 && status !== 409 && status !== 423) {
        return false;
      } else if (typeof navigator !== "undefined" && navigator.onLine === false) {
        if (!this.requests.isPaused) {
          this.requests.pause();
          window.addEventListener("online", () => {
            this.requests.resume();
          }, {
            once: true
          });
        }
      }
      queuedRequest.abort();
      queuedRequest = {
        shouldBeRequeued: true,
        abort() {
          this.shouldBeRequeued = false;
        },
        done() {
          throw new Error("Cannot mark a queued request as done: this indicates a bug");
        },
        fn() {
          throw new Error("Cannot run a queued request: this indicates a bug");
        }
      };
      return true;
    };
    if (onShouldRetry != null) {
      uploadOptions.onShouldRetry = (error, retryAttempt) => onShouldRetry(error, retryAttempt, opts, defaultOnShouldRetry2);
    } else {
      uploadOptions.onShouldRetry = defaultOnShouldRetry2;
    }
    const copyProp = (obj, srcProp, destProp) => {
      if (has(obj, srcProp) && !has(obj, destProp)) {
        obj[destProp] = obj[srcProp];
      }
    };
    const meta = {};
    const allowedMetaFields = getAllowedMetaFields(opts.allowedMetaFields, file.meta);
    allowedMetaFields.forEach((item) => {
      meta[item] = String(file.meta[item]);
    });
    copyProp(meta, "type", "filetype");
    copyProp(meta, "name", "filename");
    uploadOptions.metadata = meta;
    upload = new Upload(file.data, uploadOptions);
    this.uploaders[file.id] = upload;
    const eventManager = new EventManager(this.uppy);
    this.uploaderEvents[file.id] = eventManager;
    qRequest = () => {
      if (!file.isPaused) {
        upload.start();
      }
      return () => {
      };
    };
    upload.findPreviousUploads().then((previousUploads) => {
      const previousUpload = previousUploads[0];
      if (previousUpload) {
        this.uppy.log(`[Tus] Resuming upload of ${file.id} started at ${previousUpload.creationTime}`);
        upload.resumeFromPreviousUpload(previousUpload);
      }
    });
    queuedRequest = this.requests.run(qRequest);
    eventManager.onFileRemove(file.id, (targetFileID) => {
      queuedRequest.abort();
      this.resetUploaderReferences(file.id, {
        abort: !!upload.url
      });
      resolve2(`upload ${targetFileID} was removed`);
    });
    eventManager.onPause(file.id, (isPaused) => {
      queuedRequest.abort();
      if (isPaused) {
        upload.abort();
      } else {
        queuedRequest = this.requests.run(qRequest);
      }
    });
    eventManager.onPauseAll(file.id, () => {
      queuedRequest.abort();
      upload.abort();
    });
    eventManager.onCancelAll(file.id, () => {
      queuedRequest.abort();
      this.resetUploaderReferences(file.id, {
        abort: !!upload.url
      });
      resolve2(`upload ${file.id} was canceled`);
    });
    eventManager.onResumeAll(file.id, () => {
      queuedRequest.abort();
      if (file.error) {
        upload.abort();
      }
      queuedRequest = this.requests.run(qRequest);
    });
  }).catch((err) => {
    this.uppy.emit("upload-error", file, err);
    throw err;
  });
}
function _getCompanionClientArgs2(file) {
  var _file$remote;
  const opts = {
    ...this.opts
  };
  if (file.tus) {
    Object.assign(opts, file.tus);
  }
  if (typeof opts.headers === "function") {
    opts.headers = opts.headers(file);
  }
  return {
    ...(_file$remote = file.remote) == null ? void 0 : _file$remote.body,
    endpoint: opts.endpoint,
    uploadUrl: opts.uploadUrl,
    protocol: "tus",
    size: file.data.size,
    headers: opts.headers,
    metadata: file.meta
  };
}
async function _uploadFiles2(files) {
  const filesFiltered = filterNonFailedFiles(files);
  const filesToEmit = filterFilesToEmitUploadStarted(filesFiltered);
  this.uppy.emit("upload-start", filesToEmit);
  await Promise.allSettled(filesFiltered.map((file) => {
    if (file.isRemote) {
      const getQueue = () => this.requests;
      const controller = new AbortController();
      const removedHandler = (removedFile) => {
        if (removedFile.id === file.id) controller.abort();
      };
      this.uppy.on("file-removed", removedHandler);
      const uploadPromise = this.uppy.getRequestClientForFile(file).uploadRemoteFile(file, _classPrivateFieldLooseBase(this, _getCompanionClientArgs)[_getCompanionClientArgs](file), {
        signal: controller.signal,
        getQueue
      });
      this.requests.wrapSyncFunction(() => {
        this.uppy.off("file-removed", removedHandler);
      }, {
        priority: -1
      })();
      return uploadPromise;
    }
    return _classPrivateFieldLooseBase(this, _uploadLocalFile)[_uploadLocalFile](file);
  }));
}
Tus.VERSION = packageJson.version;
function assign(obj, props) {
  for (const key in props) {
    Object.defineProperty(obj, key, {
      value: props[key],
      enumerable: true,
      configurable: true
    });
  }
  return obj;
}
function createError(err, code2, props) {
  if (!err || typeof err === "string") {
    throw new TypeError("Please pass an Error to err-code");
  }
  if (!props) {
    props = {};
  }
  if (typeof code2 === "object") {
    props = code2;
    code2 = "";
  }
  if (code2) {
    props.code = code2;
  }
  try {
    return assign(err, props);
  } catch (_) {
    props.message = err.message;
    props.stack = err.stack;
    const ErrClass = function() {
    };
    ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
    const output2 = assign(new ErrClass(), props);
    return output2;
  }
}
var errCode = createError;
const errCode$1 = /* @__PURE__ */ getDefaultExportFromCjs(errCode);
function isAsyncIterable$c(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function first(source) {
  if (isAsyncIterable$c(source)) {
    return (async () => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    })();
  }
  for (const entry of source) {
    return entry;
  }
  return void 0;
}
function isAsyncIterable$b(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function batch(source, size = 1) {
  size = Number(size);
  if (isAsyncIterable$b(source)) {
    return async function* () {
      let things = [];
      if (size < 1) {
        size = 1;
      }
      if (size !== Math.round(size)) {
        throw new Error("Batch size must be an integer");
      }
      for await (const thing of source) {
        things.push(thing);
        while (things.length >= size) {
          yield things.slice(0, size);
          things = things.slice(size);
        }
      }
      while (things.length > 0) {
        yield things.slice(0, size);
        things = things.slice(size);
      }
    }();
  }
  return function* () {
    let things = [];
    if (size < 1) {
      size = 1;
    }
    if (size !== Math.round(size)) {
      throw new Error("Batch size must be an integer");
    }
    for (const thing of source) {
      things.push(thing);
      while (things.length >= size) {
        yield things.slice(0, size);
        things = things.slice(size);
      }
    }
    while (things.length > 0) {
      yield things.slice(0, size);
      things = things.slice(size);
    }
  }();
}
async function* parallelBatch(source, size = 1) {
  for await (const tasks of batch(source, size)) {
    const things = tasks.map(async (p) => {
      return p().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
    });
    for (let i = 0; i < things.length; i++) {
      const result = await things[i];
      if (result.ok) {
        yield result.value;
      } else {
        throw result.err;
      }
    }
  }
}
function alloc$2(size = 0) {
  return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
  return new Uint8Array(size);
}
function asUint8Array(buf2) {
  return buf2;
}
function concat$2(arrays, length2) {
  if (length2 == null) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output2.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output2);
}
function equals(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
const symbol$1 = Symbol.for("@achingbrain/uint8arraylist");
function findBufAndOffset(bufs, index2) {
  if (index2 == null || index2 < 0) {
    throw new RangeError("index is out of bounds");
  }
  let offset = 0;
  for (const buf2 of bufs) {
    const bufEnd = offset + buf2.byteLength;
    if (index2 < bufEnd) {
      return {
        buf: buf2,
        index: index2 - offset
      };
    }
    offset = bufEnd;
  }
  throw new RangeError("index is out of bounds");
}
function isUint8ArrayList(value) {
  return Boolean(value == null ? void 0 : value[symbol$1]);
}
class Uint8ArrayList {
  constructor(...data) {
    __publicField(this, "bufs");
    __publicField(this, "length");
    __publicField(this, _a2, true);
    this.bufs = [];
    this.length = 0;
    if (data.length > 0) {
      this.appendAll(data);
    }
  }
  *[(_a2 = symbol$1, Symbol.iterator)]() {
    yield* this.bufs;
  }
  get byteLength() {
    return this.length;
  }
  /**
   * Add one or more `bufs` to the end of this Uint8ArrayList
   */
  append(...bufs) {
    this.appendAll(bufs);
  }
  /**
   * Add all `bufs` to the end of this Uint8ArrayList
   */
  appendAll(bufs) {
    let length2 = 0;
    for (const buf2 of bufs) {
      if (buf2 instanceof Uint8Array) {
        length2 += buf2.byteLength;
        this.bufs.push(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length2 += buf2.byteLength;
        this.bufs.push(...buf2.bufs);
      } else {
        throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length2;
  }
  /**
   * Add one or more `bufs` to the start of this Uint8ArrayList
   */
  prepend(...bufs) {
    this.prependAll(bufs);
  }
  /**
   * Add all `bufs` to the start of this Uint8ArrayList
   */
  prependAll(bufs) {
    let length2 = 0;
    for (const buf2 of bufs.reverse()) {
      if (buf2 instanceof Uint8Array) {
        length2 += buf2.byteLength;
        this.bufs.unshift(buf2);
      } else if (isUint8ArrayList(buf2)) {
        length2 += buf2.byteLength;
        this.bufs.unshift(...buf2.bufs);
      } else {
        throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    this.length += length2;
  }
  /**
   * Read the value at `index`
   */
  get(index2) {
    const res = findBufAndOffset(this.bufs, index2);
    return res.buf[res.index];
  }
  /**
   * Set the value at `index` to `value`
   */
  set(index2, value) {
    const res = findBufAndOffset(this.bufs, index2);
    res.buf[res.index] = value;
  }
  /**
   * Copy bytes from `buf` to the index specified by `offset`
   */
  write(buf2, offset = 0) {
    if (buf2 instanceof Uint8Array) {
      for (let i = 0; i < buf2.length; i++) {
        this.set(offset + i, buf2[i]);
      }
    } else if (isUint8ArrayList(buf2)) {
      for (let i = 0; i < buf2.length; i++) {
        this.set(offset + i, buf2.get(i));
      }
    } else {
      throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
    }
  }
  /**
   * Remove bytes from the front of the pool
   */
  consume(bytes2) {
    bytes2 = Math.trunc(bytes2);
    if (Number.isNaN(bytes2) || bytes2 <= 0) {
      return;
    }
    if (bytes2 === this.byteLength) {
      this.bufs = [];
      this.length = 0;
      return;
    }
    while (this.bufs.length > 0) {
      if (bytes2 >= this.bufs[0].byteLength) {
        bytes2 -= this.bufs[0].byteLength;
        this.length -= this.bufs[0].byteLength;
        this.bufs.shift();
      } else {
        this.bufs[0] = this.bufs[0].subarray(bytes2);
        this.length -= bytes2;
        break;
      }
    }
  }
  /**
   * Extracts a section of an array and returns a new array.
   *
   * This is a copy operation as it is with Uint8Arrays and Arrays
   * - note this is different to the behaviour of Node Buffers.
   */
  slice(beginInclusive, endExclusive) {
    const { bufs, length: length2 } = this._subList(beginInclusive, endExclusive);
    return concat$2(bufs, length2);
  }
  /**
   * Returns a alloc from the given start and end element index.
   *
   * In the best case where the data extracted comes from a single Uint8Array
   * internally this is a no-copy operation otherwise it is a copy operation.
   */
  subarray(beginInclusive, endExclusive) {
    const { bufs, length: length2 } = this._subList(beginInclusive, endExclusive);
    if (bufs.length === 1) {
      return bufs[0];
    }
    return concat$2(bufs, length2);
  }
  /**
   * Returns a allocList from the given start and end element index.
   *
   * This is a no-copy operation.
   */
  sublist(beginInclusive, endExclusive) {
    const { bufs, length: length2 } = this._subList(beginInclusive, endExclusive);
    const list = new Uint8ArrayList();
    list.length = length2;
    list.bufs = [...bufs];
    return list;
  }
  _subList(beginInclusive, endExclusive) {
    beginInclusive = beginInclusive ?? 0;
    endExclusive = endExclusive ?? this.length;
    if (beginInclusive < 0) {
      beginInclusive = this.length + beginInclusive;
    }
    if (endExclusive < 0) {
      endExclusive = this.length + endExclusive;
    }
    if (beginInclusive < 0 || endExclusive > this.length) {
      throw new RangeError("index is out of bounds");
    }
    if (beginInclusive === endExclusive) {
      return { bufs: [], length: 0 };
    }
    if (beginInclusive === 0 && endExclusive === this.length) {
      return { bufs: this.bufs, length: this.length };
    }
    const bufs = [];
    let offset = 0;
    for (let i = 0; i < this.bufs.length; i++) {
      const buf2 = this.bufs[i];
      const bufStart = offset;
      const bufEnd = bufStart + buf2.byteLength;
      offset = bufEnd;
      if (beginInclusive >= bufEnd) {
        continue;
      }
      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
      if (sliceStartInBuf && sliceEndsInBuf) {
        if (beginInclusive === bufStart && endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        const start2 = beginInclusive - bufStart;
        bufs.push(buf2.subarray(start2, start2 + (endExclusive - beginInclusive)));
        break;
      }
      if (sliceStartInBuf) {
        if (beginInclusive === 0) {
          bufs.push(buf2);
          continue;
        }
        bufs.push(buf2.subarray(beginInclusive - bufStart));
        continue;
      }
      if (sliceEndsInBuf) {
        if (endExclusive === bufEnd) {
          bufs.push(buf2);
          break;
        }
        bufs.push(buf2.subarray(0, endExclusive - bufStart));
        break;
      }
      bufs.push(buf2);
    }
    return { bufs, length: endExclusive - beginInclusive };
  }
  indexOf(search, offset = 0) {
    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
      throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
    }
    const needle = search instanceof Uint8Array ? search : search.subarray();
    offset = Number(offset ?? 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const M2 = needle.byteLength;
    if (M2 === 0) {
      throw new TypeError("search must be at least 1 byte long");
    }
    const radix = 256;
    const rightmostPositions = new Int32Array(radix);
    for (let c = 0; c < radix; c++) {
      rightmostPositions[c] = -1;
    }
    for (let j = 0; j < M2; j++) {
      rightmostPositions[needle[j]] = j;
    }
    const right = rightmostPositions;
    const lastIndex = this.byteLength - needle.byteLength;
    const lastPatIndex = needle.byteLength - 1;
    let skip;
    for (let i = offset; i <= lastIndex; i += skip) {
      skip = 0;
      for (let j = lastPatIndex; j >= 0; j--) {
        const char = this.get(i + j);
        if (needle[j] !== char) {
          skip = Math.max(1, j - right[char]);
          break;
        }
      }
      if (skip === 0) {
        return i;
      }
    }
    return -1;
  }
  getInt8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt8(0);
  }
  setInt8(byteOffset, value) {
    const buf2 = allocUnsafe(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt8(0, value);
    this.write(buf2, byteOffset);
  }
  getInt16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt16(0, littleEndian);
  }
  setInt16(byteOffset, value, littleEndian) {
    const buf2 = alloc$2(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt16(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getInt32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getInt32(0, littleEndian);
  }
  setInt32(byteOffset, value, littleEndian) {
    const buf2 = alloc$2(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setInt32(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigInt64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigInt64(0, littleEndian);
  }
  setBigInt64(byteOffset, value, littleEndian) {
    const buf2 = alloc$2(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigInt64(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint8(byteOffset) {
    const buf2 = this.subarray(byteOffset, byteOffset + 1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint8(0);
  }
  setUint8(byteOffset, value) {
    const buf2 = allocUnsafe(1);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint8(0, value);
    this.write(buf2, byteOffset);
  }
  getUint16(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint16(0, littleEndian);
  }
  setUint16(byteOffset, value, littleEndian) {
    const buf2 = alloc$2(2);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint16(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getUint32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getUint32(0, littleEndian);
  }
  setUint32(byteOffset, value, littleEndian) {
    const buf2 = alloc$2(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setUint32(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getBigUint64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getBigUint64(0, littleEndian);
  }
  setBigUint64(byteOffset, value, littleEndian) {
    const buf2 = alloc$2(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setBigUint64(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat32(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat32(0, littleEndian);
  }
  setFloat32(byteOffset, value, littleEndian) {
    const buf2 = alloc$2(4);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat32(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  getFloat64(byteOffset, littleEndian) {
    const buf2 = this.subarray(byteOffset, byteOffset + 8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    return view.getFloat64(0, littleEndian);
  }
  setFloat64(byteOffset, value, littleEndian) {
    const buf2 = alloc$2(8);
    const view = new DataView(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    view.setFloat64(0, value, littleEndian);
    this.write(buf2, byteOffset);
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (!(other instanceof Uint8ArrayList)) {
      return false;
    }
    if (other.bufs.length !== this.bufs.length) {
      return false;
    }
    for (let i = 0; i < this.bufs.length; i++) {
      if (!equals(this.bufs[i], other.bufs[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
   * method if you know the total size of all the Uint8Arrays ahead of time.
   */
  static fromUint8Arrays(bufs, length2) {
    const list = new Uint8ArrayList();
    list.bufs = bufs;
    if (length2 == null) {
      length2 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
    }
    list.length = length2;
    return list;
  }
}
const DEFAULT_CHUNK_SIZE = 262144;
const fixedSize = (options2 = {}) => {
  const chunkSize = options2.chunkSize ?? DEFAULT_CHUNK_SIZE;
  return async function* fixedSizeChunker(source) {
    let list = new Uint8ArrayList();
    let currentLength = 0;
    let emitted = false;
    for await (const buffer2 of source) {
      list.append(buffer2);
      currentLength += buffer2.length;
      while (currentLength >= chunkSize) {
        yield list.slice(0, chunkSize);
        emitted = true;
        if (chunkSize === list.length) {
          list = new Uint8ArrayList();
          currentLength = 0;
        } else {
          const newBl = new Uint8ArrayList();
          newBl.append(list.sublist(chunkSize));
          list = newBl;
          currentLength -= chunkSize;
        }
      }
    }
    if (!emitted || currentLength > 0) {
      yield list.subarray(0, currentLength);
    }
  };
};
const textDecoder$2 = new TextDecoder();
function decodeVarint$1(bytes2, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes2[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [v, offset];
}
function decodeBytes(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint$1(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [bytes2.subarray(offset, postOffset), postOffset];
}
function decodeKey(bytes2, index2) {
  let wire;
  [wire, index2] = decodeVarint$1(bytes2, index2);
  return [wire & 7, wire >> 3, index2];
}
function decodeLink(bytes2) {
  const link = {};
  const l = bytes2.length;
  let index2 = 0;
  while (index2 < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index2] = decodeBytes(bytes2, index2);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      link.Name = textDecoder$2.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index2] = decodeVarint$1(bytes2, index2);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index2 > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes2) {
  const l = bytes2.length;
  let index2 = 0;
  let links2 = void 0;
  let linksBeforeData = false;
  let data = void 0;
  while (index2 < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index2] = decodeKey(bytes2, index2);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index2] = decodeBytes(bytes2, index2);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index2] = decodeBytes(bytes2, index2);
      links2.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index2 > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links2 || [];
  return node;
}
const textEncoder$2 = new TextEncoder();
const maxInt32 = 2 ** 32;
const maxUInt32 = 2 ** 31;
function encodeLink(link, bytes2) {
  let i = bytes2.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes2, i, link.Tsize) - 1;
    bytes2[i] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder$2.encode(link.Name);
    i -= nameBytes.length;
    bytes2.set(nameBytes, i);
    i = encodeVarint(bytes2, i, nameBytes.length) - 1;
    bytes2[i] = 18;
  }
  if (link.Hash) {
    i -= link.Hash.length;
    bytes2.set(link.Hash, i);
    i = encodeVarint(bytes2, i, link.Hash.length) - 1;
    bytes2[i] = 10;
  }
  return bytes2.length - i;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes2 = new Uint8Array(size);
  let i = size;
  if (node.Data) {
    i -= node.Data.length;
    bytes2.set(node.Data, i);
    i = encodeVarint(bytes2, i, node.Data.length) - 1;
    bytes2[i] = 10;
  }
  if (node.Links) {
    for (let index2 = node.Links.length - 1; index2 >= 0; index2--) {
      const size2 = encodeLink(node.Links[index2], bytes2.subarray(0, i));
      i -= size2;
      i = encodeVarint(bytes2, i, size2) - 1;
      bytes2[i] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder$2.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes2, offset, v) {
  offset -= sov(v);
  const base = offset;
  while (v >= maxUInt32) {
    bytes2[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes2[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes2[offset] = v;
  return base;
}
function sov(x2) {
  if (x2 % 2 === 0) {
    x2++;
  }
  return Math.floor((len64(x2) + 6) / 7);
}
function len64(x2) {
  let n = 0;
  if (x2 >= maxInt32) {
    x2 = Math.floor(x2 / maxInt32);
    n = 32;
  }
  if (x2 >= 1 << 16) {
    x2 >>>= 16;
    n += 16;
  }
  if (x2 >= 1 << 8) {
    x2 >>>= 8;
    n += 8;
  }
  return n + len8tab[x2];
}
const len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];
const pbNodeProperties = ["Data", "Links"];
const pbLinkProperties = ["Hash", "Name", "Tsize"];
const textEncoder$1 = new TextEncoder();
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder$1.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder$1.encode(b.Name) : [];
  let x2 = abuf.length;
  let y2 = bbuf.length;
  for (let i = 0, len2 = Math.min(x2, y2); i < len2; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x2 = abuf[i];
      y2 = bbuf[i];
      break;
    }
  }
  return x2 < y2 ? -1 : y2 < x2 ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash2 = CID.asCID(link);
    if (!Hash2) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash: Hash2 };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder$1.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate$1(node) {
  if (!node || typeof node !== "object" || Array.isArray(node) || node instanceof Uint8Array || node["/"] && node["/"] === node.bytes) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be bytes)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be a list)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link = node.Links[i];
    if (!link || typeof link !== "object" || Array.isArray(link) || link instanceof Uint8Array || link["/"] && link["/"] === link.bytes) {
      throw new TypeError("Invalid DAG-PB form (bad link)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");
    }
    if (link.Hash === void 0) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash == null || !link.Hash["/"] || link.Hash["/"] !== link.Hash.bytes) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0) {
      if (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
      }
      if (link.Tsize < 0) {
        throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)");
      }
    }
    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links2 = []) {
  return prepare({ Data: data, Links: links2 });
}
function createLink(name2, size, cid) {
  return asLink({ Hash: cid, Name: name2, Tsize: size });
}
function toByteView$2(buf2) {
  if (buf2 instanceof ArrayBuffer) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }
  return buf2;
}
const name$2 = "dag-pb";
const code$5 = 112;
function encode$7(node) {
  validate$1(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode$a(bytes2) {
  const buf2 = toByteView$2(bytes2);
  const pbn = decodeNode(buf2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}
const dagPB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code: code$5,
  createLink,
  createNode,
  decode: decode$a,
  encode: encode$7,
  name: name$2,
  prepare,
  validate: validate$1
}, Symbol.toStringTag, { value: "Module" }));
const N1$1 = Math.pow(2, 7);
const N2$1 = Math.pow(2, 14);
const N3$1 = Math.pow(2, 21);
const N4$1 = Math.pow(2, 28);
const N5$1 = Math.pow(2, 35);
const N6$1 = Math.pow(2, 42);
const N7$1 = Math.pow(2, 49);
const MSB$2 = 128;
const REST$2 = 127;
function encodingLength(value) {
  if (value < N1$1) {
    return 1;
  }
  if (value < N2$1) {
    return 2;
  }
  if (value < N3$1) {
    return 3;
  }
  if (value < N4$1) {
    return 4;
  }
  if (value < N5$1) {
    return 5;
  }
  if (value < N6$1) {
    return 6;
  }
  if (value < N7$1) {
    return 7;
  }
  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
    throw new RangeError("Could not encode varint");
  }
  return 8;
}
function encodeUint8Array(value, buf2, offset = 0) {
  switch (encodingLength(value)) {
    case 8: {
      buf2[offset++] = value & 255 | MSB$2;
      value /= 128;
    }
    case 7: {
      buf2[offset++] = value & 255 | MSB$2;
      value /= 128;
    }
    case 6: {
      buf2[offset++] = value & 255 | MSB$2;
      value /= 128;
    }
    case 5: {
      buf2[offset++] = value & 255 | MSB$2;
      value /= 128;
    }
    case 4: {
      buf2[offset++] = value & 255 | MSB$2;
      value >>>= 7;
    }
    case 3: {
      buf2[offset++] = value & 255 | MSB$2;
      value >>>= 7;
    }
    case 2: {
      buf2[offset++] = value & 255 | MSB$2;
      value >>>= 7;
    }
    case 1: {
      buf2[offset++] = value & 255;
      value >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf2;
}
function encodeUint8ArrayList(value, buf2, offset = 0) {
  switch (encodingLength(value)) {
    case 8: {
      buf2.set(offset++, value & 255 | MSB$2);
      value /= 128;
    }
    case 7: {
      buf2.set(offset++, value & 255 | MSB$2);
      value /= 128;
    }
    case 6: {
      buf2.set(offset++, value & 255 | MSB$2);
      value /= 128;
    }
    case 5: {
      buf2.set(offset++, value & 255 | MSB$2);
      value /= 128;
    }
    case 4: {
      buf2.set(offset++, value & 255 | MSB$2);
      value >>>= 7;
    }
    case 3: {
      buf2.set(offset++, value & 255 | MSB$2);
      value >>>= 7;
    }
    case 2: {
      buf2.set(offset++, value & 255 | MSB$2);
      value >>>= 7;
    }
    case 1: {
      buf2.set(offset++, value & 255);
      value >>>= 7;
      break;
    }
    default:
      throw new Error("unreachable");
  }
  return buf2;
}
function decodeUint8Array(buf2, offset) {
  let b = buf2[offset];
  let res = 0;
  res += b & REST$2;
  if (b < MSB$2) {
    return res;
  }
  b = buf2[offset + 1];
  res += (b & REST$2) << 7;
  if (b < MSB$2) {
    return res;
  }
  b = buf2[offset + 2];
  res += (b & REST$2) << 14;
  if (b < MSB$2) {
    return res;
  }
  b = buf2[offset + 3];
  res += (b & REST$2) << 21;
  if (b < MSB$2) {
    return res;
  }
  b = buf2[offset + 4];
  res += (b & REST$2) * N4$1;
  if (b < MSB$2) {
    return res;
  }
  b = buf2[offset + 5];
  res += (b & REST$2) * N5$1;
  if (b < MSB$2) {
    return res;
  }
  b = buf2[offset + 6];
  res += (b & REST$2) * N6$1;
  if (b < MSB$2) {
    return res;
  }
  b = buf2[offset + 7];
  res += (b & REST$2) * N7$1;
  if (b < MSB$2) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function decodeUint8ArrayList(buf2, offset) {
  let b = buf2.get(offset);
  let res = 0;
  res += b & REST$2;
  if (b < MSB$2) {
    return res;
  }
  b = buf2.get(offset + 1);
  res += (b & REST$2) << 7;
  if (b < MSB$2) {
    return res;
  }
  b = buf2.get(offset + 2);
  res += (b & REST$2) << 14;
  if (b < MSB$2) {
    return res;
  }
  b = buf2.get(offset + 3);
  res += (b & REST$2) << 21;
  if (b < MSB$2) {
    return res;
  }
  b = buf2.get(offset + 4);
  res += (b & REST$2) * N4$1;
  if (b < MSB$2) {
    return res;
  }
  b = buf2.get(offset + 5);
  res += (b & REST$2) * N5$1;
  if (b < MSB$2) {
    return res;
  }
  b = buf2.get(offset + 6);
  res += (b & REST$2) * N6$1;
  if (b < MSB$2) {
    return res;
  }
  b = buf2.get(offset + 7);
  res += (b & REST$2) * N7$1;
  if (b < MSB$2) {
    return res;
  }
  throw new RangeError("Could not decode varint");
}
function encode$6(value, buf2, offset = 0) {
  if (buf2 == null) {
    buf2 = allocUnsafe(encodingLength(value));
  }
  if (buf2 instanceof Uint8Array) {
    return encodeUint8Array(value, buf2, offset);
  } else {
    return encodeUint8ArrayList(value, buf2, offset);
  }
}
function decode$9(buf2, offset = 0) {
  if (buf2 instanceof Uint8Array) {
    return decodeUint8Array(buf2, offset);
  } else {
    return decodeUint8ArrayList(buf2, offset);
  }
}
const f32 = new Float32Array([-0]);
const f8b = new Uint8Array(f32.buffer);
function writeFloatLE(val, buf2, pos) {
  f32[0] = val;
  buf2[pos] = f8b[0];
  buf2[pos + 1] = f8b[1];
  buf2[pos + 2] = f8b[2];
  buf2[pos + 3] = f8b[3];
}
function readFloatLE(buf2, pos) {
  f8b[0] = buf2[pos];
  f8b[1] = buf2[pos + 1];
  f8b[2] = buf2[pos + 2];
  f8b[3] = buf2[pos + 3];
  return f32[0];
}
const f64 = new Float64Array([-0]);
const d8b = new Uint8Array(f64.buffer);
function writeDoubleLE(val, buf2, pos) {
  f64[0] = val;
  buf2[pos] = d8b[0];
  buf2[pos + 1] = d8b[1];
  buf2[pos + 2] = d8b[2];
  buf2[pos + 3] = d8b[3];
  buf2[pos + 4] = d8b[4];
  buf2[pos + 5] = d8b[5];
  buf2[pos + 6] = d8b[6];
  buf2[pos + 7] = d8b[7];
}
function readDoubleLE(buf2, pos) {
  d8b[0] = buf2[pos];
  d8b[1] = buf2[pos + 1];
  d8b[2] = buf2[pos + 2];
  d8b[3] = buf2[pos + 3];
  d8b[4] = buf2[pos + 4];
  d8b[5] = buf2[pos + 5];
  d8b[6] = buf2[pos + 6];
  d8b[7] = buf2[pos + 7];
  return f64[0];
}
const MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
const MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
class LongBits {
  constructor(lo, hi) {
    __publicField(this, "lo");
    __publicField(this, "hi");
    this.lo = lo | 0;
    this.hi = hi | 0;
  }
  /**
   * Converts this long bits to a possibly unsafe JavaScript number
   */
  toNumber(unsigned = false) {
    if (!unsigned && this.hi >>> 31 > 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }
  /**
   * Converts this long bits to a bigint
   */
  toBigInt(unsigned = false) {
    if (unsigned) {
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    if (this.hi >>> 31 !== 0) {
      const lo = ~this.lo + 1 >>> 0;
      let hi = ~this.hi >>> 0;
      if (lo === 0) {
        hi = hi + 1 >>> 0;
      }
      return -(BigInt(lo) + (BigInt(hi) << 32n));
    }
    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
  }
  /**
   * Converts this long bits to a string
   */
  toString(unsigned = false) {
    return this.toBigInt(unsigned).toString();
  }
  /**
   * Zig-zag encodes this long bits
   */
  zzEncode() {
    const mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Zig-zag decodes this long bits
   */
  zzDecode() {
    const mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  }
  /**
   * Calculates the length of this longbits when encoded as a varint.
   */
  length() {
    const part0 = this.lo;
    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
    const part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromBigInt(value) {
    if (value === 0n) {
      return zero;
    }
    if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {
      return this.fromNumber(Number(value));
    }
    const negative = value < 0n;
    if (negative) {
      value = -value;
    }
    let hi = value >> 32n;
    let lo = value - (hi << 32n);
    if (negative) {
      hi = ~hi | 0n;
      lo = ~lo | 0n;
      if (++lo > TWO_32) {
        lo = 0n;
        if (++hi > TWO_32) {
          hi = 0n;
        }
      }
    }
    return new LongBits(Number(lo), Number(hi));
  }
  /**
   * Constructs new long bits from the specified number
   */
  static fromNumber(value) {
    if (value === 0) {
      return zero;
    }
    const sign2 = value < 0;
    if (sign2) {
      value = -value;
    }
    let lo = value >>> 0;
    let hi = (value - lo) / 4294967296 >>> 0;
    if (sign2) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295) {
          hi = 0;
        }
      }
    }
    return new LongBits(lo, hi);
  }
  /**
   * Constructs new long bits from a number, long or string
   */
  static from(value) {
    if (typeof value === "number") {
      return LongBits.fromNumber(value);
    }
    if (typeof value === "bigint") {
      return LongBits.fromBigInt(value);
    }
    if (typeof value === "string") {
      return LongBits.fromBigInt(BigInt(value));
    }
    return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  }
}
const zero = new LongBits(0, 0);
zero.toBigInt = function() {
  return 0n;
};
zero.zzEncode = zero.zzDecode = function() {
  return this;
};
zero.length = function() {
  return 1;
};
const TWO_32 = 4294967296n;
function length$1(string2) {
  let len2 = 0;
  let c = 0;
  for (let i = 0; i < string2.length; ++i) {
    c = string2.charCodeAt(i);
    if (c < 128) {
      len2 += 1;
    } else if (c < 2048) {
      len2 += 2;
    } else if ((c & 64512) === 55296 && (string2.charCodeAt(i + 1) & 64512) === 56320) {
      ++i;
      len2 += 4;
    } else {
      len2 += 3;
    }
  }
  return len2;
}
function read$1(buffer2, start2, end) {
  const len2 = end - start2;
  if (len2 < 1) {
    return "";
  }
  let parts;
  const chunk = [];
  let i = 0;
  let t;
  while (start2 < end) {
    t = buffer2[start2++];
    if (t < 128) {
      chunk[i++] = t;
    } else if (t > 191 && t < 224) {
      chunk[i++] = (t & 31) << 6 | buffer2[start2++] & 63;
    } else if (t > 239 && t < 365) {
      t = ((t & 7) << 18 | (buffer2[start2++] & 63) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63) - 65536;
      chunk[i++] = 55296 + (t >> 10);
      chunk[i++] = 56320 + (t & 1023);
    } else {
      chunk[i++] = (t & 15) << 12 | (buffer2[start2++] & 63) << 6 | buffer2[start2++] & 63;
    }
    if (i > 8191) {
      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i = 0;
    }
  }
  if (parts != null) {
    if (i > 0) {
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
    }
    return parts.join("");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i));
}
function write(string2, buffer2, offset) {
  const start2 = offset;
  let c1;
  let c2;
  for (let i = 0; i < string2.length; ++i) {
    c1 = string2.charCodeAt(i);
    if (c1 < 128) {
      buffer2[offset++] = c1;
    } else if (c1 < 2048) {
      buffer2[offset++] = c1 >> 6 | 192;
      buffer2[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i;
      buffer2[offset++] = c1 >> 18 | 240;
      buffer2[offset++] = c1 >> 12 & 63 | 128;
      buffer2[offset++] = c1 >> 6 & 63 | 128;
      buffer2[offset++] = c1 & 63 | 128;
    } else {
      buffer2[offset++] = c1 >> 12 | 224;
      buffer2[offset++] = c1 >> 6 & 63 | 128;
      buffer2[offset++] = c1 & 63 | 128;
    }
  }
  return offset - start2;
}
function indexOutOfRange(reader, writeLength) {
  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);
}
function readFixed32End(buf2, end) {
  return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
}
class Uint8ArrayReader {
  constructor(buffer2) {
    __publicField(this, "buf");
    __publicField(this, "pos");
    __publicField(this, "len");
    __publicField(this, "_slice", Uint8Array.prototype.subarray);
    this.buf = buffer2;
    this.pos = 0;
    this.len = buffer2.length;
  }
  /**
   * Reads a varint as an unsigned 32 bit value
   */
  uint32() {
    let value = 4294967295;
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  }
  /**
   * Reads a varint as a signed 32 bit value
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Reads a zig-zag encoded varint as a signed 32 bit value
   */
  sint32() {
    const value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  }
  /**
   * Reads a varint as a boolean
   */
  bool() {
    return this.uint32() !== 0;
  }
  /**
   * Reads fixed 32 bits as an unsigned 32 bit integer
   */
  fixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4);
    return res;
  }
  /**
   * Reads fixed 32 bits as a signed 32 bit integer
   */
  sfixed32() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const res = readFixed32End(this.buf, this.pos += 4) | 0;
    return res;
  }
  /**
   * Reads a float (32 bit) as a number
   */
  float() {
    if (this.pos + 4 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value = readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  }
  /**
   * Reads a double (64 bit float) as a number
   */
  double() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 4);
    }
    const value = readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  }
  /**
   * Reads a sequence of bytes preceded by its length as a varint
   */
  bytes() {
    const length2 = this.uint32();
    const start2 = this.pos;
    const end = this.pos + length2;
    if (end > this.len) {
      throw indexOutOfRange(this, length2);
    }
    this.pos += length2;
    return start2 === end ? new Uint8Array(0) : this.buf.subarray(start2, end);
  }
  /**
   * Reads a string preceded by its byte length as a varint
   */
  string() {
    const bytes2 = this.bytes();
    return read$1(bytes2, 0, bytes2.length);
  }
  /**
   * Skips the specified number of bytes if specified, otherwise skips a varint
   */
  skip(length2) {
    if (typeof length2 === "number") {
      if (this.pos + length2 > this.len) {
        throw indexOutOfRange(this, length2);
      }
      this.pos += length2;
    } else {
      do {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
      } while ((this.buf[this.pos++] & 128) !== 0);
    }
    return this;
  }
  /**
   * Skips the next element of the specified wire type
   */
  skipType(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
    }
    return this;
  }
  readLongVarint() {
    const bits = new LongBits(0, 0);
    let i = 0;
    if (this.len - this.pos > 4) {
      for (; i < 4; ++i) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128) {
        return bits;
      }
      i = 0;
    } else {
      for (; i < 3; ++i) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (; i < 5; ++i) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
    } else {
      for (; i < 5; ++i) {
        if (this.pos >= this.len) {
          throw indexOutOfRange(this);
        }
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
      }
    }
    throw Error("invalid varint encoding");
  }
  readFixed64() {
    if (this.pos + 8 > this.len) {
      throw indexOutOfRange(this, 8);
    }
    const lo = readFixed32End(this.buf, this.pos += 4);
    const hi = readFixed32End(this.buf, this.pos += 4);
    return new LongBits(lo, hi);
  }
  /**
   * Reads a varint as a signed 64 bit value
   */
  int64() {
    return this.readLongVarint().toBigInt();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  int64Number() {
    return this.readLongVarint().toNumber();
  }
  /**
   * Reads a varint as a signed 64 bit value returned as a string
   */
  int64String() {
    return this.readLongVarint().toString();
  }
  /**
   * Reads a varint as an unsigned 64 bit value
   */
  uint64() {
    return this.readLongVarint().toBigInt(true);
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
   * JavaScript number
   */
  uint64Number() {
    const value = decodeUint8Array(this.buf, this.pos);
    this.pos += encodingLength(value);
    return value;
  }
  /**
   * Reads a varint as an unsigned 64 bit value returned as a string
   */
  uint64String() {
    return this.readLongVarint().toString(true);
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value
   */
  sint64() {
    return this.readLongVarint().zzDecode().toBigInt();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * possibly unsafe JavaScript number
   */
  sint64Number() {
    return this.readLongVarint().zzDecode().toNumber();
  }
  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
   * string
   */
  sint64String() {
    return this.readLongVarint().zzDecode().toString();
  }
  /**
   * Reads fixed 64 bits
   */
  fixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
   */
  fixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads fixed 64 bits returned as a string
   */
  fixed64String() {
    return this.readFixed64().toString();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits
   */
  sfixed64() {
    return this.readFixed64().toBigInt();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
   * JavaScript number
   */
  sfixed64Number() {
    return this.readFixed64().toNumber();
  }
  /**
   * Reads zig-zag encoded fixed 64 bits returned as a string
   */
  sfixed64String() {
    return this.readFixed64().toString();
  }
}
function createReader(buf2) {
  return new Uint8ArrayReader(buf2 instanceof Uint8Array ? buf2 : buf2.subarray());
}
function decodeMessage(buf2, codec, opts) {
  const reader = createReader(buf2);
  return codec.decode(reader, void 0, opts);
}
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("");
const alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode$5(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode$8(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from$1({
  prefix: "",
  name: "base256emoji",
  encode: encode$5,
  decode: decode$8
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const identity$1 = from$1({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString$5(buf2),
  decode: (str) => fromString$2(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$1
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
const textDecoder$1 = new TextDecoder();
const code$4 = 512;
function decode$7(data) {
  return JSON.parse(textDecoder$1.decode(data));
}
const name$1 = "raw";
const code$3 = 85;
function encode$4(node) {
  return coerce(node);
}
function decode$6(data) {
  return coerce(data);
}
const raw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  code: code$3,
  decode: decode$6,
  encode: encode$4,
  name: name$1
}, Symbol.toStringTag, { value: "Module" }));
const code$2 = 0;
const name = "identity";
const encode$3 = coerce;
function digest(input) {
  return create$2(code$2, encode$3(input));
}
const identity = { code: code$2, name, encode: encode$3, digest };
function from({ name: name2, code: code2, encode: encode2 }) {
  return new Hasher(name2, code2, encode2);
}
class Hasher {
  constructor(name2, code2, encode2) {
    __publicField(this, "name");
    __publicField(this, "code");
    __publicField(this, "encode");
    this.name = name2;
    this.code = code2;
    this.encode = encode2;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create$2(this.code, result) : result.then((digest2) => create$2(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
function sha(name2) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
}
const sha256$1 = from({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
const sha512$1 = from({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});
const bases = { ...identityBase, ...base2$1, ...base8$1, ...base10$1, ...base16$1, ...base32, ...base36$1, ...base58, ...base64$1, ...base256emoji$1 };
function createCodec$1(name2, prefix, encode2, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode2
    },
    decoder: {
      decode: decode2
    }
  };
}
const string$1 = createCodec$1("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec$1("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i = 0; i < buf2.length; i++) {
    string2 += String.fromCharCode(buf2[i]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf2[i] = str.charCodeAt(i);
  }
  return buf2;
});
const BASES = {
  utf8: string$1,
  "utf-8": string$1,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString$1(string2, encoding = "utf8") {
  const base = BASES[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base.decoder.decode(`${base.prefix}${string2}`);
}
function pool(size) {
  const SIZE = 8192;
  const MAX = SIZE >>> 1;
  let slab;
  let offset = SIZE;
  return function poolAlloc(size2) {
    if (size2 < 1 || size2 > MAX) {
      return allocUnsafe(size2);
    }
    if (offset + size2 > SIZE) {
      slab = allocUnsafe(SIZE);
      offset = 0;
    }
    const buf2 = slab.subarray(offset, offset += size2);
    if ((offset & 7) !== 0) {
      offset = (offset | 7) + 1;
    }
    return buf2;
  };
}
class Op {
  constructor(fn, len2, val) {
    /**
     * Function to call
     */
    __publicField(this, "fn");
    /**
     * Value byte length
     */
    __publicField(this, "len");
    /**
     * Next operation
     */
    __publicField(this, "next");
    /**
     * Value to write
     */
    __publicField(this, "val");
    this.fn = fn;
    this.len = len2;
    this.next = void 0;
    this.val = val;
  }
}
function noop$1() {
}
class State {
  constructor(writer) {
    /**
     * Current head
     */
    __publicField(this, "head");
    /**
     * Current tail
     */
    __publicField(this, "tail");
    /**
     * Current buffer length
     */
    __publicField(this, "len");
    /**
     * Next state
     */
    __publicField(this, "next");
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
}
const bufferPool = pool();
function alloc$1(size) {
  if (globalThis.Buffer != null) {
    return allocUnsafe(size);
  }
  return bufferPool(size);
}
class Uint8ArrayWriter {
  constructor() {
    /**
     * Current length
     */
    __publicField(this, "len");
    /**
     * Operations head
     */
    __publicField(this, "head");
    /**
     * Operations tail
     */
    __publicField(this, "tail");
    /**
     * Linked forked states
     */
    __publicField(this, "states");
    this.len = 0;
    this.head = new Op(noop$1, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  /**
   * Pushes a new operation to the queue
   */
  _push(fn, len2, val) {
    this.tail = this.tail.next = new Op(fn, len2, val);
    this.len += len2;
    return this;
  }
  /**
   * Writes an unsigned 32 bit value as a varint
   */
  uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  }
  /**
   * Writes a signed 32 bit value as a varint`
   */
  int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  }
  /**
   * Writes a 32 bit value as a varint, zig-zag encoded
   */
  sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64(value) {
    const bits = LongBits.fromBigInt(value);
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64Number(value) {
    return this._push(encodeUint8Array, encodingLength(value), value);
  }
  /**
   * Writes an unsigned 64 bit value as a varint
   */
  uint64String(value) {
    return this.uint64(BigInt(value));
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64(value) {
    return this.uint64(value);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64Number(value) {
    return this.uint64Number(value);
  }
  /**
   * Writes a signed 64 bit value as a varint
   */
  int64String(value) {
    return this.uint64String(value);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64(value) {
    const bits = LongBits.fromBigInt(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64Number(value) {
    const bits = LongBits.fromNumber(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  }
  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded
   */
  sint64String(value) {
    return this.sint64(BigInt(value));
  }
  /**
   * Writes a boolish value as a varint
   */
  bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  }
  /**
   * Writes an unsigned 32 bit value as fixed 32 bits
   */
  fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  }
  /**
   * Writes a signed 32 bit value as fixed 32 bits
   */
  sfixed32(value) {
    return this.fixed32(value);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64(value) {
    const bits = LongBits.fromBigInt(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64Number(value) {
    const bits = LongBits.fromNumber(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  }
  /**
   * Writes an unsigned 64 bit value as fixed 64 bits
   */
  fixed64String(value) {
    return this.fixed64(BigInt(value));
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64(value) {
    return this.fixed64(value);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64Number(value) {
    return this.fixed64Number(value);
  }
  /**
   * Writes a signed 64 bit value as fixed 64 bits
   */
  sfixed64String(value) {
    return this.fixed64String(value);
  }
  /**
   * Writes a float (32 bit)
   */
  float(value) {
    return this._push(writeFloatLE, 4, value);
  }
  /**
   * Writes a double (64 bit float).
   *
   * @function
   * @param {number} value - Value to write
   * @returns {Writer} `this`
   */
  double(value) {
    return this._push(writeDoubleLE, 8, value);
  }
  /**
   * Writes a sequence of bytes
   */
  bytes(value) {
    const len2 = value.length >>> 0;
    if (len2 === 0) {
      return this._push(writeByte, 1, 0);
    }
    return this.uint32(len2)._push(writeBytes, len2, value);
  }
  /**
   * Writes a string
   */
  string(value) {
    const len2 = length$1(value);
    return len2 !== 0 ? this.uint32(len2)._push(write, len2, value) : this._push(writeByte, 1, 0);
  }
  /**
   * Forks this writer's state by pushing it to a stack.
   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
   */
  fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop$1, 0, 0);
    this.len = 0;
    return this;
  }
  /**
   * Resets this instance to the last state
   */
  reset() {
    if (this.states != null) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop$1, 0, 0);
      this.len = 0;
    }
    return this;
  }
  /**
   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
   */
  ldelim() {
    const head = this.head;
    const tail = this.tail;
    const len2 = this.len;
    this.reset().uint32(len2);
    if (len2 !== 0) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len2;
    }
    return this;
  }
  /**
   * Finishes the write operation
   */
  finish() {
    let head = this.head.next;
    const buf2 = alloc$1(this.len);
    let pos = 0;
    while (head != null) {
      head.fn(head.val, buf2, pos);
      pos += head.len;
      head = head.next;
    }
    return buf2;
  }
}
function writeByte(val, buf2, pos) {
  buf2[pos] = val & 255;
}
function writeVarint32(val, buf2, pos) {
  while (val > 127) {
    buf2[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf2[pos] = val;
}
class VarintOp extends Op {
  constructor(len2, val) {
    super(writeVarint32, len2, val);
    __publicField(this, "next");
    this.next = void 0;
  }
}
function writeVarint64(val, buf2, pos) {
  while (val.hi !== 0) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf2[pos++] = val.lo;
}
function writeFixed32(val, buf2, pos) {
  buf2[pos] = val & 255;
  buf2[pos + 1] = val >>> 8 & 255;
  buf2[pos + 2] = val >>> 16 & 255;
  buf2[pos + 3] = val >>> 24;
}
function writeBytes(val, buf2, pos) {
  buf2.set(val, pos);
}
if (globalThis.Buffer != null) {
  Uint8ArrayWriter.prototype.bytes = function(value) {
    const len2 = value.length >>> 0;
    this.uint32(len2);
    if (len2 > 0) {
      this._push(writeBytesBuffer, len2, value);
    }
    return this;
  };
  Uint8ArrayWriter.prototype.string = function(value) {
    const len2 = globalThis.Buffer.byteLength(value);
    this.uint32(len2);
    if (len2 > 0) {
      this._push(writeStringBuffer, len2, value);
    }
    return this;
  };
}
function writeBytesBuffer(val, buf2, pos) {
  buf2.set(val, pos);
}
function writeStringBuffer(val, buf2, pos) {
  if (val.length < 40) {
    write(val, buf2, pos);
  } else if (buf2.utf8Write != null) {
    buf2.utf8Write(val, pos);
  } else {
    buf2.set(fromString$1(val), pos);
  }
}
function createWriter() {
  return new Uint8ArrayWriter();
}
function encodeMessage(message2, codec) {
  const w2 = createWriter();
  codec.encode(message2, w2, {
    lengthDelimited: false
  });
  return w2.finish();
}
var CODEC_TYPES;
(function(CODEC_TYPES2) {
  CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
  CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
  CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec(name2, type, encode2, decode2) {
  return {
    name: name2,
    type,
    encode: encode2,
    decode: decode2
  };
}
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode2 = function enumEncode(val, writer) {
    const enumValue = findValue(val);
    writer.int32(enumValue);
  };
  const decode2 = function enumDecode(reader) {
    const val = reader.int32();
    return findValue(val);
  };
  return createCodec("enum", CODEC_TYPES.VARINT, encode2, decode2);
}
function message(encode2, decode2) {
  return createCodec("message", CODEC_TYPES.LENGTH_DELIMITED, encode2, decode2);
}
var Data;
(function(Data2) {
  (function(DataType2) {
    DataType2["Raw"] = "Raw";
    DataType2["Directory"] = "Directory";
    DataType2["File"] = "File";
    DataType2["Metadata"] = "Metadata";
    DataType2["Symlink"] = "Symlink";
    DataType2["HAMTShard"] = "HAMTShard";
  })(Data2.DataType || (Data2.DataType = {}));
  let __DataTypeValues;
  (function(__DataTypeValues2) {
    __DataTypeValues2[__DataTypeValues2["Raw"] = 0] = "Raw";
    __DataTypeValues2[__DataTypeValues2["Directory"] = 1] = "Directory";
    __DataTypeValues2[__DataTypeValues2["File"] = 2] = "File";
    __DataTypeValues2[__DataTypeValues2["Metadata"] = 3] = "Metadata";
    __DataTypeValues2[__DataTypeValues2["Symlink"] = 4] = "Symlink";
    __DataTypeValues2[__DataTypeValues2["HAMTShard"] = 5] = "HAMTShard";
  })(__DataTypeValues || (__DataTypeValues = {}));
  (function(DataType2) {
    DataType2.codec = () => {
      return enumeration(__DataTypeValues);
    };
  })(Data2.DataType || (Data2.DataType = {}));
  let _codec;
  Data2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          Data2.DataType.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (obj.filesize != null) {
          w2.uint32(24);
          w2.uint64(obj.filesize);
        }
        if (obj.blocksizes != null) {
          for (const value of obj.blocksizes) {
            w2.uint32(32);
            w2.uint64(value);
          }
        }
        if (obj.hashType != null) {
          w2.uint32(40);
          w2.uint64(obj.hashType);
        }
        if (obj.fanout != null) {
          w2.uint32(48);
          w2.uint64(obj.fanout);
        }
        if (obj.mode != null) {
          w2.uint32(56);
          w2.uint32(obj.mode);
        }
        if (obj.mtime != null) {
          w2.uint32(66);
          UnixTime.codec().encode(obj.mtime, w2);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length2) => {
        const obj = {
          blocksizes: []
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = Data2.DataType.codec().decode(reader);
              break;
            case 2:
              obj.Data = reader.bytes();
              break;
            case 3:
              obj.filesize = reader.uint64();
              break;
            case 4:
              obj.blocksizes.push(reader.uint64());
              break;
            case 5:
              obj.hashType = reader.uint64();
              break;
            case 6:
              obj.fanout = reader.uint64();
              break;
            case 7:
              obj.mode = reader.uint32();
              break;
            case 8:
              obj.mtime = UnixTime.codec().decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Data2.encode = (obj) => {
    return encodeMessage(obj, Data2.codec());
  };
  Data2.decode = (buf2) => {
    return decodeMessage(buf2, Data2.codec());
  };
})(Data || (Data = {}));
var UnixTime;
(function(UnixTime2) {
  let _codec;
  UnixTime2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Seconds != null) {
          w2.uint32(8);
          w2.int64(obj.Seconds);
        }
        if (obj.FractionalNanoseconds != null) {
          w2.uint32(21);
          w2.fixed32(obj.FractionalNanoseconds);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length2) => {
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Seconds = reader.int64();
              break;
            case 2:
              obj.FractionalNanoseconds = reader.fixed32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  UnixTime2.encode = (obj) => {
    return encodeMessage(obj, UnixTime2.codec());
  };
  UnixTime2.decode = (buf2) => {
    return decodeMessage(buf2, UnixTime2.codec());
  };
})(UnixTime || (UnixTime = {}));
var Metadata;
(function(Metadata2) {
  let _codec;
  Metadata2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.MimeType != null) {
          w2.uint32(10);
          w2.string(obj.MimeType);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length2) => {
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.MimeType = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Metadata2.encode = (obj) => {
    return encodeMessage(obj, Metadata2.codec());
  };
  Metadata2.decode = (buf2) => {
    return decodeMessage(buf2, Metadata2.codec());
  };
})(Metadata || (Metadata = {}));
const types = {
  Raw: "raw",
  Directory: "directory",
  File: "file",
  Metadata: "metadata",
  Symlink: "symlink",
  HAMTShard: "hamt-sharded-directory"
};
const dirTypes = [
  "directory",
  "hamt-sharded-directory"
];
const DEFAULT_FILE_MODE = parseInt("0644", 8);
const DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
let UnixFS$1 = class UnixFS {
  constructor(options2 = {
    type: "file"
  }) {
    __publicField(this, "type");
    __publicField(this, "data");
    __publicField(this, "blockSizes");
    __publicField(this, "hashType");
    __publicField(this, "fanout");
    __publicField(this, "mtime");
    __publicField(this, "_mode");
    __publicField(this, "_originalMode");
    const { type, data, blockSizes, hashType, fanout, mtime, mode } = options2;
    if (type != null && !Object.values(types).includes(type)) {
      throw errCode$1(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
    }
    this.type = type ?? "file";
    this.data = data;
    this.hashType = hashType;
    this.fanout = fanout;
    this.blockSizes = blockSizes ?? [];
    this._originalMode = 0;
    this.mode = mode;
    this.mtime = mtime;
  }
  /**
   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md
   */
  static unmarshal(marshaled) {
    const message2 = Data.decode(marshaled);
    const data = new UnixFS({
      type: types[message2.Type != null ? message2.Type.toString() : "File"],
      data: message2.Data,
      blockSizes: message2.blocksizes,
      mode: message2.mode,
      mtime: message2.mtime != null ? {
        secs: message2.mtime.Seconds ?? 0n,
        nsecs: message2.mtime.FractionalNanoseconds
      } : void 0,
      fanout: message2.fanout
    });
    data._originalMode = message2.mode ?? 0;
    return data;
  }
  set mode(mode) {
    if (mode == null) {
      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
    } else {
      this._mode = mode & 4095;
    }
  }
  get mode() {
    return this._mode;
  }
  isDirectory() {
    return dirTypes.includes(this.type);
  }
  addBlockSize(size) {
    this.blockSizes.push(size);
  }
  removeBlockSize(index2) {
    this.blockSizes.splice(index2, 1);
  }
  /**
   * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else
   */
  fileSize() {
    if (this.isDirectory()) {
      return 0n;
    }
    let sum = 0n;
    this.blockSizes.forEach((size) => {
      sum += size;
    });
    if (this.data != null) {
      sum += BigInt(this.data.length);
    }
    return sum;
  }
  /**
   * encode to protobuf Uint8Array
   */
  marshal() {
    let type;
    switch (this.type) {
      case "raw":
        type = Data.DataType.Raw;
        break;
      case "directory":
        type = Data.DataType.Directory;
        break;
      case "file":
        type = Data.DataType.File;
        break;
      case "metadata":
        type = Data.DataType.Metadata;
        break;
      case "symlink":
        type = Data.DataType.Symlink;
        break;
      case "hamt-sharded-directory":
        type = Data.DataType.HAMTShard;
        break;
      default:
        throw errCode$1(new Error(`Type: ${type} is not valid`), "ERR_INVALID_TYPE");
    }
    let data = this.data;
    if (this.data == null || this.data.length === 0) {
      data = void 0;
    }
    let mode;
    if (this.mode != null) {
      mode = this._originalMode & 4294963200 | (this.mode ?? 0);
      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
        mode = void 0;
      }
      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
        mode = void 0;
      }
    }
    let mtime;
    if (this.mtime != null) {
      mtime = {
        Seconds: this.mtime.secs,
        FractionalNanoseconds: this.mtime.nsecs
      };
    }
    return Data.encode({
      Type: type,
      Data: data,
      filesize: this.isDirectory() ? void 0 : this.fileSize(),
      blocksizes: this.blockSizes,
      hashType: this.hashType,
      fanout: this.fanout,
      mode,
      mtime
    });
  }
};
class CustomProgressEvent extends Event {
  constructor(type, detail) {
    super(type);
    __publicField(this, "type");
    __publicField(this, "detail");
    this.type = type;
    this.detail = detail;
  }
}
const persist$1 = async (buffer2, blockstore, options2) => {
  if (options2.codec == null) {
    options2.codec = dagPB;
  }
  const multihash = await sha256$1.digest(buffer2);
  const cid = CID.create(options2.cidVersion, options2.codec.code, multihash);
  await blockstore.put(cid, buffer2, options2);
  return cid;
};
function defaultBufferImporter(options2) {
  return async function* bufferImporter(file, blockstore) {
    let bytesWritten = 0n;
    for await (let block of file.content) {
      yield async () => {
        var _a3;
        let unixfs2;
        const opts = {
          codec: dagPB,
          cidVersion: options2.cidVersion,
          onProgress: options2.onProgress
        };
        if (options2.rawLeaves) {
          opts.codec = raw;
          opts.cidVersion = 1;
        } else {
          unixfs2 = new UnixFS$1({
            type: options2.leafType,
            data: block
          });
          block = encode$7({
            Data: unixfs2.marshal(),
            Links: []
          });
        }
        const cid = await persist$1(block, blockstore, opts);
        bytesWritten += BigInt(block.byteLength);
        (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("unixfs:importer:progress:file:write", {
          bytesWritten,
          cid,
          path: file.path
        }));
        return {
          cid,
          unixfs: unixfs2,
          size: BigInt(block.length),
          block
        };
      };
    }
  };
}
const dirBuilder = async (dir, blockstore, options2) => {
  const unixfs2 = new UnixFS$1({
    type: "directory",
    mtime: dir.mtime,
    mode: dir.mode
  });
  const block = encode$7(prepare({ Data: unixfs2.marshal() }));
  const cid = await persist$1(block, blockstore, options2);
  const path = dir.path;
  return {
    cid,
    path,
    unixfs: unixfs2,
    size: BigInt(block.length),
    originalPath: dir.originalPath,
    block
  };
};
async function* buildFileBatch(file, blockstore, options2) {
  let count2 = -1;
  let previous;
  for await (const entry of parallelBatch(options2.bufferImporter(file, blockstore), options2.blockWriteConcurrency)) {
    count2++;
    if (count2 === 0) {
      previous = {
        ...entry,
        single: true
      };
      continue;
    } else if (count2 === 1 && previous != null) {
      yield {
        ...previous,
        block: void 0,
        single: void 0
      };
      previous = void 0;
    }
    yield {
      ...entry,
      block: void 0
    };
  }
  if (previous != null) {
    yield previous;
  }
}
function isSingleBlockImport(result) {
  return result.single === true;
}
const reduce = (file, blockstore, options2) => {
  const reducer2 = async function(leaves) {
    var _a3, _b2;
    if (leaves.length === 1 && isSingleBlockImport(leaves[0]) && options2.reduceSingleLeafToSelf) {
      const leaf = leaves[0];
      let node2 = leaf.block;
      if (isSingleBlockImport(leaf) && (file.mtime !== void 0 || file.mode !== void 0)) {
        leaf.unixfs = new UnixFS$1({
          type: "file",
          mtime: file.mtime,
          mode: file.mode,
          data: leaf.block
        });
        node2 = { Data: leaf.unixfs.marshal(), Links: [] };
        leaf.block = encode$7(prepare(node2));
        leaf.cid = await persist$1(leaf.block, blockstore, {
          ...options2,
          cidVersion: options2.cidVersion
        });
        leaf.size = BigInt(leaf.block.length);
      }
      (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("unixfs:importer:progress:file:layout", {
        cid: leaf.cid,
        path: leaf.originalPath
      }));
      return {
        cid: leaf.cid,
        path: file.path,
        unixfs: leaf.unixfs,
        size: leaf.size,
        originalPath: leaf.originalPath
      };
    }
    const f2 = new UnixFS$1({
      type: "file",
      mtime: file.mtime,
      mode: file.mode
    });
    const links2 = leaves.filter((leaf) => {
      var _a4, _b3;
      if (leaf.cid.code === code$3 && leaf.size > 0) {
        return true;
      }
      if (leaf.unixfs != null && leaf.unixfs.data == null && leaf.unixfs.fileSize() > 0n) {
        return true;
      }
      return Boolean((_b3 = (_a4 = leaf.unixfs) == null ? void 0 : _a4.data) == null ? void 0 : _b3.length);
    }).map((leaf) => {
      var _a4;
      if (leaf.cid.code === code$3) {
        f2.addBlockSize(leaf.size);
        return {
          Name: "",
          Tsize: Number(leaf.size),
          Hash: leaf.cid
        };
      }
      if (leaf.unixfs == null || leaf.unixfs.data == null) {
        f2.addBlockSize(((_a4 = leaf.unixfs) == null ? void 0 : _a4.fileSize()) ?? 0n);
      } else {
        f2.addBlockSize(BigInt(leaf.unixfs.data.length));
      }
      return {
        Name: "",
        Tsize: Number(leaf.size),
        Hash: leaf.cid
      };
    });
    const node = {
      Data: f2.marshal(),
      Links: links2
    };
    const block = encode$7(prepare(node));
    const cid = await persist$1(block, blockstore, options2);
    (_b2 = options2.onProgress) == null ? void 0 : _b2.call(options2, new CustomProgressEvent("unixfs:importer:progress:file:layout", {
      cid,
      path: file.originalPath
    }));
    return {
      cid,
      path: file.path,
      unixfs: f2,
      size: BigInt(block.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0)),
      originalPath: file.originalPath,
      block
    };
  };
  return reducer2;
};
const fileBuilder = async (file, block, options2) => {
  return options2.layout(buildFileBatch(file, block, options2), reduce(file, block, options2));
};
function isIterable$1(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable$a(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return async function* () {
        yield content;
      }();
    } else if (isIterable$1(content)) {
      return async function* () {
        yield* content;
      }();
    } else if (isAsyncIterable$a(content)) {
      return content;
    }
  } catch {
    throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
function defaultDagBuilder(options2) {
  return async function* dagBuilder(source, blockstore) {
    for await (const entry of source) {
      let originalPath;
      if (entry.path != null) {
        originalPath = entry.path;
        entry.path = entry.path.split("/").filter((path) => path != null && path !== ".").join("/");
      }
      if (isFileCandidate(entry)) {
        const file = {
          path: entry.path,
          mtime: entry.mtime,
          mode: entry.mode,
          content: async function* () {
            var _a3;
            let bytesRead = 0n;
            for await (const chunk of options2.chunker(options2.chunkValidator(contentAsAsyncIterable(entry.content)))) {
              const currentChunkSize = BigInt(chunk.byteLength);
              bytesRead += currentChunkSize;
              (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("unixfs:importer:progress:file:read", {
                bytesRead,
                chunkSize: currentChunkSize,
                path: entry.path
              }));
              yield chunk;
            }
          }(),
          originalPath
        };
        yield async () => fileBuilder(file, blockstore, options2);
      } else if (entry.path != null) {
        const dir = {
          path: entry.path,
          mtime: entry.mtime,
          mode: entry.mode,
          originalPath
        };
        yield async () => dirBuilder(dir, blockstore, options2);
      } else {
        throw new Error("Import candidate must have content or path or both");
      }
    }
  };
}
function isFileCandidate(entry) {
  return entry.content != null;
}
const defaultChunkValidator = () => {
  return async function* validateChunks(source) {
    for await (const content of source) {
      if (content.length === void 0) {
        throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
      }
      if (typeof content === "string" || content instanceof String) {
        yield fromString$1(content.toString());
      } else if (Array.isArray(content)) {
        yield Uint8Array.from(content);
      } else if (content instanceof Uint8Array) {
        yield content;
      } else {
        throw errCode$1(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
      }
    }
  };
};
const DEFAULT_MAX_CHILDREN_PER_NODE = 174;
function balanced(options2) {
  const maxChildrenPerNode = (options2 == null ? void 0 : options2.maxChildrenPerNode) ?? DEFAULT_MAX_CHILDREN_PER_NODE;
  return async function balancedLayout(source, reduce2) {
    const roots = [];
    for await (const chunked of batch(source, maxChildrenPerNode)) {
      roots.push(await reduce2(chunked));
    }
    if (roots.length > 1) {
      return balancedLayout(roots, reduce2);
    }
    return roots[0];
  };
}
function isAsyncIterable$9(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function all(source) {
  if (isAsyncIterable$9(source)) {
    return (async () => {
      const arr2 = [];
      for await (const entry of source) {
        arr2.push(entry);
      }
      return arr2;
    })();
  }
  const arr = [];
  for (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
let Dir$1 = class Dir {
  constructor(props, options2) {
    __publicField(this, "options");
    __publicField(this, "root");
    __publicField(this, "dir");
    __publicField(this, "path");
    __publicField(this, "dirty");
    __publicField(this, "flat");
    __publicField(this, "parent");
    __publicField(this, "parentKey");
    __publicField(this, "unixfs");
    __publicField(this, "mode");
    __publicField(this, "mtime");
    __publicField(this, "cid");
    __publicField(this, "size");
    __publicField(this, "nodeSize");
    this.options = options2 ?? {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
  }
};
const CID_V0$1 = CID.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn");
const CID_V1$1 = CID.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi");
class DirFlat extends Dir$1 {
  constructor(props, options2) {
    super(props, options2);
    __publicField(this, "_children");
    this._children = /* @__PURE__ */ new Map();
  }
  async put(name2, value) {
    this.cid = void 0;
    this.size = void 0;
    this.nodeSize = void 0;
    this._children.set(name2, value);
  }
  async get(name2) {
    return Promise.resolve(this._children.get(name2));
  }
  childCount() {
    return this._children.size;
  }
  directChildrenCount() {
    return this.childCount();
  }
  onlyChild() {
    return this._children.values().next().value;
  }
  async *eachChildSeries() {
    for (const [key, child] of this._children.entries()) {
      yield {
        key,
        child
      };
    }
  }
  estimateNodeSize() {
    if (this.nodeSize !== void 0) {
      return this.nodeSize;
    }
    this.nodeSize = 0;
    for (const [name2, child] of this._children.entries()) {
      if (child.size != null && child.cid != null) {
        this.nodeSize += name2.length + (this.options.cidVersion === 1 ? CID_V1$1.bytes.byteLength : CID_V0$1.bytes.byteLength);
      }
    }
    return this.nodeSize;
  }
  async *flush(block) {
    const links2 = [];
    for (const [name2, child] of this._children.entries()) {
      let result = child;
      if (child instanceof Dir$1) {
        for await (const entry of child.flush(block)) {
          result = entry;
          yield entry;
        }
      }
      if (result.size != null && result.cid != null) {
        links2.push({
          Name: name2,
          Tsize: Number(result.size),
          Hash: result.cid
        });
      }
    }
    const unixfs2 = new UnixFS$1({
      type: "directory",
      mtime: this.mtime,
      mode: this.mode
    });
    const node = { Data: unixfs2.marshal(), Links: links2 };
    const buffer2 = encode$7(prepare(node));
    const cid = await persist$1(buffer2, block, this.options);
    const size = buffer2.length + node.Links.reduce(
      /**
       * @param {number} acc
       * @param {PBLink} curr
       */
      (acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize),
      0
    );
    this.cid = cid;
    this.size = size;
    yield {
      cid,
      unixfs: unixfs2,
      path: this.path,
      size: BigInt(size)
    };
  }
}
var murmurHash3js = { exports: {} };
(function(module2, exports) {
  (function(root2, undefined$1) {
    var library = {
      "version": "3.0.0",
      "x86": {},
      "x64": {},
      "inputValidation": true
    };
    function _validBytes(bytes2) {
      if (!Array.isArray(bytes2) && !ArrayBuffer.isView(bytes2)) {
        return false;
      }
      for (var i = 0; i < bytes2.length; i++) {
        if (!Number.isInteger(bytes2[i]) || bytes2[i] < 0 || bytes2[i] > 255) {
          return false;
        }
      }
      return true;
    }
    function _x86Multiply(m2, n) {
      return (m2 & 65535) * n + (((m2 >>> 16) * n & 65535) << 16);
    }
    function _x86Rotl(m2, n) {
      return m2 << n | m2 >>> 32 - n;
    }
    function _x86Fmix(h2) {
      h2 ^= h2 >>> 16;
      h2 = _x86Multiply(h2, 2246822507);
      h2 ^= h2 >>> 13;
      h2 = _x86Multiply(h2, 3266489909);
      h2 ^= h2 >>> 16;
      return h2;
    }
    function _x64Add(m2, n) {
      m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m2[3] + n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m2[2] + n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m2[1] + n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m2[0] + n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Multiply(m2, n) {
      m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m2[3] * n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m2[2] * n[3];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[2] += m2[3] * n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m2[1] * n[3];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m2[2] * n[2];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m2[3] * n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m2[0] * n[3] + m2[1] * n[2] + m2[2] * n[1] + m2[3] * n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Rotl(m2, n) {
      n %= 64;
      if (n === 32) {
        return [m2[1], m2[0]];
      } else if (n < 32) {
        return [m2[0] << n | m2[1] >>> 32 - n, m2[1] << n | m2[0] >>> 32 - n];
      } else {
        n -= 32;
        return [m2[1] << n | m2[0] >>> 32 - n, m2[0] << n | m2[1] >>> 32 - n];
      }
    }
    function _x64LeftShift(m2, n) {
      n %= 64;
      if (n === 0) {
        return m2;
      } else if (n < 32) {
        return [m2[0] << n | m2[1] >>> 32 - n, m2[1] << n];
      } else {
        return [m2[1] << n - 32, 0];
      }
    }
    function _x64Xor(m2, n) {
      return [m2[0] ^ n[0], m2[1] ^ n[1]];
    }
    function _x64Fmix(h2) {
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      h2 = _x64Multiply(h2, [4283543511, 3981806797]);
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      h2 = _x64Multiply(h2, [3301882366, 444984403]);
      h2 = _x64Xor(h2, [0, h2[0] >>> 1]);
      return h2;
    }
    library.x86.hash32 = function(bytes2, seed) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$1;
      }
      seed = seed || 0;
      var remainder = bytes2.length % 4;
      var blocks = bytes2.length - remainder;
      var h1 = seed;
      var k1 = 0;
      var c1 = 3432918353;
      var c2 = 461845907;
      for (var i = 0; i < blocks; i = i + 4) {
        k1 = bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 13);
        h1 = _x86Multiply(h1, 5) + 3864292196;
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= bytes2[i + 2] << 16;
        case 2:
          k1 ^= bytes2[i + 1] << 8;
        case 1:
          k1 ^= bytes2[i];
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes2.length;
      h1 = _x86Fmix(h1);
      return h1 >>> 0;
    };
    library.x86.hash128 = function(bytes2, seed) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$1;
      }
      seed = seed || 0;
      var remainder = bytes2.length % 16;
      var blocks = bytes2.length - remainder;
      var h1 = seed;
      var h2 = seed;
      var h3 = seed;
      var h4 = seed;
      var k1 = 0;
      var k2 = 0;
      var k3 = 0;
      var k4 = 0;
      var c1 = 597399067;
      var c2 = 2869860233;
      var c3 = 951274213;
      var c4 = 2716044179;
      for (var i = 0; i < blocks; i = i + 16) {
        k1 = bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24;
        k2 = bytes2[i + 4] | bytes2[i + 5] << 8 | bytes2[i + 6] << 16 | bytes2[i + 7] << 24;
        k3 = bytes2[i + 8] | bytes2[i + 9] << 8 | bytes2[i + 10] << 16 | bytes2[i + 11] << 24;
        k4 = bytes2[i + 12] | bytes2[i + 13] << 8 | bytes2[i + 14] << 16 | bytes2[i + 15] << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 19);
        h1 += h2;
        h1 = _x86Multiply(h1, 5) + 1444728091;
        k2 = _x86Multiply(k2, c2);
        k2 = _x86Rotl(k2, 16);
        k2 = _x86Multiply(k2, c3);
        h2 ^= k2;
        h2 = _x86Rotl(h2, 17);
        h2 += h3;
        h2 = _x86Multiply(h2, 5) + 197830471;
        k3 = _x86Multiply(k3, c3);
        k3 = _x86Rotl(k3, 17);
        k3 = _x86Multiply(k3, c4);
        h3 ^= k3;
        h3 = _x86Rotl(h3, 15);
        h3 += h4;
        h3 = _x86Multiply(h3, 5) + 2530024501;
        k4 = _x86Multiply(k4, c4);
        k4 = _x86Rotl(k4, 18);
        k4 = _x86Multiply(k4, c1);
        h4 ^= k4;
        h4 = _x86Rotl(h4, 13);
        h4 += h1;
        h4 = _x86Multiply(h4, 5) + 850148119;
      }
      k1 = 0;
      k2 = 0;
      k3 = 0;
      k4 = 0;
      switch (remainder) {
        case 15:
          k4 ^= bytes2[i + 14] << 16;
        case 14:
          k4 ^= bytes2[i + 13] << 8;
        case 13:
          k4 ^= bytes2[i + 12];
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
        case 12:
          k3 ^= bytes2[i + 11] << 24;
        case 11:
          k3 ^= bytes2[i + 10] << 16;
        case 10:
          k3 ^= bytes2[i + 9] << 8;
        case 9:
          k3 ^= bytes2[i + 8];
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
        case 8:
          k2 ^= bytes2[i + 7] << 24;
        case 7:
          k2 ^= bytes2[i + 6] << 16;
        case 6:
          k2 ^= bytes2[i + 5] << 8;
        case 5:
          k2 ^= bytes2[i + 4];
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
        case 4:
          k1 ^= bytes2[i + 3] << 24;
        case 3:
          k1 ^= bytes2[i + 2] << 16;
        case 2:
          k1 ^= bytes2[i + 1] << 8;
        case 1:
          k1 ^= bytes2[i];
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes2.length;
      h2 ^= bytes2.length;
      h3 ^= bytes2.length;
      h4 ^= bytes2.length;
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      h1 = _x86Fmix(h1);
      h2 = _x86Fmix(h2);
      h3 = _x86Fmix(h3);
      h4 = _x86Fmix(h4);
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(bytes2, seed) {
      if (library.inputValidation && !_validBytes(bytes2)) {
        return undefined$1;
      }
      seed = seed || 0;
      var remainder = bytes2.length % 16;
      var blocks = bytes2.length - remainder;
      var h1 = [0, seed];
      var h2 = [0, seed];
      var k1 = [0, 0];
      var k2 = [0, 0];
      var c1 = [2277735313, 289559509];
      var c2 = [1291169091, 658871167];
      for (var i = 0; i < blocks; i = i + 16) {
        k1 = [bytes2[i + 4] | bytes2[i + 5] << 8 | bytes2[i + 6] << 16 | bytes2[i + 7] << 24, bytes2[i] | bytes2[i + 1] << 8 | bytes2[i + 2] << 16 | bytes2[i + 3] << 24];
        k2 = [bytes2[i + 12] | bytes2[i + 13] << 8 | bytes2[i + 14] << 16 | bytes2[i + 15] << 24, bytes2[i + 8] | bytes2[i + 9] << 8 | bytes2[i + 10] << 16 | bytes2[i + 11] << 24];
        k1 = _x64Multiply(k1, c1);
        k1 = _x64Rotl(k1, 31);
        k1 = _x64Multiply(k1, c2);
        h1 = _x64Xor(h1, k1);
        h1 = _x64Rotl(h1, 27);
        h1 = _x64Add(h1, h2);
        h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
        k2 = _x64Multiply(k2, c2);
        k2 = _x64Rotl(k2, 33);
        k2 = _x64Multiply(k2, c1);
        h2 = _x64Xor(h2, k2);
        h2 = _x64Rotl(h2, 31);
        h2 = _x64Add(h2, h1);
        h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
      }
      k1 = [0, 0];
      k2 = [0, 0];
      switch (remainder) {
        case 15:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 14]], 48));
        case 14:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 13]], 40));
        case 13:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 12]], 32));
        case 12:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 11]], 24));
        case 11:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 10]], 16));
        case 10:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes2[i + 9]], 8));
        case 9:
          k2 = _x64Xor(k2, [0, bytes2[i + 8]]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
        case 8:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 7]], 56));
        case 7:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 6]], 48));
        case 6:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 5]], 40));
        case 5:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 4]], 32));
        case 4:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 3]], 24));
        case 3:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 2]], 16));
        case 2:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes2[i + 1]], 8));
        case 1:
          k1 = _x64Xor(k1, [0, bytes2[i]]);
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
      }
      h1 = _x64Xor(h1, [0, bytes2.length]);
      h2 = _x64Xor(h2, [0, bytes2.length]);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      h1 = _x64Fmix(h1);
      h2 = _x64Fmix(h2);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };
    {
      if (module2.exports) {
        exports = module2.exports = library;
      }
      exports.murmurHash3 = library;
    }
  })();
})(murmurHash3js, murmurHash3js.exports);
var murmurHash3jsExports = murmurHash3js.exports;
var murmurhash3jsRevisited = murmurHash3jsExports;
const mur = /* @__PURE__ */ getDefaultExportFromCjs(murmurhash3jsRevisited);
const murmur3128 = from({
  name: "murmur3-128",
  code: 34,
  encode: (input) => fromHex(mur.x64.hash128(input))
});
const BITS_PER_BYTE = 7;
var sparseArray = class SparseArray {
  constructor() {
    this._bitArrays = [];
    this._data = [];
    this._length = 0;
    this._changedLength = false;
    this._changedData = false;
  }
  set(index2, value) {
    let pos = this._internalPositionFor(index2, false);
    if (value === void 0) {
      if (pos !== -1) {
        this._unsetInternalPos(pos);
        this._unsetBit(index2);
        this._changedLength = true;
        this._changedData = true;
      }
    } else {
      let needsSort = false;
      if (pos === -1) {
        pos = this._data.length;
        this._setBit(index2);
        this._changedData = true;
      } else {
        needsSort = true;
      }
      this._setInternalPos(pos, index2, value, needsSort);
      this._changedLength = true;
    }
  }
  unset(index2) {
    this.set(index2, void 0);
  }
  get(index2) {
    this._sortData();
    const pos = this._internalPositionFor(index2, true);
    if (pos === -1) {
      return void 0;
    }
    return this._data[pos][1];
  }
  push(value) {
    this.set(this.length, value);
    return this.length;
  }
  get length() {
    this._sortData();
    if (this._changedLength) {
      const last2 = this._data[this._data.length - 1];
      this._length = last2 ? last2[0] + 1 : 0;
      this._changedLength = false;
    }
    return this._length;
  }
  forEach(iterator) {
    let i = 0;
    while (i < this.length) {
      iterator(this.get(i), i, this);
      i++;
    }
  }
  map(iterator) {
    let i = 0;
    let mapped = new Array(this.length);
    while (i < this.length) {
      mapped[i] = iterator(this.get(i), i, this);
      i++;
    }
    return mapped;
  }
  reduce(reducer2, initialValue) {
    let i = 0;
    let acc = initialValue;
    while (i < this.length) {
      const value = this.get(i);
      acc = reducer2(acc, value, i);
      i++;
    }
    return acc;
  }
  find(finder) {
    let i = 0, found, last2;
    while (i < this.length && !found) {
      last2 = this.get(i);
      found = finder(last2);
      i++;
    }
    return found ? last2 : void 0;
  }
  _internalPositionFor(index2, noCreate) {
    const bytePos = this._bytePosFor(index2, noCreate);
    if (bytePos >= this._bitArrays.length) {
      return -1;
    }
    const byte = this._bitArrays[bytePos];
    const bitPos = index2 - bytePos * BITS_PER_BYTE;
    const exists2 = (byte & 1 << bitPos) > 0;
    if (!exists2) {
      return -1;
    }
    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
    const mask = ~(4294967295 << bitPos + 1);
    const bytePopCount = popCount(byte & mask);
    const arrayPos = previousPopCount + bytePopCount - 1;
    return arrayPos;
  }
  _bytePosFor(index2, noCreate) {
    const bytePos = Math.floor(index2 / BITS_PER_BYTE);
    const targetLength = bytePos + 1;
    while (!noCreate && this._bitArrays.length < targetLength) {
      this._bitArrays.push(0);
    }
    return bytePos;
  }
  _setBit(index2) {
    const bytePos = this._bytePosFor(index2, false);
    this._bitArrays[bytePos] |= 1 << index2 - bytePos * BITS_PER_BYTE;
  }
  _unsetBit(index2) {
    const bytePos = this._bytePosFor(index2, false);
    this._bitArrays[bytePos] &= ~(1 << index2 - bytePos * BITS_PER_BYTE);
  }
  _setInternalPos(pos, index2, value, needsSort) {
    const data = this._data;
    const elem = [index2, value];
    if (needsSort) {
      this._sortData();
      data[pos] = elem;
    } else {
      if (data.length) {
        if (data[data.length - 1][0] >= index2) {
          data.push(elem);
        } else if (data[0][0] <= index2) {
          data.unshift(elem);
        } else {
          const randomIndex = Math.round(data.length / 2);
          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
        }
      } else {
        this._data.push(elem);
      }
      this._changedData = true;
      this._changedLength = true;
    }
  }
  _unsetInternalPos(pos) {
    this._data.splice(pos, 1);
  }
  _sortData() {
    if (this._changedData) {
      this._data.sort(sortInternal);
    }
    this._changedData = false;
  }
  bitField() {
    const bytes2 = [];
    let pendingBitsForResultingByte = 8;
    let pendingBitsForNewByte = 0;
    let resultingByte = 0;
    let newByte;
    const pending = this._bitArrays.slice();
    while (pending.length || pendingBitsForNewByte) {
      if (pendingBitsForNewByte === 0) {
        newByte = pending.shift();
        pendingBitsForNewByte = 7;
      }
      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
      const mask = ~(255 << usingBits);
      const masked = newByte & mask;
      resultingByte |= masked << 8 - pendingBitsForResultingByte;
      newByte = newByte >>> usingBits;
      pendingBitsForNewByte -= usingBits;
      pendingBitsForResultingByte -= usingBits;
      if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
        bytes2.push(resultingByte);
        resultingByte = 0;
        pendingBitsForResultingByte = 8;
      }
    }
    for (var i = bytes2.length - 1; i > 0; i--) {
      const value = bytes2[i];
      if (value === 0) {
        bytes2.pop();
      } else {
        break;
      }
    }
    return bytes2;
  }
  compactArray() {
    this._sortData();
    return this._data.map(valueOnly);
  }
};
function popCountReduce(count2, byte) {
  return count2 + popCount(byte);
}
function popCount(_v) {
  let v = _v;
  v = v - (v >> 1 & 1431655765);
  v = (v & 858993459) + (v >> 2 & 858993459);
  return (v + (v >> 4) & 252645135) * 16843009 >> 24;
}
function sortInternal(a, b) {
  return a[0] - b[0];
}
function valueOnly(elem) {
  return elem[1];
}
const SparseArray2 = /* @__PURE__ */ getDefaultExportFromCjs(sparseArray);
class Bucket {
  constructor(options2, parent, posAtParent = 0) {
    __publicField(this, "_options");
    __publicField(this, "_popCount");
    __publicField(this, "_parent");
    __publicField(this, "_posAtParent");
    __publicField(this, "_children");
    __publicField(this, "key");
    this._options = options2;
    this._popCount = 0;
    this._parent = parent;
    this._posAtParent = posAtParent;
    this._children = new SparseArray2();
    this.key = null;
  }
  async put(key, value) {
    const place = await this._findNewBucketAndPos(key);
    place.bucket._putAt(place, key, value);
  }
  async get(key) {
    const child = await this._findChild(key);
    if (child != null) {
      return child.value;
    }
  }
  async del(key) {
    const place = await this._findPlace(key);
    const child = place.bucket._at(place.pos);
    if (child != null && child.key === key) {
      place.bucket._delAt(place.pos);
    }
  }
  leafCount() {
    const children = this._children.compactArray();
    return children.reduce((acc, child) => {
      if (child instanceof Bucket) {
        return acc + child.leafCount();
      }
      return acc + 1;
    }, 0);
  }
  childrenCount() {
    return this._children.length;
  }
  onlyChild() {
    return this._children.get(0);
  }
  *eachLeafSeries() {
    const children = this._children.compactArray();
    for (const child of children) {
      if (child instanceof Bucket) {
        yield* child.eachLeafSeries();
      } else {
        yield child;
      }
    }
  }
  serialize(map2, reduce2) {
    const acc = [];
    return reduce2(this._children.reduce((acc2, child, index2) => {
      if (child != null) {
        if (child instanceof Bucket) {
          acc2.push(child.serialize(map2, reduce2));
        } else {
          acc2.push(map2(child, index2));
        }
      }
      return acc2;
    }, acc));
  }
  async asyncTransform(asyncMap, asyncReduce) {
    return asyncTransformBucket(this, asyncMap, asyncReduce);
  }
  toJSON() {
    return this.serialize(mapNode, reduceNodes);
  }
  prettyPrint() {
    return JSON.stringify(this.toJSON(), null, "  ");
  }
  tableSize() {
    return Math.pow(2, this._options.bits);
  }
  async _findChild(key) {
    const result = await this._findPlace(key);
    const child = result.bucket._at(result.pos);
    if (child instanceof Bucket) {
      return void 0;
    }
    if (child != null && child.key === key) {
      return child;
    }
  }
  async _findPlace(key) {
    const hashValue = this._options.hash(typeof key === "string" ? fromString$1(key) : key);
    const index2 = await hashValue.take(this._options.bits);
    const child = this._children.get(index2);
    if (child instanceof Bucket) {
      return child._findPlace(hashValue);
    }
    return {
      bucket: this,
      pos: index2,
      hash: hashValue,
      existingChild: child
    };
  }
  async _findNewBucketAndPos(key) {
    const place = await this._findPlace(key);
    if (place.existingChild != null && place.existingChild.key !== key) {
      const bucket = new Bucket(this._options, place.bucket, place.pos);
      place.bucket._putObjectAt(place.pos, bucket);
      const newPlace = await bucket._findPlace(place.existingChild.hash);
      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
      return bucket._findNewBucketAndPos(place.hash);
    }
    return place;
  }
  _putAt(place, key, value) {
    this._putObjectAt(place.pos, {
      key,
      value,
      hash: place.hash
    });
  }
  _putObjectAt(pos, object) {
    if (this._children.get(pos) == null) {
      this._popCount++;
    }
    this._children.set(pos, object);
  }
  _delAt(pos) {
    if (pos === -1) {
      throw new Error("Invalid position");
    }
    if (this._children.get(pos) != null) {
      this._popCount--;
    }
    this._children.unset(pos);
    this._level();
  }
  _level() {
    if (this._parent != null && this._popCount <= 1) {
      if (this._popCount === 1) {
        const onlyChild = this._children.find(exists$2);
        if (onlyChild != null && !(onlyChild instanceof Bucket)) {
          const hash2 = onlyChild.hash;
          hash2.untake(this._options.bits);
          const place = {
            pos: this._posAtParent,
            hash: hash2,
            bucket: this._parent
          };
          this._parent._putAt(place, onlyChild.key, onlyChild.value);
        }
      } else {
        this._parent._delAt(this._posAtParent);
      }
    }
  }
  _at(index2) {
    return this._children.get(index2);
  }
}
function exists$2(o) {
  return Boolean(o);
}
function mapNode(node, _) {
  return node.key;
}
function reduceNodes(nodes) {
  return nodes;
}
async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
  const output2 = [];
  for (const child of bucket._children.compactArray()) {
    if (child instanceof Bucket) {
      await asyncTransformBucket(child, asyncMap, asyncReduce);
    } else {
      const mappedChildren = await asyncMap(child);
      output2.push({
        bitField: bucket._children.bitField(),
        children: mappedChildren
      });
    }
  }
  return asyncReduce(output2);
}
const START_MASKS$1 = [
  255,
  254,
  252,
  248,
  240,
  224,
  192,
  128
];
const STOP_MASKS$1 = [
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255
];
let ConsumableBuffer$1 = class ConsumableBuffer {
  constructor(value) {
    __publicField(this, "_value");
    __publicField(this, "_currentBytePos");
    __publicField(this, "_currentBitPos");
    this._value = value;
    this._currentBytePos = value.length - 1;
    this._currentBitPos = 7;
  }
  availableBits() {
    return this._currentBitPos + 1 + this._currentBytePos * 8;
  }
  totalBits() {
    return this._value.length * 8;
  }
  take(bits) {
    let pendingBits = bits;
    let result = 0;
    while (pendingBits > 0 && this._haveBits()) {
      const byte = this._value[this._currentBytePos];
      const availableBits = this._currentBitPos + 1;
      const taking = Math.min(availableBits, pendingBits);
      const value = byteBitsToInt$1(byte, availableBits - taking, taking);
      result = (result << taking) + value;
      pendingBits -= taking;
      this._currentBitPos -= taking;
      if (this._currentBitPos < 0) {
        this._currentBitPos = 7;
        this._currentBytePos--;
      }
    }
    return result;
  }
  untake(bits) {
    this._currentBitPos += bits;
    while (this._currentBitPos > 7) {
      this._currentBitPos -= 8;
      this._currentBytePos += 1;
    }
  }
  _haveBits() {
    return this._currentBytePos >= 0;
  }
};
function byteBitsToInt$1(byte, start2, length2) {
  const mask = maskFor$1(start2, length2);
  return (byte & mask) >>> start2;
}
function maskFor$1(start2, length2) {
  return START_MASKS$1[start2] & STOP_MASKS$1[Math.min(length2 + start2 - 1, 7)];
}
function wrapHash$1(hashFn2) {
  function hashing(value) {
    if (value instanceof InfiniteHash$1) {
      return value;
    } else {
      return new InfiniteHash$1(value, hashFn2);
    }
  }
  return hashing;
}
let InfiniteHash$1 = class InfiniteHash {
  constructor(value, hashFn2) {
    __publicField(this, "_value");
    __publicField(this, "_hashFn");
    __publicField(this, "_depth");
    __publicField(this, "_availableBits");
    __publicField(this, "_currentBufferIndex");
    __publicField(this, "_buffers");
    if (!(value instanceof Uint8Array)) {
      throw new Error("can only hash Uint8Arrays");
    }
    this._value = value;
    this._hashFn = hashFn2;
    this._depth = -1;
    this._availableBits = 0;
    this._currentBufferIndex = 0;
    this._buffers = [];
  }
  async take(bits) {
    let pendingBits = bits;
    while (this._availableBits < pendingBits) {
      await this._produceMoreBits();
    }
    let result = 0;
    while (pendingBits > 0) {
      const hash2 = this._buffers[this._currentBufferIndex];
      const available = Math.min(hash2.availableBits(), pendingBits);
      const took = hash2.take(available);
      result = (result << available) + took;
      pendingBits -= available;
      this._availableBits -= available;
      if (hash2.availableBits() === 0) {
        this._currentBufferIndex++;
      }
    }
    return result;
  }
  untake(bits) {
    let pendingBits = bits;
    while (pendingBits > 0) {
      const hash2 = this._buffers[this._currentBufferIndex];
      const availableForUntake = Math.min(hash2.totalBits() - hash2.availableBits(), pendingBits);
      hash2.untake(availableForUntake);
      pendingBits -= availableForUntake;
      this._availableBits += availableForUntake;
      if (this._currentBufferIndex > 0 && hash2.totalBits() === hash2.availableBits()) {
        this._depth--;
        this._currentBufferIndex--;
      }
    }
  }
  async _produceMoreBits() {
    this._depth++;
    const value = this._depth > 0 ? concat$2([this._value, Uint8Array.from([this._depth])]) : this._value;
    const hashValue = await this._hashFn(value);
    const buffer2 = new ConsumableBuffer$1(hashValue);
    this._buffers.push(buffer2);
    this._availableBits += buffer2.availableBits();
  }
};
function createHAMT(options2) {
  if (options2 == null || options2.hashFn == null) {
    throw new Error("please define an options.hashFn");
  }
  const bucketOptions = {
    bits: options2.bits ?? 8,
    hash: wrapHash$1(options2.hashFn)
  };
  return new Bucket(bucketOptions);
}
async function hamtHashFn$1(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}
const HAMT_HASH_CODE = BigInt(34);
const DEFAULT_FANOUT_BITS = 8;
let DirSharded$1 = class DirSharded extends Dir$1 {
  constructor(props, options2) {
    super(props, options2);
    __publicField(this, "_bucket");
    this._bucket = createHAMT({
      hashFn: hamtHashFn$1,
      bits: options2.shardFanoutBits ?? DEFAULT_FANOUT_BITS
    });
  }
  async put(name2, value) {
    this.cid = void 0;
    this.size = void 0;
    this.nodeSize = void 0;
    await this._bucket.put(name2, value);
  }
  async get(name2) {
    return this._bucket.get(name2);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value
      };
    }
  }
  estimateNodeSize() {
    if (this.nodeSize !== void 0) {
      return this.nodeSize;
    }
    this.nodeSize = calculateSize$1(this._bucket, this, this.options);
    return this.nodeSize;
  }
  async *flush(blockstore) {
    for await (const entry of flush$1(this._bucket, blockstore, this, this.options)) {
      yield {
        ...entry,
        path: this.path
      };
    }
  }
};
async function* flush$1(bucket, blockstore, shardRoot, options2) {
  const children = bucket._children;
  const padLength = (bucket.tableSize() - 1).toString(16).length;
  const links2 = [];
  let childrenSize = 0n;
  for (let i = 0; i < children.length; i++) {
    const child = children.get(i);
    if (child == null) {
      continue;
    }
    const labelPrefix = i.toString(16).toUpperCase().padStart(padLength, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of flush$1(child, blockstore, null, options2)) {
        shard = subShard;
      }
      if (shard == null) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links2.push({
        Name: labelPrefix,
        Tsize: Number(shard.size),
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (isDir$1(child.value)) {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      if (flushedDir == null) {
        throw new Error("Did not flush dir");
      }
      const label = labelPrefix + child.key;
      links2.push({
        Name: label,
        Tsize: Number(flushedDir.size),
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value = child.value;
      if (value.cid == null) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value.size;
      links2.push({
        Name: label,
        Tsize: Number(size2),
        Hash: value.cid
      });
      childrenSize += BigInt(size2 ?? 0);
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS$1({
    type: "hamt-sharded-directory",
    data,
    fanout: BigInt(bucket.tableSize()),
    hashType: HAMT_HASH_CODE,
    mtime: shardRoot == null ? void 0 : shardRoot.mtime,
    mode: shardRoot == null ? void 0 : shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links2
  };
  const buffer2 = encode$7(prepare(node));
  const cid = await persist$1(buffer2, blockstore, options2);
  const size = BigInt(buffer2.byteLength) + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size
  };
}
function isDir$1(obj) {
  return typeof obj.flush === "function";
}
function calculateSize$1(bucket, shardRoot, options2) {
  const children = bucket._children;
  const padLength = (bucket.tableSize() - 1).toString(16).length;
  const links2 = [];
  for (let i = 0; i < children.length; i++) {
    const child = children.get(i);
    if (child == null) {
      continue;
    }
    const labelPrefix = i.toString(16).toUpperCase().padStart(padLength, "0");
    if (child instanceof Bucket) {
      const size = calculateSize$1(child, null, options2);
      links2.push({
        Name: labelPrefix,
        Tsize: Number(size),
        Hash: options2.cidVersion === 0 ? CID_V0$1 : CID_V1$1
      });
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      const size = dir2.nodeSize();
      links2.push({
        Name: labelPrefix + child.key,
        Tsize: Number(size),
        Hash: options2.cidVersion === 0 ? CID_V0$1 : CID_V1$1
      });
    } else {
      const value = child.value;
      if (value.cid == null) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size = value.size;
      links2.push({
        Name: label,
        Tsize: Number(size),
        Hash: value.cid
      });
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS$1({
    type: "hamt-sharded-directory",
    data,
    fanout: BigInt(bucket.tableSize()),
    hashType: HAMT_HASH_CODE,
    mtime: shardRoot == null ? void 0 : shardRoot.mtime,
    mode: shardRoot == null ? void 0 : shardRoot.mode
  });
  const buffer2 = encode$7(prepare({
    Data: dir.marshal(),
    Links: links2
  }));
  return buffer2.length;
}
async function flatToShard(child, dir, threshold, options2) {
  let newDir = dir;
  if (dir instanceof DirFlat && dir.estimateNodeSize() > threshold) {
    newDir = await convertToShard(dir, options2);
  }
  const parent = newDir.parent;
  if (parent != null) {
    if (newDir !== dir) {
      if (child != null) {
        child.parent = newDir;
      }
      if (newDir.parentKey == null) {
        throw new Error("No parent key found");
      }
      await parent.put(newDir.parentKey, newDir);
    }
    return flatToShard(newDir, parent, threshold, options2);
  }
  return newDir;
}
async function convertToShard(oldDir, options2) {
  const newDir = new DirSharded$1({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false,
    mtime: oldDir.mtime,
    mode: oldDir.mode
  }, options2);
  for await (const { key, child } of oldDir.eachChildSeries()) {
    await newDir.put(key, child);
  }
  return newDir;
}
const toPathComponents$1 = (path = "") => {
  return path.split(new RegExp("(?<!\\\\)\\/")).filter(Boolean);
};
async function addToTree(elem, tree, options2) {
  var _a3, _b2;
  const pathElems = toPathComponents$1(elem.path ?? "");
  const lastIndex = pathElems.length - 1;
  let parent = tree;
  let currentPath = "";
  for (let i = 0; i < pathElems.length; i++) {
    const pathElem = pathElems[i];
    currentPath += `${currentPath !== "" ? "/" : ""}${pathElem}`;
    const last2 = i === lastIndex;
    parent.dirty = true;
    parent.cid = void 0;
    parent.size = void 0;
    if (last2) {
      await parent.put(pathElem, elem);
      tree = await flatToShard(null, parent, options2.shardSplitThresholdBytes, options2);
    } else {
      let dir = await parent.get(pathElem);
      if (dir == null || !(dir instanceof Dir$1)) {
        dir = new DirFlat({
          root: false,
          dir: true,
          parent,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true,
          mtime: (_a3 = dir == null ? void 0 : dir.unixfs) == null ? void 0 : _a3.mtime,
          mode: (_b2 = dir == null ? void 0 : dir.unixfs) == null ? void 0 : _b2.mode
        }, options2);
      }
      await parent.put(pathElem, dir);
      parent = dir;
    }
  }
  return tree;
}
async function* flushAndYield(tree, blockstore) {
  var _a3;
  if (!(tree instanceof Dir$1)) {
    if (((_a3 = tree.unixfs) == null ? void 0 : _a3.isDirectory()) === true) {
      yield tree;
    }
    return;
  }
  yield* tree.flush(blockstore);
}
function defaultTreeBuilder(options2) {
  return async function* treeBuilder(source, block) {
    let tree = new DirFlat({
      root: true,
      dir: true,
      path: "",
      dirty: true,
      flat: true
    }, options2);
    let rootDir;
    let singleRoot = false;
    for await (const entry of source) {
      if (entry == null) {
        continue;
      }
      const dir = `${entry.originalPath ?? ""}`.split("/")[0];
      if (dir != null && dir !== "") {
        if (rootDir == null) {
          rootDir = dir;
          singleRoot = true;
        } else if (rootDir !== dir) {
          singleRoot = false;
        }
      }
      tree = await addToTree(entry, tree, options2);
      if (entry.unixfs == null || !entry.unixfs.isDirectory()) {
        yield entry;
      }
    }
    if (options2.wrapWithDirectory || singleRoot && tree.childCount() > 1) {
      yield* flushAndYield(tree, block);
    } else {
      for await (const unwrapped of tree.eachChildSeries()) {
        if (unwrapped == null) {
          continue;
        }
        yield* flushAndYield(unwrapped.child, block);
      }
    }
  };
}
async function* importer(source, blockstore, options2 = {}) {
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  const wrapWithDirectory = options2.wrapWithDirectory ?? false;
  const shardSplitThresholdBytes = options2.shardSplitThresholdBytes ?? 262144;
  const shardFanoutBits = options2.shardFanoutBits ?? 8;
  const cidVersion = options2.cidVersion ?? 1;
  const rawLeaves = options2.rawLeaves ?? true;
  const leafType = options2.leafType ?? "file";
  const fileImportConcurrency = options2.fileImportConcurrency ?? 50;
  const blockWriteConcurrency = options2.blockWriteConcurrency ?? 10;
  const reduceSingleLeafToSelf = options2.reduceSingleLeafToSelf ?? true;
  const chunker = options2.chunker ?? fixedSize();
  const chunkValidator = options2.chunkValidator ?? defaultChunkValidator();
  const buildDag = options2.dagBuilder ?? defaultDagBuilder({
    chunker,
    chunkValidator,
    wrapWithDirectory,
    layout: options2.layout ?? balanced(),
    bufferImporter: options2.bufferImporter ?? defaultBufferImporter({
      cidVersion,
      rawLeaves,
      leafType,
      onProgress: options2.onProgress
    }),
    blockWriteConcurrency,
    reduceSingleLeafToSelf,
    cidVersion,
    onProgress: options2.onProgress
  });
  const buildTree = options2.treeBuilder ?? defaultTreeBuilder({
    wrapWithDirectory,
    shardSplitThresholdBytes,
    shardFanoutBits,
    cidVersion,
    onProgress: options2.onProgress
  });
  for await (const entry of buildTree(parallelBatch(buildDag(candidates, blockstore), fileImportConcurrency), blockstore)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}
async function importFile(content, blockstore, options2 = {}) {
  const result = await first(importer([content], blockstore, options2));
  if (result == null) {
    throw errCode$1(new Error("Nothing imported"), "ERR_INVALID_PARAMS");
  }
  return result;
}
async function importDirectory(content, blockstore, options2 = {}) {
  const result = await first(importer([content], blockstore, options2));
  if (result == null) {
    throw errCode$1(new Error("Nothing imported"), "ERR_INVALID_PARAMS");
  }
  return result;
}
async function importBytes(buf2, blockstore, options2 = {}) {
  return importFile({
    content: buf2
  }, blockstore, options2);
}
async function importByteStream(bufs, blockstore, options2 = {}) {
  return importFile({
    content: bufs
  }, blockstore, options2);
}
const defaultImporterSettings = {
  cidVersion: 1,
  rawLeaves: true,
  layout: balanced({
    maxChildrenPerNode: 1024
  }),
  chunker: fixedSize({
    chunkSize: 1048576
  })
};
async function* addAll(source, blockstore, options2 = {}) {
  yield* importer(source, blockstore, {
    ...defaultImporterSettings,
    ...options2
  });
}
async function addBytes(bytes2, blockstore, options2 = {}) {
  const { cid } = await importBytes(bytes2, blockstore, {
    ...defaultImporterSettings,
    ...options2
  });
  return cid;
}
async function addByteStream(bytes2, blockstore, options2 = {}) {
  const { cid } = await importByteStream(bytes2, blockstore, {
    ...defaultImporterSettings,
    ...options2
  });
  return cid;
}
async function addFile(file, blockstore, options2 = {}) {
  const { cid } = await importFile(file, blockstore, {
    ...defaultImporterSettings,
    ...options2
  });
  return cid;
}
async function addDirectory(dir, blockstore, options2 = {}) {
  const { cid } = await importDirectory({
    ...dir,
    path: dir.path ?? "-"
  }, blockstore, {
    ...defaultImporterSettings,
    ...options2
  });
  return cid;
}
function isAsyncIterable$8(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function last(source) {
  if (isAsyncIterable$8(source)) {
    return (async () => {
      let res2;
      for await (const entry of source) {
        res2 = entry;
      }
      return res2;
    })();
  }
  let res;
  for (const entry of source) {
    res = entry;
  }
  return res;
}
const typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
const objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer$1(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer$1(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
class Type {
  /**
   * @param {number} major
   * @param {string} name
   * @param {boolean} terminal
   */
  constructor(major, name2, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name2;
    this.terminal = terminal;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  /**
   * @param {Type} typ
   * @returns {number}
   */
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
}
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
let Token$1 = class Token {
  /**
   * @param {Type} type
   * @param {any} [value]
   * @param {number} [encodedLength]
   */
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  /* c8 ignore next 3 */
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};
const useBuffer = globalThis.process && // @ts-ignore
!globalThis.process.browser && // @ts-ignore
globalThis.Buffer && // @ts-ignore
typeof globalThis.Buffer.isBuffer === "function";
const textDecoder = new TextDecoder();
const textEncoder = new TextEncoder();
function isBuffer(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
const toString$3 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes2, start2, end) => {
    return end - start2 > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(bytes2.subarray(start2, end)).toString("utf8")
    ) : utf8Slice(bytes2, start2, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes2, start2, end) => {
    return end - start2 > 64 ? textDecoder.decode(bytes2.subarray(start2, end)) : utf8Slice(bytes2, start2, end);
  }
);
const fromString = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string2) => {
    return string2.length > 64 ? (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(string2)
    ) : utf8ToBytes$2(string2);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {string} string
   */
  (string2) => {
    return string2.length > 64 ? textEncoder.encode(string2) : utf8ToBytes$2(string2);
  }
);
const fromArray = (arr) => {
  return Uint8Array.from(arr);
};
const slice = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes2, start2, end) => {
    if (isBuffer(bytes2)) {
      return new Uint8Array(bytes2.subarray(start2, end));
    }
    return bytes2.slice(start2, end);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array} bytes
   * @param {number} start
   * @param {number} end
   */
  (bytes2, start2, end) => {
    return bytes2.slice(start2, end);
  }
);
const concat$1 = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length2) => {
    chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
      // eslint-disable-line operator-linebreak
      // @ts-ignore
      globalThis.Buffer.from(c)
    ));
    return asU8A(globalThis.Buffer.concat(chunks, length2));
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {Uint8Array[]} chunks
   * @param {number} length
   * @returns {Uint8Array}
   */
  (chunks, length2) => {
    const out = new Uint8Array(length2);
    let off = 0;
    for (let b of chunks) {
      if (off + b.length > out.length) {
        b = b.subarray(0, out.length - off);
      }
      out.set(b, off);
      off += b.length;
    }
    return out;
  }
);
const alloc = useBuffer ? (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return globalThis.Buffer.allocUnsafe(size);
  }
) : (
  // eslint-disable-line operator-linebreak
  /**
   * @param {number} size
   * @returns {Uint8Array}
   */
  (size) => {
    return new Uint8Array(size);
  }
);
function compare(b1, b2) {
  if (isBuffer(b1) && isBuffer(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes$2(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len2 = codePoints.length;
  if (len2 <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len2) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
const defaultChunkSize = 256;
class Bl {
  /**
   * @param {number} [chunkSize]
   */
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  /**
   * @param {Uint8Array|number[]} bytes
   */
  push(bytes2) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes2.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes2, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes2, 0);
      } else {
        this.chunks.push(bytes2);
        this.maxCursor += bytes2.length;
      }
    }
    this.cursor += bytes2.length;
  }
  /**
   * @param {boolean} [reset]
   * @returns {Uint8Array}
   */
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat$1(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
}
const decodeErrPrefix = "CBOR decode error:";
const encodeErrPrefix = "CBOR encode error:";
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
const uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function readUint8(data, offset, options2) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options2.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options2) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options2.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options2) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options2.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options2) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options2.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options2.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options2) {
  return new Token$1(Type.uint, readUint8(data, pos + 1, options2), 2);
}
function decodeUint16(data, pos, _minor, options2) {
  return new Token$1(Type.uint, readUint16(data, pos + 1, options2), 3);
}
function decodeUint32(data, pos, _minor, options2) {
  return new Token$1(Type.uint, readUint32(data, pos + 1, options2), 5);
}
function decodeUint64(data, pos, _minor, options2) {
  return new Token$1(Type.uint, readUint64(data, pos + 1, options2), 9);
}
function encodeUint(buf2, token2) {
  return encodeUintValue(buf2, 0, token2.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([major | 24, nuint]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set2 = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set2[8] = lo & 255;
      lo = lo >> 8;
      set2[7] = lo & 255;
      lo = lo >> 8;
      set2[6] = lo & 255;
      lo = lo >> 8;
      set2[5] = lo & 255;
      set2[4] = hi & 255;
      hi = hi >> 8;
      set2[3] = hi & 255;
      hi = hi >> 8;
      set2[2] = hi & 255;
      hi = hi >> 8;
      set2[1] = hi & 255;
      buf2.push(set2);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
    /* c8 ignore next */
    0
  );
};
function decodeNegint8(data, pos, _minor, options2) {
  return new Token$1(Type.negint, -1 - readUint8(data, pos + 1, options2), 2);
}
function decodeNegint16(data, pos, _minor, options2) {
  return new Token$1(Type.negint, -1 - readUint16(data, pos + 1, options2), 3);
}
function decodeNegint32(data, pos, _minor, options2) {
  return new Token$1(Type.negint, -1 - readUint32(data, pos + 1, options2), 5);
}
const neg1b = BigInt(-1);
const pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options2) {
  const int = readUint64(data, pos + 1, options2);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token$1(Type.negint, value, 9);
    }
  }
  if (options2.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token$1(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token2) {
  const negint = token2.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token2.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token2) {
  const negint = token2.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
    /* c8 ignore next */
    0
  );
};
function toToken$3(data, pos, prefix, length2) {
  assertEnoughData(data, pos, prefix + length2);
  const buf2 = slice(data, pos + prefix, pos + prefix + length2);
  return new Token$1(Type.bytes, buf2, prefix + length2);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken$3(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options2) {
  return toToken$3(data, pos, 2, readUint8(data, pos + 1, options2));
}
function decodeBytes16(data, pos, _minor, options2) {
  return toToken$3(data, pos, 3, readUint16(data, pos + 1, options2));
}
function decodeBytes32(data, pos, _minor, options2) {
  return toToken$3(data, pos, 5, readUint32(data, pos + 1, options2));
}
function decodeBytes64(data, pos, _minor, options2) {
  const l = readUint64(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken$3(data, pos, 9, l);
}
function tokenBytes(token2) {
  if (token2.encodedBytes === void 0) {
    token2.encodedBytes = token2.type === Type.string ? fromString(token2.value) : token2.value;
  }
  return token2.encodedBytes;
}
function encodeBytes(buf2, token2) {
  const bytes2 = tokenBytes(token2);
  encodeUintValue(buf2, token2.type.majorEncoded, bytes2.length);
  buf2.push(bytes2);
}
encodeBytes.encodedSize = function encodedSize4(token2) {
  const bytes2 = tokenBytes(token2);
  return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}
function toToken$2(data, pos, prefix, length2, options2) {
  const totLength = prefix + length2;
  assertEnoughData(data, pos, totLength);
  const tok = new Token$1(Type.string, toString$3(data, pos + prefix, pos + totLength), totLength);
  if (options2.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options2) {
  return toToken$2(data, pos, 1, minor, options2);
}
function decodeString8(data, pos, _minor, options2) {
  return toToken$2(data, pos, 2, readUint8(data, pos + 1, options2), options2);
}
function decodeString16(data, pos, _minor, options2) {
  return toToken$2(data, pos, 3, readUint16(data, pos + 1, options2), options2);
}
function decodeString32(data, pos, _minor, options2) {
  return toToken$2(data, pos, 5, readUint32(data, pos + 1, options2), options2);
}
function decodeString64(data, pos, _minor, options2) {
  const l = readUint64(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken$2(data, pos, 9, l, options2);
}
const encodeString = encodeBytes;
function toToken$1(_data, _pos, prefix, length2) {
  return new Token$1(Type.array, length2, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken$1(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options2) {
  return toToken$1(data, pos, 2, readUint8(data, pos + 1, options2));
}
function decodeArray16(data, pos, _minor, options2) {
  return toToken$1(data, pos, 3, readUint16(data, pos + 1, options2));
}
function decodeArray32(data, pos, _minor, options2) {
  return toToken$1(data, pos, 5, readUint32(data, pos + 1, options2));
}
function decodeArray64(data, pos, _minor, options2) {
  const l = readUint64(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken$1(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken$1(data, pos, 1, Infinity);
}
function encodeArray(buf2, token2) {
  encodeUintValue(buf2, Type.array.majorEncoded, token2.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
function toToken(_data, _pos, prefix, length2) {
  return new Token$1(Type.map, length2, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options2) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options2));
}
function decodeMap16(data, pos, _minor, options2) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options2));
}
function decodeMap32(data, pos, _minor, options2) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options2));
}
function decodeMap64(data, pos, _minor, options2) {
  const l = readUint64(data, pos + 1, options2);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken(data, pos, 1, Infinity);
}
function encodeMap(buf2, token2) {
  encodeUintValue(buf2, Type.map.majorEncoded, token2.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token$1(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options2) {
  return new Token$1(Type.tag, readUint8(data, pos + 1, options2), 2);
}
function decodeTag16(data, pos, _minor, options2) {
  return new Token$1(Type.tag, readUint16(data, pos + 1, options2), 3);
}
function decodeTag32(data, pos, _minor, options2) {
  return new Token$1(Type.tag, readUint32(data, pos + 1, options2), 5);
}
function decodeTag64(data, pos, _minor, options2) {
  return new Token$1(Type.tag, readUint64(data, pos + 1, options2), 9);
}
function encodeTag(buf2, token2) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token2.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token2) {
  return encodeUintValue.encodedSize(token2.value);
};
const MINOR_FALSE = 20;
const MINOR_TRUE = 21;
const MINOR_NULL = 22;
const MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options2) {
  if (options2.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options2.coerceUndefinedToNull === true) {
    return new Token$1(Type.null, null, 1);
  }
  return new Token$1(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options2) {
  if (options2.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token$1(Type.break, void 0, 1);
}
function createToken(value, bytes2, options2) {
  if (options2) {
    if (options2.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options2.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token$1(Type.float, value, bytes2);
}
function decodeFloat16(data, pos, _minor, options2) {
  return createToken(readFloat16(data, pos + 1), 3, options2);
}
function decodeFloat32(data, pos, _minor, options2) {
  return createToken(readFloat32(data, pos + 1), 5, options2);
}
function decodeFloat64(data, pos, _minor, options2) {
  return createToken(readFloat64(data, pos + 1), 9, options2);
}
function encodeFloat(buf2, token2, options2) {
  const float = token2.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options2 || options2.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token2, options2) {
  const float = token2.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options2 || options2.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
const buffer = new ArrayBuffer(9);
const dataView = new DataView(buffer, 1);
const ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
const jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
const quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token$1(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token$1(Type.negint, i, 1);
}
quick[64] = new Token$1(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token$1(Type.string, "", 1);
quick[128] = new Token$1(Type.array, 0, 1);
quick[160] = new Token$1(Type.map, 0, 1);
quick[244] = new Token$1(Type.false, false, 1);
quick[245] = new Token$1(Type.true, true, 1);
quick[246] = new Token$1(Type.null, null, 1);
function quickEncodeToken(token2) {
  switch (token2.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token2.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token2.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token2.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token2.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token2.value < 24) {
        return fromArray([Number(token2.value)]);
      }
      return;
    case Type.negint:
      if (token2.value >= -24) {
        return fromArray([31 - Number(token2.value)]);
      }
  }
}
const defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
const cborEncoders = makeCborEncoders();
const buf = new Bl();
class Ref {
  /**
   * @param {object|any[]} obj
   * @param {Reference|undefined} parent
   */
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  /**
   * @param {object|any[]} obj
   * @returns {boolean}
   */
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  /**
   * @param {Reference|undefined} stack
   * @param {object|any[]} obj
   * @returns {Reference}
   */
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
}
const simpleTokens = {
  null: new Token$1(Type.null, null),
  undefined: new Token$1(Type.undefined, void 0),
  true: new Token$1(Type.true, true),
  false: new Token$1(Type.false, false),
  emptyArray: new Token$1(Type.array, 0),
  emptyMap: new Token$1(Type.map, 0)
};
const typeEncoders = {
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token$1(Type.float, obj);
    } else if (obj >= 0) {
      return new Token$1(Type.uint, obj);
    } else {
      return new Token$1(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token$1(Type.uint, obj);
    } else {
      return new Token$1(Type.negint, obj);
    }
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token$1(Type.bytes, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  string(obj, _typ, _options, _refStack) {
    return new Token$1(Type.string, obj);
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  /**
   * @param {any} _obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token$1(Type.bytes, new Uint8Array(obj));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} _options
   * @param {Reference} [_refStack]
   * @returns {TokenOrNestedTokens}
   */
  DataView(obj, _typ, _options, _refStack) {
    return new Token$1(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  /**
   * @param {any} obj
   * @param {string} _typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Array(obj, _typ, options2, refStack) {
    if (!obj.length) {
      if (options2.addBreakTokens === true) {
        return [simpleTokens.emptyArray, new Token$1(Type.break)];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options2, refStack);
    }
    if (options2.addBreakTokens) {
      return [new Token$1(Type.array, obj.length), entries, new Token$1(Type.break)];
    }
    return [new Token$1(Type.array, obj.length), entries];
  },
  /**
   * @param {any} obj
   * @param {string} typ
   * @param {EncodeOptions} options
   * @param {Reference} [refStack]
   * @returns {TokenOrNestedTokens}
   */
  Object(obj, typ, options2, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length2 = isMap ? obj.size : keys.length;
    if (!length2) {
      if (options2.addBreakTokens === true) {
        return [simpleTokens.emptyMap, new Token$1(Type.break)];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options2, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options2, refStack)
      ];
    }
    sortMapEntries(entries, options2);
    if (options2.addBreakTokens) {
      return [new Token$1(Type.map, length2), entries, new Token$1(Type.break)];
    }
    return [new Token$1(Type.map, length2), entries];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options2 = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options2 && options2.typeEncoders && /** @type {OptionalTypeEncoder} */
  options2.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options2, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options2, refStack);
}
function sortMapEntries(entries, options2) {
  if (options2.mapSorter) {
    entries.sort(options2.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options2) {
  if (Array.isArray(tokens)) {
    for (const token2 of tokens) {
      tokensToEncoded(buf2, token2, encoders, options2);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options2);
  }
}
function encodeCustom(data, encoders, options2) {
  const tokens = objectToTokens(data, options2);
  if (!Array.isArray(tokens) && options2.quickEncodeToken) {
    const quickBytes = options2.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options2);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options2);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options2);
  return buf.toBytes(true);
}
function encode$2(data, options2) {
  options2 = Object.assign({}, defaultEncodeOptions, options2);
  return encodeCustom(data, cborEncoders, options2);
}
const defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
class Tokeniser {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options2 = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options2;
  }
  pos() {
    return this._pos;
  }
  done() {
    return this._pos >= this.data.length;
  }
  next() {
    const byt = this.data[this._pos];
    let token2 = quick[byt];
    if (token2 === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token2 = decoder(this.data, this._pos, minor, this.options);
    }
    this._pos += token2.encodedLength;
    return token2;
  }
}
const DONE = Symbol.for("DONE");
const BREAK = Symbol.for("BREAK");
function tokenToArray(token2, tokeniser, options2) {
  const arr = [];
  for (let i = 0; i < token2.value; i++) {
    const value = tokensToObject(tokeniser, options2);
    if (value === BREAK) {
      if (token2.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token2.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token2, tokeniser, options2) {
  const useMaps = options2.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m2 = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token2.value; i++) {
    const key = tokensToObject(tokeniser, options2);
    if (key === BREAK) {
      if (token2.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token2.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options2.rejectDuplicateMapKeys === true) {
      if (useMaps && m2.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options2);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token2.value})`);
    }
    if (useMaps) {
      m2.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m2 : obj;
}
function tokensToObject(tokeniser, options2) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token2 = tokeniser.next();
  if (token2.type === Type.break) {
    return BREAK;
  }
  if (token2.type.terminal) {
    return token2.value;
  }
  if (token2.type === Type.array) {
    return tokenToArray(token2, tokeniser, options2);
  }
  if (token2.type === Type.map) {
    return tokenToMap(token2, tokeniser, options2);
  }
  if (token2.type === Type.tag) {
    if (options2.tags && typeof options2.tags[token2.value] === "function") {
      const tagged = tokensToObject(tokeniser, options2);
      return options2.tags[token2.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token2.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst(data, options2) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options2 = Object.assign({}, defaultDecodeOptions, options2);
  const tokeniser = options2.tokenizer || new Tokeniser(data, options2);
  const decoded = tokensToObject(tokeniser, options2);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode$5(data, options2) {
  const [decoded, remainder] = decodeFirst(data, options2);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
const CID_CBOR_TAG = 42;
function toByteView$1(buf2) {
  if (buf2 instanceof ArrayBuffer) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }
  return buf2;
}
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token$1(Type.tag, CID_CBOR_TAG),
    new Token$1(Type.bytes, bytes2)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const _encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
({
  ..._encodeOptions,
  typeEncoders: {
    ..._encodeOptions.typeEncoders
  }
});
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes2.subarray(1));
}
const _decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
({
  ..._decodeOptions,
  tags: _decodeOptions.tags.slice()
});
const code$1 = 113;
const encode$1 = (node) => encode$2(node, _encodeOptions);
const decode$4 = (data) => decode$5(toByteView$1(data), _decodeOptions);
class JSONEncoder extends Array {
  constructor() {
    super();
    this.inRecursive = [];
  }
  /**
   * @param {Bl} buf
   */
  prefix(buf2) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf2.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf2.push([44]);
          } else {
            buf2.push([58]);
          }
        }
      }
    }
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.uint.major](buf2, token2) {
    this.prefix(buf2);
    const is2 = String(token2.value);
    const isa = [];
    for (let i = 0; i < is2.length; i++) {
      isa[i] = is2.charCodeAt(i);
    }
    buf2.push(isa);
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.negint.major](buf2, token2) {
    this[Type.uint.major](buf2, token2);
  }
  /**
   * @param {Bl} _buf
   * @param {Token} _token
   */
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.string.major](buf2, token2) {
    this.prefix(buf2);
    const byts = fromString(JSON.stringify(token2.value));
    buf2.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  /**
   * @param {Bl} buf
   * @param {Token} _token
   */
  [Type.array.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({ type: Type.array, elements: 0 });
    buf2.push([91]);
  }
  /**
   * @param {Bl} buf
   * @param {Token} _token
   */
  [Type.map.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({ type: Type.map, elements: 0 });
    buf2.push([123]);
  }
  /**
   * @param {Bl} _buf
   * @param {Token} _token
   */
  [Type.tag.major](_buf, _token) {
  }
  /**
   * @param {Bl} buf
   * @param {Token} token
   */
  [Type.float.major](buf2, token2) {
    if (token2.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf2.push([93]);
        } else if (recurs.type === Type.map) {
          buf2.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token2.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf2);
    if (token2.type.name === "true") {
      buf2.push([116, 114, 117, 101]);
      return;
    } else if (token2.type.name === "false") {
      buf2.push([102, 97, 108, 115, 101]);
      return;
    } else if (token2.type.name === "null") {
      buf2.push([110, 117, 108, 108]);
      return;
    }
    const is2 = String(token2.value);
    const isa = [];
    let dp = false;
    for (let i = 0; i < is2.length; i++) {
      isa[i] = is2.charCodeAt(i);
      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf2.push(isa);
  }
}
class Tokenizer {
  /**
   * @param {Uint8Array} data
   * @param {DecodeOptions} options
   */
  constructor(data, options2 = {}) {
    this._pos = 0;
    this.data = data;
    this.options = options2;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  pos() {
    return this._pos;
  }
  /**
   * @returns {boolean}
   */
  done() {
    return this._pos >= this.data.length;
  }
  /**
   * @returns {number}
   */
  ch() {
    return this.data[this._pos];
  }
  /**
   * @returns {string}
   */
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this._pos];
    }
  }
  /**
   * @param {number[]} str
   */
  expect(str) {
    if (this.data.length - this._pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`);
    }
    for (let i = 0; i < str.length; i++) {
      if (this.data[this._pos++] !== str[i]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this._pos;
    let negative = false;
    let float = false;
    const swallow = (chars) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars.includes(ch)) {
          this._pos++;
        } else {
          break;
        }
      }
    };
    if (this.ch() === 45) {
      negative = true;
      this._pos++;
    }
    if (this.ch() === 48) {
      this._pos++;
      if (this.ch() === 46) {
        this._pos++;
        float = true;
      } else {
        return new Token$1(Type.uint, 0, this._pos - startPos);
      }
    }
    swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    if (negative && this._pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`);
      }
      float = true;
      this._pos++;
      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float = true;
      this._pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this._pos++;
      }
      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos));
    const num = parseFloat(numStr);
    if (float) {
      return new Token$1(Type.float, num, this._pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
      return new Token$1(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos);
    }
    return new Token$1(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos);
  }
  /**
   * @returns {Token}
   */
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`);
    }
    this._pos++;
    for (let i = this._pos, l = 0; i < this.data.length && l < 65536; i++, l++) {
      const ch = this.data[i];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i));
        this._pos = i + 1;
        return new Token$1(Type.string, str, l);
      }
    }
    const startPos = this._pos;
    const chars = [];
    const readu4 = () => {
      if (this._pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`);
      }
      let u4 = 0;
      for (let i = 0; i < 4; i++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`);
        }
        u4 = u4 * 16 + ch;
        this._pos++;
      }
      return u4;
    };
    const readUtf8Char = () => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this._pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this._pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this._pos + 1];
          thirdByte = this.data[this._pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this._pos + 1];
          thirdByte = this.data[this._pos + 2];
          fourthByte = this.data[this._pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars.push(codePoint);
      this._pos += bytesPerSequence;
    };
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this._pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`);
          }
          ch1 = this.ch();
          this._pos++;
          switch (ch1) {
            case 34:
            case 39:
            case 92:
            case 47:
              chars.push(ch1);
              break;
            case 98:
              chars.push(8);
              break;
            case 116:
              chars.push(9);
              break;
            case 110:
              chars.push(10);
              break;
            case 102:
              chars.push(12);
              break;
            case 114:
              chars.push(13);
              break;
            case 117:
              chars.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`);
          }
          break;
        case 34:
          this._pos++;
          return new Token$1(Type.string, decodeCodePointsArray(chars), this._pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`);
          } else if (ch < 128) {
            chars.push(ch);
            this._pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`);
  }
  /**
   * @returns {Token}
   */
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this._pos++;
        return new Token$1(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this._pos++;
        return new Token$1(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([110, 117, 108, 108]);
        return new Token$1(Type.null, null, 4);
      case 102:
        this.expect([102, 97, 108, 115, 101]);
        return new Token$1(Type.false, false, 5);
      case 116:
        this.expect([116, 114, 117, 101]);
        return new Token$1(Type.true, true, 4);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`);
    }
  }
  /**
   * @returns {Token}
   */
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this._pos++;
          this.skipWhitespace();
          return new Token$1(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this._pos++;
          this.skipWhitespace();
          return new Token$1(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this._pos++;
          this.skipWhitespace();
          return new Token$1(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this._pos++;
          this.skipWhitespace();
          return new Token$1(Type.break, void 0, 1);
        }
        const token2 = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this._pos++;
        this.modeStack.push("obj-value");
        return token2;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`);
    }
  }
}
function decode$3(data, options2) {
  options2 = Object.assign({ tokenizer: new Tokenizer(data, options2) }, options2);
  return decode$5(data, options2);
}
function toByteView(buf2) {
  if (buf2 instanceof ArrayBuffer) {
    return new Uint8Array(buf2, 0, buf2.byteLength);
  }
  return buf2;
}
let DagJsonTokenizer$1 = class DagJsonTokenizer extends Tokenizer {
  /**
   * @param {Uint8Array} data
   * @param {object} [options]
   */
  constructor(data, options2) {
    super(data, options2);
    this.tokenBuffer = [];
  }
  /**
   * @returns {boolean}
   */
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  /**
   * @returns {Token}
   */
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   *
   * @returns {Token}
   */
  next() {
    const token2 = this._next();
    if (token2.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token$1(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i = 0; i < 2; i++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes2 = base64.decode(`m${innerValueToken.value}`);
              return new Token$1(Type.bytes, bytes2, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token2;
  }
};
const decodeOptions = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  // this will lead to BigInt for ints outside of
  // safe-integer range, which may surprise users
  strict: true,
  useMaps: false,
  rejectDuplicateMapKeys: true,
  /** @type {import('cborg').TagDecoder[]} */
  tags: []
};
decodeOptions.tags[42] = CID.parse;
const code = 297;
const decode$2 = (data) => {
  const buf2 = toByteView(data);
  const options2 = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer$1(buf2, decodeOptions) });
  return decode$3(buf2, options2);
};
new TextDecoder();
new TextEncoder();
function resolveObjectPath(object, block, cid, name2, path, toResolve, depth) {
  let subObject = object;
  let subPath = path;
  while (toResolve.length > 0) {
    const prop = toResolve[0];
    if (prop in subObject) {
      toResolve.shift();
      subPath = `${subPath}/${prop}`;
      const subObjectCid = CID.asCID(subObject[prop]);
      if (subObjectCid != null) {
        return {
          entry: {
            type: "object",
            name: name2,
            path,
            cid,
            node: block,
            depth,
            size: BigInt(block.length),
            content: async function* () {
              yield object;
            }
          },
          next: {
            cid: subObjectCid,
            name: prop,
            path: subPath,
            toResolve
          }
        };
      }
      subObject = subObject[prop];
    } else {
      throw errCode$1(new Error(`No property named ${prop} found in node ${cid}`), "ERR_NO_PROP");
    }
  }
  return {
    entry: {
      type: "object",
      name: name2,
      path,
      cid,
      node: block,
      depth,
      size: BigInt(block.length),
      content: async function* () {
        yield object;
      }
    }
  };
}
const resolve$6 = async (cid, name2, path, toResolve, resolve2, depth, blockstore, options2) => {
  const block = await blockstore.get(cid, options2);
  const object = decode$4(block);
  return resolveObjectPath(object, block, cid, name2, path, toResolve, depth);
};
const resolve$5 = async (cid, name2, path, toResolve, resolve2, depth, blockstore, options2) => {
  const block = await blockstore.get(cid, options2);
  const object = decode$2(block);
  return resolveObjectPath(object, block, cid, name2, path, toResolve, depth);
};
function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
  const blockLength = BigInt(block.length);
  const blockEnd = BigInt(blockStart + blockLength);
  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    return new Uint8Array(0);
  }
  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    block = block.subarray(0, Number(requestedEnd - blockStart));
  }
  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    block = block.subarray(Number(requestedStart - blockStart));
  }
  return block;
}
const validateOffsetAndLength = (size, offset = 0, length2 = size) => {
  const fileSize = BigInt(size);
  const start2 = BigInt(offset ?? 0);
  let end = BigInt(length2);
  if (end !== fileSize) {
    end = start2 + end;
  }
  if (end > fileSize) {
    end = fileSize;
  }
  if (start2 < 0n) {
    throw errCode$1(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (start2 > fileSize) {
    throw errCode$1(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
  }
  if (end < 0n) {
    throw errCode$1(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
  }
  if (end > fileSize) {
    throw errCode$1(new Error("Length must be less than the file size"), "ERR_INVALID_PARAMS");
  }
  return {
    start: start2,
    end
  };
};
const rawContent$1 = (node) => {
  async function* contentGenerator(options2 = {}) {
    var _a3;
    const { start: start2, end } = validateOffsetAndLength(node.length, options2.offset, options2.length);
    const buf2 = extractDataFromBlock(node, 0n, start2, end);
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("unixfs:exporter:progress:identity", {
      bytesRead: BigInt(buf2.byteLength),
      totalBytes: end - start2,
      fileSize: BigInt(node.byteLength)
    }));
    yield buf2;
  }
  return contentGenerator;
};
const resolve$4 = async (cid, name2, path, toResolve, resolve2, depth, blockstore, options2) => {
  if (toResolve.length > 0) {
    throw errCode$1(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const buf2 = decode$d(cid.multihash.bytes);
  return {
    entry: {
      type: "identity",
      name: name2,
      path,
      cid,
      content: rawContent$1(buf2.digest),
      depth,
      size: BigInt(buf2.digest.length),
      node: buf2.digest
    }
  };
};
const resolve$3 = async (cid, name2, path, toResolve, resolve2, depth, blockstore, options2) => {
  const block = await blockstore.get(cid, options2);
  const object = decode$7(block);
  return resolveObjectPath(object, block, cid, name2, path, toResolve, depth);
};
const rawContent = (node) => {
  async function* contentGenerator(options2 = {}) {
    var _a3;
    const { start: start2, end } = validateOffsetAndLength(node.length, options2.offset, options2.length);
    const buf2 = extractDataFromBlock(node, 0n, start2, end);
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("unixfs:exporter:progress:raw", {
      bytesRead: BigInt(buf2.byteLength),
      totalBytes: end - start2,
      fileSize: BigInt(node.byteLength)
    }));
    yield buf2;
  }
  return contentGenerator;
};
const resolve$2 = async (cid, name2, path, toResolve, resolve2, depth, blockstore, options2) => {
  if (toResolve.length > 0) {
    throw errCode$1(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
  }
  const block = await blockstore.get(cid, options2);
  return {
    entry: {
      type: "raw",
      name: name2,
      path,
      cid,
      content: rawContent(block),
      depth,
      size: BigInt(block.length),
      node: block
    }
  };
};
const hashFn = async function(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
};
const addLinksToHamtBucket = async (links2, bucket, rootBucket) => {
  const padLength = (bucket.tableSize() - 1).toString(16).length;
  await Promise.all(links2.map(async (link) => {
    if (link.Name == null) {
      throw new Error("Unexpected Link without a Name");
    }
    if (link.Name.length === padLength) {
      const pos = parseInt(link.Name, 16);
      bucket._putObjectAt(pos, new Bucket({
        hash: rootBucket._options.hash,
        bits: rootBucket._options.bits
      }, bucket, pos));
      return;
    }
    await rootBucket.put(link.Name.substring(2), true);
  }));
};
const toPrefix$1 = (position, padLength) => {
  return position.toString(16).toUpperCase().padStart(padLength, "0").substring(0, padLength);
};
const toBucketPath = (position) => {
  let bucket = position.bucket;
  const path = [];
  while (bucket._parent != null) {
    path.push(bucket);
    bucket = bucket._parent;
  }
  path.push(bucket);
  return path.reverse();
};
const findShardCid = async (node, name2, blockstore, context, options2) => {
  if (context == null) {
    if (node.Data == null) {
      throw errCode$1(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
    }
    let dir;
    try {
      dir = UnixFS$1.unmarshal(node.Data);
    } catch (err) {
      throw errCode$1(err, "ERR_NOT_UNIXFS");
    }
    if (dir.type !== "hamt-sharded-directory") {
      throw errCode$1(new Error("not a HAMT"), "ERR_NOT_UNIXFS");
    }
    if (dir.fanout == null) {
      throw errCode$1(new Error("missing fanout"), "ERR_NOT_UNIXFS");
    }
    const rootBucket = createHAMT({
      hashFn,
      bits: Math.log2(Number(dir.fanout))
    });
    context = {
      rootBucket,
      hamtDepth: 1,
      lastBucket: rootBucket
    };
  }
  const padLength = (context.lastBucket.tableSize() - 1).toString(16).length;
  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);
  const position = await context.rootBucket._findNewBucketAndPos(name2);
  let prefix = toPrefix$1(position.pos, padLength);
  const bucketPath = toBucketPath(position);
  if (bucketPath.length > context.hamtDepth) {
    context.lastBucket = bucketPath[context.hamtDepth];
    prefix = toPrefix$1(context.lastBucket._posAtParent, padLength);
  }
  const link = node.Links.find((link2) => {
    if (link2.Name == null) {
      return false;
    }
    const entryPrefix = link2.Name.substring(0, padLength);
    const entryName = link2.Name.substring(padLength);
    if (entryPrefix !== prefix) {
      return false;
    }
    if (entryName !== "" && entryName !== name2) {
      return false;
    }
    return true;
  });
  if (link == null) {
    return;
  }
  if (link.Name != null && link.Name.substring(padLength) === name2) {
    return link.Hash;
  }
  context.hamtDepth++;
  const block = await blockstore.get(link.Hash, options2);
  node = decode$a(block);
  return findShardCid(node, name2, blockstore, context, options2);
};
function peekable(iterable) {
  const [iterator, symbol2] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
  const queue = [];
  return {
    peek: () => {
      return iterator.next();
    },
    push: (value) => {
      queue.push(value);
    },
    next: () => {
      if (queue.length > 0) {
        return {
          done: false,
          value: queue.shift()
        };
      }
      return iterator.next();
    },
    [symbol2]() {
      return this;
    }
  };
}
function isAsyncIterable$7(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function filter(source, fn) {
  let index2 = 0;
  if (isAsyncIterable$7(source)) {
    return async function* () {
      for await (const entry of source) {
        if (await fn(entry, index2++)) {
          yield entry;
        }
      }
    }();
  }
  const peekable$1 = peekable(source);
  const { value, done } = peekable$1.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = fn(value, index2++);
  if (typeof res.then === "function") {
    return async function* () {
      if (await res) {
        yield value;
      }
      for await (const entry of peekable$1) {
        if (await fn(entry, index2++)) {
          yield entry;
        }
      }
    }();
  }
  const func2 = fn;
  return function* () {
    if (res === true) {
      yield value;
    }
    for (const entry of peekable$1) {
      if (func2(entry, index2++)) {
        yield entry;
      }
    }
  }();
}
function isAsyncIterable$6(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function map(source, func2) {
  let index2 = 0;
  if (isAsyncIterable$6(source)) {
    return async function* () {
      for await (const val of source) {
        yield func2(val, index2++);
      }
    }();
  }
  const peekable$1 = peekable(source);
  const { value, done } = peekable$1.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = func2(value, index2++);
  if (typeof res.then === "function") {
    return async function* () {
      yield await res;
      for await (const val of peekable$1) {
        yield func2(val, index2++);
      }
    }();
  }
  const fn = func2;
  return function* () {
    yield res;
    for (const val of peekable$1) {
      yield fn(val, index2++);
    }
  }();
}
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve2, reject) => {
    deferred.resolve = resolve2;
    deferred.reject = reject;
  });
  return deferred;
}
const CustomEvent$2 = globalThis.CustomEvent ?? Event;
async function* parallel(source, options2 = {}) {
  let concurrency = options2.concurrency ?? Infinity;
  if (concurrency < 1) {
    concurrency = Infinity;
  }
  const ordered = options2.ordered == null ? false : options2.ordered;
  const emitter = new EventTarget();
  const ops = [];
  let slotAvailable = pDefer();
  let resultAvailable = pDefer();
  let sourceFinished = false;
  let sourceErr;
  let opErred = false;
  emitter.addEventListener("task-complete", () => {
    resultAvailable.resolve();
  });
  void Promise.resolve().then(async () => {
    try {
      for await (const task of source) {
        if (ops.length === concurrency) {
          slotAvailable = pDefer();
          await slotAvailable.promise;
        }
        if (opErred) {
          break;
        }
        const op = {
          done: false
        };
        ops.push(op);
        task().then((result) => {
          op.done = true;
          op.ok = true;
          op.value = result;
          emitter.dispatchEvent(new CustomEvent$2("task-complete"));
        }, (err) => {
          op.done = true;
          op.err = err;
          emitter.dispatchEvent(new CustomEvent$2("task-complete"));
        });
      }
      sourceFinished = true;
      emitter.dispatchEvent(new CustomEvent$2("task-complete"));
    } catch (err) {
      sourceErr = err;
      emitter.dispatchEvent(new CustomEvent$2("task-complete"));
    }
  });
  function valuesAvailable() {
    var _a3;
    if (ordered) {
      return (_a3 = ops[0]) == null ? void 0 : _a3.done;
    }
    return Boolean(ops.find((op) => op.done));
  }
  function* yieldOrderedValues() {
    while (ops.length > 0 && ops[0].done) {
      const op = ops[0];
      ops.shift();
      if (op.ok) {
        yield op.value;
      } else {
        opErred = true;
        slotAvailable.resolve();
        throw op.err;
      }
      slotAvailable.resolve();
    }
  }
  function* yieldUnOrderedValues() {
    while (valuesAvailable()) {
      for (let i = 0; i < ops.length; i++) {
        if (ops[i].done) {
          const op = ops[i];
          ops.splice(i, 1);
          i--;
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
    }
  }
  while (true) {
    if (!valuesAvailable()) {
      resultAvailable = pDefer();
      await resultAvailable.promise;
    }
    if (sourceErr != null) {
      throw sourceErr;
    }
    if (ordered) {
      yield* yieldOrderedValues();
    } else {
      yield* yieldUnOrderedValues();
    }
    if (sourceFinished && ops.length === 0) {
      break;
    }
  }
}
class FixedFIFO {
  constructor(hwm) {
    __publicField(this, "buffer");
    __publicField(this, "mask");
    __publicField(this, "top");
    __publicField(this, "btm");
    __publicField(this, "next");
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last2 = this.buffer[this.btm];
    if (last2 === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last2;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
}
class FIFO {
  constructor(options2 = {}) {
    __publicField(this, "size");
    __publicField(this, "hwm");
    __publicField(this, "head");
    __publicField(this, "tail");
    this.hwm = options2.splitLimit ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if ((obj == null ? void 0 : obj.byteLength) != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if ((val == null ? void 0 : val.value) != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if ((val == null ? void 0 : val.value) != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
}
let AbortError$5 = class AbortError extends Error {
  constructor(message2, code2) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.code = code2 ?? "ABORT_ERR";
  }
};
function pushable(options2 = {}) {
  const getNext = (buffer2) => {
    const next = buffer2.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      // @ts-expect-error if done is false, value will be present
      value: next.value
    };
  };
  return _pushable(getNext, options2);
}
function _pushable(getNext, options2) {
  options2 = options2 ?? {};
  let onEnd = options2.onEnd;
  let buffer2 = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  let drain2 = pDefer();
  const waitNext = async () => {
    try {
      if (!buffer2.isEmpty()) {
        return getNext(buffer2);
      }
      if (ended) {
        return { done: true };
      }
      return await new Promise((resolve2, reject) => {
        onNext = (next) => {
          onNext = null;
          buffer2.push(next);
          try {
            resolve2(getNext(buffer2));
          } catch (err) {
            reject(err);
          }
          return pushable2;
        };
      });
    } finally {
      if (buffer2.isEmpty()) {
        queueMicrotask(() => {
          drain2.resolve();
          drain2 = pDefer();
        });
      }
    }
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer2.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer2 = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer2.push({ error: err });
    return pushable2;
  };
  const push = (value) => {
    if (ended) {
      return pushable2;
    }
    if ((options2 == null ? void 0 : options2.objectMode) !== true && (value == null ? void 0 : value.byteLength) == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value });
  };
  const end = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer2 = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end,
    get readableLength() {
      return buffer2.size;
    },
    onEmpty: async (options3) => {
      const signal = options3 == null ? void 0 : options3.signal;
      signal == null ? void 0 : signal.throwIfAborted();
      if (buffer2.isEmpty()) {
        return;
      }
      let cancel;
      let listener;
      if (signal != null) {
        cancel = new Promise((resolve2, reject) => {
          listener = () => {
            reject(new AbortError$5());
          };
          signal.addEventListener("abort", listener);
        });
      }
      try {
        await Promise.race([
          drain2.promise,
          cancel
        ]);
      } finally {
        if (listener != null && signal != null) {
          signal == null ? void 0 : signal.removeEventListener("abort", listener);
        }
      }
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    },
    onEmpty: (opts) => {
      return _pushable2.onEmpty(opts);
    }
  };
  return pushable2;
}
function isAsyncIterable$5(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function merge$1(...sources) {
  const syncSources = [];
  for (const source of sources) {
    if (!isAsyncIterable$5(source)) {
      syncSources.push(source);
    }
  }
  if (syncSources.length === sources.length) {
    return function* () {
      for (const source of syncSources) {
        yield* source;
      }
    }();
  }
  return async function* () {
    const output2 = pushable({
      objectMode: true
    });
    void Promise.resolve().then(async () => {
      try {
        await Promise.all(sources.map(async (source) => {
          for await (const item of source) {
            output2.push(item);
          }
        }));
        output2.end();
      } catch (err) {
        output2.end(err);
      }
    });
    yield* output2;
  }();
}
function pipe(first2, ...rest) {
  if (first2 == null) {
    throw new Error("Empty pipeline");
  }
  if (isDuplex(first2)) {
    const duplex = first2;
    first2 = () => duplex.source;
  } else if (isIterable(first2) || isAsyncIterable$4(first2)) {
    const source = first2;
    first2 = () => source;
  }
  const fns = [first2, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i = 1; i < fns.length - 1; i++) {
      if (isDuplex(fns[i])) {
        fns[i] = duplexPipelineFn(fns[i]);
      }
    }
  }
  return rawPipe(...fns);
}
const rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
const isAsyncIterable$4 = (obj) => {
  return (obj == null ? void 0 : obj[Symbol.asyncIterator]) != null;
};
const isIterable = (obj) => {
  return (obj == null ? void 0 : obj[Symbol.iterator]) != null;
};
const isDuplex = (obj) => {
  if (obj == null) {
    return false;
  }
  return obj.sink != null && obj.source != null;
};
const duplexPipelineFn = (duplex) => {
  return (source) => {
    const p = duplex.sink(source);
    if ((p == null ? void 0 : p.then) != null) {
      const stream = pushable({
        objectMode: true
      });
      p.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      let sourceWrap;
      const source2 = duplex.source;
      if (isAsyncIterable$4(source2)) {
        sourceWrap = async function* () {
          yield* source2;
          stream.end();
        };
      } else if (isIterable(source2)) {
        sourceWrap = function* () {
          yield* source2;
          stream.end();
        };
      } else {
        throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
      }
      return merge$1(stream, sourceWrap());
    }
    return duplex.source;
  };
};
const directoryContent = (cid, node, unixfs2, path, resolve2, depth, blockstore) => {
  async function* yieldDirectoryContent(options2 = {}) {
    var _a3;
    const offset = options2.offset ?? 0;
    const length2 = options2.length ?? node.Links.length;
    const links2 = node.Links.slice(offset, length2);
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("unixfs:exporter:walk:directory", {
      cid
    }));
    yield* pipe(links2, (source) => map(source, (link) => {
      return async () => {
        const linkName = link.Name ?? "";
        const linkPath = `${path}/${linkName}`;
        const result = await resolve2(link.Hash, linkName, linkPath, [], depth + 1, blockstore, options2);
        return result.entry;
      };
    }), (source) => parallel(source, {
      ordered: true,
      concurrency: options2.blockReadConcurrency
    }), (source) => filter(source, (entry) => entry != null));
  }
  return yieldDirectoryContent;
};
var eventemitter3 = { exports: {} };
(function(module2) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__) prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names2 = [], events2, name2;
    if (this._eventsCount === 0) return names2;
    for (name2 in events2 = this._events) {
      if (has2.call(events2, name2)) names2.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events2));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2) return 0;
    if (listeners2.fn) return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners2 = this._events[evt], len2 = arguments.length, args, i;
    if (listeners2.fn) {
      if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
      switch (len2) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len2 - 1); i < len2; i++) {
        args[i - 1] = arguments[i];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length2 = listeners2.length, j;
      for (i = 0; i < length2; i++) {
        if (listeners2[i].once) this.removeListener(event, listeners2[i].fn, void 0, true);
        switch (len2) {
          case 1:
            listeners2[i].fn.call(listeners2[i].context);
            break;
          case 2:
            listeners2[i].fn.call(listeners2[i].context, a1);
            break;
          case 3:
            listeners2[i].fn.call(listeners2[i].context, a1, a2);
            break;
          case 4:
            listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len2 - 1); j < len2; j++) {
              args[j - 1] = arguments[j];
            }
            listeners2[i].fn.apply(listeners2[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events2 = [], length2 = listeners2.length; i < length2; i++) {
        if (listeners2[i].fn !== fn || once && !listeners2[i].once || context && listeners2[i].context !== context) {
          events2.push(listeners2[i]);
        }
      }
      if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
class TimeoutError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
}
let AbortError$4 = class AbortError2 extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
};
const getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError$4(errorMessage) : new DOMException(errorMessage);
const getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options2) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout }
  } = options2;
  let timer;
  const wrappedPromise = new Promise((resolve2, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options2.signal) {
      const { signal } = options2;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve2, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve2(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve2();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve2(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}
function lowerBound(array, value, comparator) {
  let first2 = 0;
  let count2 = array.length;
  while (count2 > 0) {
    const step = Math.trunc(count2 / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count2 -= step + 1;
    } else {
      count2 = step;
    }
  }
  return first2;
}
class PriorityQueue {
  constructor() {
    __privateAdd(this, _queue3, []);
  }
  enqueue(run, options2) {
    options2 = {
      priority: 0,
      ...options2
    };
    const element = {
      priority: options2.priority,
      run
    };
    if (this.size && __privateGet(this, _queue3)[this.size - 1].priority >= options2.priority) {
      __privateGet(this, _queue3).push(element);
      return;
    }
    const index2 = lowerBound(__privateGet(this, _queue3), element, (a, b) => b.priority - a.priority);
    __privateGet(this, _queue3).splice(index2, 0, element);
  }
  dequeue() {
    const item = __privateGet(this, _queue3).shift();
    return item == null ? void 0 : item.run;
  }
  filter(options2) {
    return __privateGet(this, _queue3).filter((element) => element.priority === options2.priority).map((element) => element.run);
  }
  get size() {
    return __privateGet(this, _queue3).length;
  }
}
_queue3 = new WeakMap();
class PQueue extends EventEmitter {
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options2) {
    var _a3, _b2;
    super();
    __privateAdd(this, _PQueue_instances);
    __privateAdd(this, _carryoverConcurrencyCount);
    __privateAdd(this, _isIntervalIgnored);
    __privateAdd(this, _intervalCount, 0);
    __privateAdd(this, _intervalCap);
    __privateAdd(this, _interval);
    __privateAdd(this, _intervalEnd, 0);
    __privateAdd(this, _intervalId);
    __privateAdd(this, _timeoutId);
    __privateAdd(this, _queue4);
    __privateAdd(this, _queueClass);
    __privateAdd(this, _pending, 0);
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    __privateAdd(this, _concurrency);
    __privateAdd(this, _isPaused);
    __privateAdd(this, _throwOnTimeout);
    /**
        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
    
        Applies to each future operation.
        */
    __publicField(this, "timeout");
    options2 = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options2
    };
    if (!(typeof options2.intervalCap === "number" && options2.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((_a3 = options2.intervalCap) == null ? void 0 : _a3.toString()) ?? ""}\` (${typeof options2.intervalCap})`);
    }
    if (options2.interval === void 0 || !(Number.isFinite(options2.interval) && options2.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((_b2 = options2.interval) == null ? void 0 : _b2.toString()) ?? ""}\` (${typeof options2.interval})`);
    }
    __privateSet(this, _carryoverConcurrencyCount, options2.carryoverConcurrencyCount);
    __privateSet(this, _isIntervalIgnored, options2.intervalCap === Number.POSITIVE_INFINITY || options2.interval === 0);
    __privateSet(this, _intervalCap, options2.intervalCap);
    __privateSet(this, _interval, options2.interval);
    __privateSet(this, _queue4, new options2.queueClass());
    __privateSet(this, _queueClass, options2.queueClass);
    this.concurrency = options2.concurrency;
    this.timeout = options2.timeout;
    __privateSet(this, _throwOnTimeout, options2.throwOnTimeout === true);
    __privateSet(this, _isPaused, options2.autoStart === false);
  }
  get concurrency() {
    return __privateGet(this, _concurrency);
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __privateSet(this, _concurrency, newConcurrency);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
  }
  async add(function_, options2 = {}) {
    options2 = {
      timeout: this.timeout,
      throwOnTimeout: __privateGet(this, _throwOnTimeout),
      ...options2
    };
    return new Promise((resolve2, reject) => {
      __privateGet(this, _queue4).enqueue(async () => {
        var _a3;
        __privateWrapper(this, _pending)._++;
        __privateWrapper(this, _intervalCount)._++;
        try {
          (_a3 = options2.signal) == null ? void 0 : _a3.throwIfAborted();
          let operation = function_({ signal: options2.signal });
          if (options2.timeout) {
            operation = pTimeout(Promise.resolve(operation), { milliseconds: options2.timeout });
          }
          if (options2.signal) {
            operation = Promise.race([operation, __privateMethod(this, _PQueue_instances, throwOnAbort_fn).call(this, options2.signal)]);
          }
          const result = await operation;
          resolve2(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError && !options2.throwOnTimeout) {
            resolve2();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          __privateMethod(this, _PQueue_instances, next_fn).call(this);
        }
      }, options2);
      this.emit("add");
      __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
    });
  }
  async addAll(functions, options2) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options2)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!__privateGet(this, _isPaused)) {
      return this;
    }
    __privateSet(this, _isPaused, false);
    __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    __privateSet(this, _isPaused, true);
  }
  /**
  Clear the queue.
  */
  clear() {
    __privateSet(this, _queue4, new (__privateGet(this, _queueClass))());
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (__privateGet(this, _queue4).size === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (__privateGet(this, _queue4).size < limit) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "next", () => __privateGet(this, _queue4).size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (__privateGet(this, _pending) === 0 && __privateGet(this, _queue4).size === 0) {
      return;
    }
    await __privateMethod(this, _PQueue_instances, onEvent_fn).call(this, "idle");
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return __privateGet(this, _queue4).size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options2) {
    return __privateGet(this, _queue4).filter(options2).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return __privateGet(this, _pending);
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return __privateGet(this, _isPaused);
  }
}
_carryoverConcurrencyCount = new WeakMap();
_isIntervalIgnored = new WeakMap();
_intervalCount = new WeakMap();
_intervalCap = new WeakMap();
_interval = new WeakMap();
_intervalEnd = new WeakMap();
_intervalId = new WeakMap();
_timeoutId = new WeakMap();
_queue4 = new WeakMap();
_queueClass = new WeakMap();
_pending = new WeakMap();
_concurrency = new WeakMap();
_isPaused = new WeakMap();
_throwOnTimeout = new WeakMap();
_PQueue_instances = new WeakSet();
doesIntervalAllowAnother_get = function() {
  return __privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalCount) < __privateGet(this, _intervalCap);
};
doesConcurrentAllowAnother_get = function() {
  return __privateGet(this, _pending) < __privateGet(this, _concurrency);
};
next_fn = function() {
  __privateWrapper(this, _pending)._--;
  __privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this);
  this.emit("next");
};
onResumeInterval_fn = function() {
  __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
  __privateSet(this, _timeoutId, void 0);
};
isIntervalPaused_get = function() {
  const now = Date.now();
  if (__privateGet(this, _intervalId) === void 0) {
    const delay = __privateGet(this, _intervalEnd) - now;
    if (delay < 0) {
      __privateSet(this, _intervalCount, __privateGet(this, _carryoverConcurrencyCount) ? __privateGet(this, _pending) : 0);
    } else {
      if (__privateGet(this, _timeoutId) === void 0) {
        __privateSet(this, _timeoutId, setTimeout(() => {
          __privateMethod(this, _PQueue_instances, onResumeInterval_fn).call(this);
        }, delay));
      }
      return true;
    }
  }
  return false;
};
tryToStartAnother_fn = function() {
  if (__privateGet(this, _queue4).size === 0) {
    if (__privateGet(this, _intervalId)) {
      clearInterval(__privateGet(this, _intervalId));
    }
    __privateSet(this, _intervalId, void 0);
    this.emit("empty");
    if (__privateGet(this, _pending) === 0) {
      this.emit("idle");
    }
    return false;
  }
  if (!__privateGet(this, _isPaused)) {
    const canInitializeInterval = !__privateGet(this, _PQueue_instances, isIntervalPaused_get);
    if (__privateGet(this, _PQueue_instances, doesIntervalAllowAnother_get) && __privateGet(this, _PQueue_instances, doesConcurrentAllowAnother_get)) {
      const job = __privateGet(this, _queue4).dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __privateMethod(this, _PQueue_instances, initializeIntervalIfNeeded_fn).call(this);
      }
      return true;
    }
  }
  return false;
};
initializeIntervalIfNeeded_fn = function() {
  if (__privateGet(this, _isIntervalIgnored) || __privateGet(this, _intervalId) !== void 0) {
    return;
  }
  __privateSet(this, _intervalId, setInterval(() => {
    __privateMethod(this, _PQueue_instances, onInterval_fn).call(this);
  }, __privateGet(this, _interval)));
  __privateSet(this, _intervalEnd, Date.now() + __privateGet(this, _interval));
};
onInterval_fn = function() {
  if (__privateGet(this, _intervalCount) === 0 && __privateGet(this, _pending) === 0 && __privateGet(this, _intervalId)) {
    clearInterval(__privateGet(this, _intervalId));
    __privateSet(this, _intervalId, void 0);
  }
  __privateSet(this, _intervalCount, __privateGet(this, _carryoverConcurrencyCount) ? __privateGet(this, _pending) : 0);
  __privateMethod(this, _PQueue_instances, processQueue_fn).call(this);
};
/**
Executes all queued functions until it reaches the limit.
*/
processQueue_fn = function() {
  while (__privateMethod(this, _PQueue_instances, tryToStartAnother_fn).call(this)) {
  }
};
throwOnAbort_fn = async function(signal) {
  return new Promise((_resolve, reject) => {
    signal.addEventListener("abort", () => {
      reject(signal.reason);
    }, { once: true });
  });
};
onEvent_fn = async function(event, filter2) {
  return new Promise((resolve2) => {
    const listener = () => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve2();
    };
    this.on(event, listener);
  });
};
async function walkDAG(blockstore, node, queue, streamPosition, start2, end, options2) {
  if (node instanceof Uint8Array) {
    const buf2 = extractDataFromBlock(node, streamPosition, start2, end);
    queue.push(buf2);
    return;
  }
  if (node.Data == null) {
    throw errCode$1(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  let file;
  try {
    file = UnixFS$1.unmarshal(node.Data);
  } catch (err) {
    throw errCode$1(err, "ERR_NOT_UNIXFS");
  }
  if (file.data != null) {
    const data = file.data;
    const buf2 = extractDataFromBlock(data, streamPosition, start2, end);
    queue.push(buf2);
    streamPosition += BigInt(buf2.byteLength);
  }
  const childOps = [];
  if (node.Links.length !== file.blockSizes.length) {
    throw errCode$1(new Error("Inconsistent block sizes and dag links"), "ERR_NOT_UNIXFS");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const childLink = node.Links[i];
    const childStart = streamPosition;
    const childEnd = childStart + file.blockSizes[i];
    if (start2 >= childStart && start2 < childEnd || // child has offset byte
    end >= childStart && end <= childEnd || // child has end byte
    start2 < childStart && end > childEnd) {
      childOps.push({
        link: childLink,
        blockStart: streamPosition
      });
    }
    streamPosition = childEnd;
    if (streamPosition > end) {
      break;
    }
  }
  await pipe(childOps, (source) => map(source, (op) => {
    return async () => {
      const block = await blockstore.get(op.link.Hash, options2);
      return {
        ...op,
        block
      };
    };
  }), (source) => parallel(source, {
    ordered: true,
    concurrency: options2.blockReadConcurrency
  }), async (source) => {
    for await (const { link, block, blockStart } of source) {
      let child;
      switch (link.Hash.code) {
        case code$5:
          child = decode$a(block);
          break;
        case code$3:
          child = block;
          break;
        default:
          queue.end(errCode$1(new Error(`Unsupported codec: ${link.Hash.code}`), "ERR_NOT_UNIXFS"));
          return;
      }
      const childQueue = new PQueue({
        concurrency: 1
      });
      childQueue.on("error", (error) => {
        queue.end(error);
      });
      void childQueue.add(async () => {
        var _a3;
        (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("unixfs:exporter:walk:file", {
          cid: link.Hash
        }));
        await walkDAG(blockstore, child, queue, blockStart, start2, end, options2);
      });
      await childQueue.onIdle();
    }
  });
  if (streamPosition >= end) {
    queue.end();
  }
}
const fileContent = (cid, node, unixfs2, path, resolve2, depth, blockstore) => {
  async function* yieldFileContent(options2 = {}) {
    var _a3, _b2;
    const fileSize = unixfs2.fileSize();
    if (fileSize === void 0) {
      throw new Error("File was a directory");
    }
    const { start: start2, end } = validateOffsetAndLength(fileSize, options2.offset, options2.length);
    if (end === 0n) {
      return;
    }
    let read2 = 0n;
    const wanted = end - start2;
    const queue = pushable();
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("unixfs:exporter:walk:file", {
      cid
    }));
    void walkDAG(blockstore, node, queue, 0n, start2, end, options2).catch((err) => {
      queue.end(err);
    });
    for await (const buf2 of queue) {
      if (buf2 == null) {
        continue;
      }
      read2 += BigInt(buf2.byteLength);
      if (read2 > wanted) {
        queue.end();
        throw errCode$1(new Error("Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect"), "ERR_OVER_READ");
      }
      if (read2 === wanted) {
        queue.end();
      }
      (_b2 = options2.onProgress) == null ? void 0 : _b2.call(options2, new CustomProgressEvent("unixfs:exporter:progress:unixfs:file", {
        bytesRead: read2,
        totalBytes: wanted,
        fileSize
      }));
      yield buf2;
    }
    if (read2 < wanted) {
      throw errCode$1(new Error("Traversed entire DAG but did not read enough bytes"), "ERR_UNDER_READ");
    }
  }
  return yieldFileContent;
};
const hamtShardedDirectoryContent = (cid, node, unixfs2, path, resolve2, depth, blockstore) => {
  function yieldHamtDirectoryContent(options2 = {}) {
    var _a3;
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("unixfs:exporter:walk:hamt-sharded-directory", {
      cid
    }));
    return listDirectory(node, path, resolve2, depth, blockstore, options2);
  }
  return yieldHamtDirectoryContent;
};
async function* listDirectory(node, path, resolve2, depth, blockstore, options2) {
  const links2 = node.Links;
  if (node.Data == null) {
    throw errCode$1(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  let dir;
  try {
    dir = UnixFS$1.unmarshal(node.Data);
  } catch (err) {
    throw errCode$1(err, "ERR_NOT_UNIXFS");
  }
  if (dir.fanout == null) {
    throw errCode$1(new Error("missing fanout"), "ERR_NOT_UNIXFS");
  }
  const padLength = (dir.fanout - 1n).toString(16).length;
  const results = pipe(links2, (source) => map(source, (link) => {
    return async () => {
      var _a3;
      const name2 = link.Name != null ? link.Name.substring(padLength) : null;
      if (name2 != null && name2 !== "") {
        const result = await resolve2(link.Hash, name2, `${path}/${name2}`, [], depth + 1, blockstore, options2);
        return { entries: result.entry == null ? [] : [result.entry] };
      } else {
        const block = await blockstore.get(link.Hash, options2);
        node = decode$a(block);
        (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("unixfs:exporter:walk:hamt-sharded-directory", {
          cid: link.Hash
        }));
        return { entries: listDirectory(node, path, resolve2, depth, blockstore, options2) };
      }
    };
  }), (source) => parallel(source, {
    ordered: true,
    concurrency: options2.blockReadConcurrency
  }));
  for await (const { entries } of results) {
    yield* entries;
  }
}
const findLinkCid = (node, name2) => {
  const link = node.Links.find((link2) => link2.Name === name2);
  return link == null ? void 0 : link.Hash;
};
const contentExporters = {
  raw: fileContent,
  file: fileContent,
  directory: directoryContent,
  "hamt-sharded-directory": hamtShardedDirectoryContent,
  metadata: (cid, node, unixfs2, path, resolve2, depth, blockstore) => {
    return () => [];
  },
  symlink: (cid, node, unixfs2, path, resolve2, depth, blockstore) => {
    return () => [];
  }
};
const unixFsResolver = async (cid, name2, path, toResolve, resolve2, depth, blockstore, options2) => {
  const block = await blockstore.get(cid, options2);
  const node = decode$a(block);
  let unixfs2;
  let next;
  if (name2 == null) {
    name2 = cid.toString();
  }
  if (node.Data == null) {
    throw errCode$1(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  try {
    unixfs2 = UnixFS$1.unmarshal(node.Data);
  } catch (err) {
    throw errCode$1(err, "ERR_NOT_UNIXFS");
  }
  if (path == null) {
    path = name2;
  }
  if (toResolve.length > 0) {
    let linkCid;
    if ((unixfs2 == null ? void 0 : unixfs2.type) === "hamt-sharded-directory") {
      linkCid = await findShardCid(node, toResolve[0], blockstore);
    } else {
      linkCid = findLinkCid(node, toResolve[0]);
    }
    if (linkCid == null) {
      throw errCode$1(new Error("file does not exist"), "ERR_NOT_FOUND");
    }
    const nextName = toResolve.shift();
    const nextPath = `${path}/${nextName}`;
    next = {
      cid: linkCid,
      toResolve,
      name: nextName ?? "",
      path: nextPath
    };
  }
  const content = contentExporters[unixfs2.type](cid, node, unixfs2, path, resolve2, depth, blockstore);
  if (content == null) {
    throw errCode$1(new Error("could not find content exporter"), "ERR_NOT_FOUND");
  }
  if (unixfs2.isDirectory()) {
    return {
      entry: {
        type: "directory",
        name: name2,
        path,
        cid,
        content,
        unixfs: unixfs2,
        depth,
        node,
        size: unixfs2.fileSize()
      },
      next
    };
  }
  return {
    entry: {
      type: "file",
      name: name2,
      path,
      cid,
      content,
      unixfs: unixfs2,
      depth,
      node,
      size: unixfs2.fileSize()
    },
    next
  };
};
const resolvers$1 = {
  [code$5]: unixFsResolver,
  [code$3]: resolve$2,
  [code$1]: resolve$6,
  [code]: resolve$5,
  [identity.code]: resolve$4,
  [code$4]: resolve$3
};
const resolve$1 = async (cid, name2, path, toResolve, depth, blockstore, options2) => {
  const resolver = resolvers$1[cid.code];
  if (resolver == null) {
    throw errCode$1(new Error(`No resolver for code ${cid.code}`), "ERR_NO_RESOLVER");
  }
  return resolver(cid, name2, path, toResolve, resolve$1, depth, blockstore, options2);
};
const toPathComponents = (path = "") => {
  return (path.trim().match(/([^\\^/]|\\\/)+/g) ?? []).filter(Boolean);
};
const cidAndRest = (path) => {
  if (path instanceof Uint8Array) {
    return {
      cid: CID.decode(path),
      toResolve: []
    };
  }
  const cid = CID.asCID(path);
  if (cid != null) {
    return {
      cid,
      toResolve: []
    };
  }
  if (typeof path === "string") {
    if (path.indexOf("/ipfs/") === 0) {
      path = path.substring(6);
    }
    const output2 = toPathComponents(path);
    return {
      cid: CID.parse(output2[0]),
      toResolve: output2.slice(1)
    };
  }
  throw errCode$1(new Error(`Unknown path type ${path}`), "ERR_BAD_PATH");
};
async function* walkPath(path, blockstore, options2 = {}) {
  let { cid, toResolve } = cidAndRest(path);
  let name2 = cid.toString();
  let entryPath = name2;
  const startingDepth = toResolve.length;
  while (true) {
    const result = await resolve$1(cid, name2, entryPath, toResolve, startingDepth, blockstore, options2);
    if (result.entry == null && result.next == null) {
      throw errCode$1(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
    }
    if (result.entry != null) {
      yield result.entry;
    }
    if (result.next == null) {
      return;
    }
    toResolve = result.next.toResolve;
    cid = result.next.cid;
    name2 = result.next.name;
    entryPath = result.next.path;
  }
}
async function exporter$1(path, blockstore, options2 = {}) {
  const result = await last(walkPath(path, blockstore, options2));
  if (result == null) {
    throw errCode$1(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
  }
  return result;
}
async function* recursive(path, blockstore, options2 = {}) {
  const node = await exporter$1(path, blockstore, options2);
  if (node == null) {
    return;
  }
  yield node;
  if (node.type === "directory") {
    for await (const child of recurse(node, options2)) {
      yield child;
    }
  }
  async function* recurse(node2, options3) {
    for await (const file of node2.content(options3)) {
      yield file;
      if (file instanceof Uint8Array) {
        continue;
      }
      if (file.type === "directory") {
        yield* recurse(file, options3);
      }
    }
  }
}
var isPlainObj = (value) => {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
};
const isOptionObject = isPlainObj;
const { hasOwnProperty } = Object.prototype;
const { propertyIsEnumerable } = Object;
const defineProperty = (object, name2, value) => Object.defineProperty(object, name2, {
  value,
  writable: true,
  enumerable: true,
  configurable: true
});
const globalThis$1 = commonjsGlobal;
const defaultMergeOptions = {
  concatArrays: false,
  ignoreUndefined: false
};
const getEnumerableOwnPropertyKeys = (value) => {
  const keys = [];
  for (const key in value) {
    if (hasOwnProperty.call(value, key)) {
      keys.push(key);
    }
  }
  if (Object.getOwnPropertySymbols) {
    const symbols = Object.getOwnPropertySymbols(value);
    for (const symbol2 of symbols) {
      if (propertyIsEnumerable.call(value, symbol2)) {
        keys.push(symbol2);
      }
    }
  }
  return keys;
};
function clone(value) {
  if (Array.isArray(value)) {
    return cloneArray(value);
  }
  if (isOptionObject(value)) {
    return cloneOptionObject(value);
  }
  return value;
}
function cloneArray(array) {
  const result = array.slice(0, 0);
  getEnumerableOwnPropertyKeys(array).forEach((key) => {
    defineProperty(result, key, clone(array[key]));
  });
  return result;
}
function cloneOptionObject(object) {
  const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
  getEnumerableOwnPropertyKeys(object).forEach((key) => {
    defineProperty(result, key, clone(object[key]));
  });
  return result;
}
const mergeKeys = (merged, source, keys, config2) => {
  keys.forEach((key) => {
    if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
      return;
    }
    if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
      defineProperty(merged, key, merge(merged[key], source[key], config2));
    } else {
      defineProperty(merged, key, clone(source[key]));
    }
  });
  return merged;
};
const concatArrays = (merged, source, config2) => {
  let result = merged.slice(0, 0);
  let resultIndex = 0;
  [merged, source].forEach((array) => {
    const indices = [];
    for (let k = 0; k < array.length; k++) {
      if (!hasOwnProperty.call(array, k)) {
        continue;
      }
      indices.push(String(k));
      if (array === merged) {
        defineProperty(result, resultIndex++, array[k]);
      } else {
        defineProperty(result, resultIndex++, clone(array[k]));
      }
    }
    result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config2);
  });
  return result;
};
function merge(merged, source, config2) {
  if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
    return concatArrays(merged, source, config2);
  }
  if (!isOptionObject(source) || !isOptionObject(merged)) {
    return clone(source);
  }
  return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
}
var mergeOptions$8 = function(...options2) {
  const config2 = merge(clone(defaultMergeOptions), this !== globalThis$1 && this || {}, defaultMergeOptions);
  let merged = { _: {} };
  for (const option of options2) {
    if (option === void 0) {
      continue;
    }
    if (!isOptionObject(option)) {
      throw new TypeError("`" + option + "` is not an Option Object");
    }
    merged = merge(merged, { _: option }, config2);
  }
  return merged._;
};
const mergeOptions$9 = /* @__PURE__ */ getDefaultExportFromCjs(mergeOptions$8);
class UnixFSError extends Error {
  constructor(message2, name2, code2) {
    super(message2);
    __publicField(this, "name");
    __publicField(this, "code");
    this.name = name2;
    this.code = code2;
  }
}
class NotUnixFSError extends UnixFSError {
  constructor(message2 = "not a Unixfs node") {
    super(message2, "NotUnixFSError", "ERR_NOT_UNIXFS");
  }
}
class InvalidPBNodeError extends UnixFSError {
  constructor(message2 = "invalid PBNode") {
    super(message2, "InvalidPBNodeError", "ERR_INVALID_PBNODE");
  }
}
class UnknownError extends UnixFSError {
  constructor(message2 = "unknown error") {
    super(message2, "InvalidPBNodeError", "ERR_UNKNOWN_ERROR");
  }
}
class AlreadyExistsError extends UnixFSError {
  constructor(message2 = "path already exists") {
    super(message2, "AlreadyExistsError", "ERR_ALREADY_EXISTS");
  }
}
class DoesNotExistError extends UnixFSError {
  constructor(message2 = "path does not exist") {
    super(message2, "DoesNotExistError", "ERR_DOES_NOT_EXIST");
  }
}
class NoContentError extends UnixFSError {
  constructor(message2 = "no content") {
    super(message2, "NoContentError", "ERR_NO_CONTENT");
  }
}
class NotAFileError extends UnixFSError {
  constructor(message2 = "not a file") {
    super(message2, "NotAFileError", "ERR_NOT_A_FILE");
  }
}
class NotADirectoryError extends UnixFSError {
  constructor(message2 = "not a directory") {
    super(message2, "NotADirectoryError", "ERR_NOT_A_DIRECTORY");
  }
}
class InvalidParametersError extends UnixFSError {
  constructor(message2 = "invalid parameters") {
    super(message2, "InvalidParametersError", "ERR_INVALID_PARAMETERS");
  }
}
const s = 1e3;
const m = s * 60;
const h$1 = m * 60;
const d = h$1 * 24;
const w = d * 7;
const y = d * 365.25;
function ms(value, options2) {
  try {
    if (typeof value === "string" && value.length > 0) {
      return parse$1(value);
    } else if (typeof value === "number" && isFinite(value)) {
      return (options2 == null ? void 0 : options2.long) ? fmtLong(value) : fmtShort(value);
    }
    throw new Error("Value is not a string or number.");
  } catch (error) {
    const message2 = isError$1(error) ? `${error.message}. value=${JSON.stringify(value)}` : "An unknown error has occured.";
    throw new Error(message2);
  }
}
function parse$1(str) {
  str = String(str);
  if (str.length > 100) {
    throw new Error("Value exceeds the maximum length of 100 characters.");
  }
  const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return NaN;
  }
  const n = parseFloat(match[1]);
  const type = (match[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h$1;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      throw new Error(`The unit ${type} was matched, but no matching case exists.`);
  }
}
function fmtShort(ms2) {
  const msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return `${Math.round(ms2 / d)}d`;
  }
  if (msAbs >= h$1) {
    return `${Math.round(ms2 / h$1)}h`;
  }
  if (msAbs >= m) {
    return `${Math.round(ms2 / m)}m`;
  }
  if (msAbs >= s) {
    return `${Math.round(ms2 / s)}s`;
  }
  return `${ms2}ms`;
}
function fmtLong(ms2) {
  const msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h$1) {
    return plural(ms2, msAbs, h$1, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return `${ms2} ms`;
}
function plural(ms2, msAbs, n, name2) {
  const isPlural = msAbs >= n * 1.5;
  return `${Math.round(ms2 / n)} ${name2}${isPlural ? "s" : ""}`;
}
function isError$1(error) {
  return typeof error === "object" && error !== null && "message" in error;
}
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = ms;
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash2 = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
      hash2 |= 0;
    }
    return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug(...args) {
      if (!debug.enabled) {
        return;
      }
      const self2 = debug;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index2 = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
        if (match === "%%") {
          return "%";
        }
        index2++;
        const formatter = createDebug.formatters[format];
        if (typeof formatter === "function") {
          const val = args[index2];
          match = formatter.call(self2, val);
          args.splice(index2, 1);
          index2--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy;
    Object.defineProperty(debug, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len2 = split2.length;
    for (i = 0; i < len2; i++) {
      if (!split2[i]) {
        continue;
      }
      namespaces = split2[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name2) {
    if (name2[name2.length - 1] === "*") {
      return true;
    }
    let i;
    let len2;
    for (i = 0, len2 = createDebug.skips.length; i < len2; i++) {
      if (createDebug.skips[i].test(name2)) {
        return false;
      }
    }
    for (i = 0, len2 = createDebug.names.length; i < len2; i++) {
      if (createDebug.names[i].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack ?? val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.setupFormatters(createDebug.formatters);
  createDebug.enable(createDebug.load());
  return createDebug;
}
var define_process_env_default = {};
const storage = localstorage();
const colors = [
  "#0000CC",
  "#0000FF",
  "#0033CC",
  "#0033FF",
  "#0066CC",
  "#0066FF",
  "#0099CC",
  "#0099FF",
  "#00CC00",
  "#00CC33",
  "#00CC66",
  "#00CC99",
  "#00CCCC",
  "#00CCFF",
  "#3300CC",
  "#3300FF",
  "#3333CC",
  "#3333FF",
  "#3366CC",
  "#3366FF",
  "#3399CC",
  "#3399FF",
  "#33CC00",
  "#33CC33",
  "#33CC66",
  "#33CC99",
  "#33CCCC",
  "#33CCFF",
  "#6600CC",
  "#6600FF",
  "#6633CC",
  "#6633FF",
  "#66CC00",
  "#66CC33",
  "#9900CC",
  "#9900FF",
  "#9933CC",
  "#9933FF",
  "#99CC00",
  "#99CC33",
  "#CC0000",
  "#CC0033",
  "#CC0066",
  "#CC0099",
  "#CC00CC",
  "#CC00FF",
  "#CC3300",
  "#CC3333",
  "#CC3366",
  "#CC3399",
  "#CC33CC",
  "#CC33FF",
  "#CC6600",
  "#CC6633",
  "#CC9900",
  "#CC9933",
  "#CCCC00",
  "#CCCC33",
  "#FF0000",
  "#FF0033",
  "#FF0066",
  "#FF0099",
  "#FF00CC",
  "#FF00FF",
  "#FF3300",
  "#FF3333",
  "#FF3366",
  "#FF3399",
  "#FF33CC",
  "#FF33FF",
  "#FF6600",
  "#FF6633",
  "#FF9900",
  "#FF9933",
  "#FFCC00",
  "#FFCC33"
];
function useColors() {
  var _a3, _b2, _c2, _d2, _e2;
  if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
    return true;
  }
  if (typeof navigator !== "undefined" && ((_a3 = navigator.userAgent) == null ? void 0 : _a3.toLowerCase().match(/(edge|trident)\/(\d+)/)) != null) {
    return false;
  }
  return typeof document !== "undefined" && ((_c2 = (_b2 = document.documentElement) == null ? void 0 : _b2.style) == null ? void 0 : _c2.WebkitAppearance) || // Is firebug? http://stackoverflow.com/a/398120/376773
  // @ts-expect-error window.console.firebug and window.console.exception are not in the types
  typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== "undefined" && ((_d2 = navigator.userAgent) == null ? void 0 : _d2.toLowerCase().match(/firefox\/(\d+)/)) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== "undefined" && ((_e2 = navigator.userAgent) == null ? void 0 : _e2.toLowerCase().match(/applewebkit\/(\d+)/));
}
function formatArgs(args) {
  args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + ms(this.diff);
  if (!this.useColors) {
    return;
  }
  const c = "color: " + this.color;
  args.splice(1, 0, c, "color: inherit");
  let index2 = 0;
  let lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, (match) => {
    if (match === "%%") {
      return;
    }
    index2++;
    if (match === "%c") {
      lastC = index2;
    }
  });
  args.splice(lastC, 0, c);
}
const log$e = console.debug ?? console.log ?? (() => {
});
function save(namespaces) {
  try {
    if (namespaces) {
      storage == null ? void 0 : storage.setItem("debug", namespaces);
    } else {
      storage == null ? void 0 : storage.removeItem("debug");
    }
  } catch (error) {
  }
}
function load() {
  let r;
  try {
    r = storage == null ? void 0 : storage.getItem("debug");
  } catch (error) {
  }
  if (!r && typeof process$1 !== "undefined" && "env" in process$1) {
    r = define_process_env_default.DEBUG;
  }
  return r;
}
function localstorage() {
  try {
    return localStorage;
  } catch (error) {
  }
}
function setupFormatters(formatters) {
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
}
const weald = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log: log$e });
weald.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
weald.formatters.t = (v) => {
  return v == null ? "undefined" : base32$1.baseEncode(v);
};
weald.formatters.m = (v) => {
  return v == null ? "undefined" : base64.baseEncode(v);
};
weald.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
weald.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
weald.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
weald.formatters.a = (v) => {
  return v == null ? "undefined" : v.toString();
};
function createDisabledLogger(namespace) {
  const logger2 = () => {
  };
  logger2.enabled = false;
  logger2.color = "";
  logger2.diff = 0;
  logger2.log = () => {
  };
  logger2.namespace = namespace;
  logger2.destroy = () => true;
  logger2.extend = () => logger2;
  return logger2;
}
function defaultLogger() {
  return {
    forComponent(name2) {
      return logger(name2);
    }
  };
}
function logger(name2) {
  let trace = createDisabledLogger(`${name2}:trace`);
  if (weald.enabled(`${name2}:trace`) && weald.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
    trace = weald(`${name2}:trace`);
  }
  return Object.assign(weald(name2), {
    error: weald(`${name2}:error`),
    trace
  });
}
function wrapHash(hashFn2) {
  function hashing(value) {
    if (value instanceof InfiniteHash2) {
      return value;
    } else {
      return new InfiniteHash2(value, hashFn2);
    }
  }
  return hashing;
}
class InfiniteHash2 {
  constructor(value, hashFn2) {
    __publicField(this, "_value");
    __publicField(this, "_hashFn");
    __publicField(this, "_depth");
    __publicField(this, "_availableBits");
    __publicField(this, "_currentBufferIndex");
    __publicField(this, "_buffers");
    if (!(value instanceof Uint8Array)) {
      throw new Error("can only hash Uint8Arrays");
    }
    this._value = value;
    this._hashFn = hashFn2;
    this._depth = -1;
    this._availableBits = 0;
    this._currentBufferIndex = 0;
    this._buffers = [];
  }
  async take(bits) {
    let pendingBits = bits;
    while (this._availableBits < pendingBits) {
      await this._produceMoreBits();
    }
    let result = 0;
    while (pendingBits > 0) {
      const hash2 = this._buffers[this._currentBufferIndex];
      const available = Math.min(hash2.availableBits(), pendingBits);
      const took = hash2.take(available);
      result = (result << available) + took;
      pendingBits -= available;
      this._availableBits -= available;
      if (hash2.availableBits() === 0) {
        this._currentBufferIndex++;
      }
    }
    return result;
  }
  untake(bits) {
    let pendingBits = bits;
    while (pendingBits > 0) {
      const hash2 = this._buffers[this._currentBufferIndex];
      const availableForUntake = Math.min(hash2.totalBits() - hash2.availableBits(), pendingBits);
      hash2.untake(availableForUntake);
      pendingBits -= availableForUntake;
      this._availableBits += availableForUntake;
      if (this._currentBufferIndex > 0 && hash2.totalBits() === hash2.availableBits()) {
        this._depth--;
        this._currentBufferIndex--;
      }
    }
  }
  async _produceMoreBits() {
    this._depth++;
    const value = this._depth > 0 ? concat$2([this._value, Uint8Array.from([this._depth])]) : this._value;
    const hashValue = await this._hashFn(value);
    const buffer2 = new ConsumableBuffer2(hashValue);
    this._buffers.push(buffer2);
    this._availableBits += buffer2.availableBits();
  }
}
const START_MASKS = [
  255,
  254,
  252,
  248,
  240,
  224,
  192,
  128
];
const STOP_MASKS = [
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255
];
class ConsumableBuffer2 {
  constructor(value) {
    __publicField(this, "_value");
    __publicField(this, "_currentBytePos");
    __publicField(this, "_currentBitPos");
    this._value = value;
    this._currentBytePos = value.length - 1;
    this._currentBitPos = 7;
  }
  availableBits() {
    return this._currentBitPos + 1 + this._currentBytePos * 8;
  }
  totalBits() {
    return this._value.length * 8;
  }
  take(bits) {
    let pendingBits = bits;
    let result = 0;
    while (pendingBits > 0 && this._haveBits()) {
      const byte = this._value[this._currentBytePos];
      const availableBits = this._currentBitPos + 1;
      const taking = Math.min(availableBits, pendingBits);
      const value = byteBitsToInt(byte, availableBits - taking, taking);
      result = (result << taking) + value;
      pendingBits -= taking;
      this._currentBitPos -= taking;
      if (this._currentBitPos < 0) {
        this._currentBitPos = 7;
        this._currentBytePos--;
      }
    }
    return result;
  }
  untake(bits) {
    this._currentBitPos += bits;
    while (this._currentBitPos > 7) {
      this._currentBitPos -= 8;
      this._currentBytePos += 1;
    }
  }
  _haveBits() {
    return this._currentBytePos >= 0;
  }
}
function byteBitsToInt(byte, start2, length2) {
  const mask = maskFor(start2, length2);
  return (byte & mask) >>> start2;
}
function maskFor(start2, length2) {
  return START_MASKS[start2] & STOP_MASKS[Math.min(length2 + start2 - 1, 7)];
}
const hamtHashCode = BigInt(murmur3128.code);
const hamtBucketBits = 8;
async function hamtHashFn(buf2) {
  return (await murmur3128.encode(buf2)).subarray(0, 8).reverse();
}
const persist = async (buffer2, blockstore, options2) => {
  if (options2.codec == null) {
    options2.codec = dagPB;
  }
  const multihash = await sha256$1.digest(buffer2);
  const cid = CID.create(options2.cidVersion, options2.codec.code, multihash);
  await blockstore.put(cid, buffer2, {
    ...options2,
    signal: options2.signal
  });
  return cid;
};
class Dir2 {
  constructor(props, options2) {
    __publicField(this, "options");
    __publicField(this, "root");
    __publicField(this, "dir");
    __publicField(this, "path");
    __publicField(this, "dirty");
    __publicField(this, "flat");
    __publicField(this, "parent");
    __publicField(this, "parentKey");
    __publicField(this, "unixfs");
    __publicField(this, "mode");
    __publicField(this, "mtime");
    __publicField(this, "cid");
    __publicField(this, "size");
    __publicField(this, "nodeSize");
    this.options = options2 ?? {};
    this.root = props.root;
    this.dir = props.dir;
    this.path = props.path;
    this.dirty = props.dirty;
    this.flat = props.flat;
    this.parent = props.parent;
    this.parentKey = props.parentKey;
    this.unixfs = props.unixfs;
    this.mode = props.mode;
    this.mtime = props.mtime;
  }
}
class DirSharded2 extends Dir2 {
  constructor(props, options2) {
    super(props, options2);
    __publicField(this, "_bucket");
    this._bucket = createHAMT({
      hashFn: hamtHashFn,
      bits: 8
    });
  }
  async put(name2, value) {
    this.cid = void 0;
    this.size = void 0;
    this.nodeSize = void 0;
    await this._bucket.put(name2, value);
  }
  async get(name2) {
    return this._bucket.get(name2);
  }
  childCount() {
    return this._bucket.leafCount();
  }
  directChildrenCount() {
    return this._bucket.childrenCount();
  }
  onlyChild() {
    return this._bucket.onlyChild();
  }
  async *eachChildSeries() {
    for await (const { key, value } of this._bucket.eachLeafSeries()) {
      yield {
        key,
        child: value
      };
    }
  }
  estimateNodeSize() {
    if (this.nodeSize !== void 0) {
      return this.nodeSize;
    }
    this.nodeSize = calculateSize(this._bucket, this, this.options);
    return this.nodeSize;
  }
  async *flush(blockstore) {
    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
      yield {
        ...entry,
        path: this.path
      };
    }
  }
}
async function* flush(bucket, blockstore, shardRoot, options2) {
  const children = bucket._children;
  const links2 = [];
  let childrenSize = 0n;
  for (let i = 0; i < children.length; i++) {
    const child = children.get(i);
    if (child == null) {
      continue;
    }
    const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      let shard;
      for await (const subShard of flush(child, blockstore, null, options2)) {
        shard = subShard;
      }
      if (shard == null) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links2.push({
        Name: labelPrefix,
        Tsize: Number(shard.size),
        Hash: shard.cid
      });
      childrenSize += shard.size;
    } else if (isDir(child.value)) {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      if (flushedDir == null) {
        throw new Error("Did not flush dir");
      }
      const label = labelPrefix + child.key;
      links2.push({
        Name: label,
        Tsize: Number(flushedDir.size),
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value = child.value;
      if (value.cid == null) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value.size;
      links2.push({
        Name: label,
        Tsize: Number(size2),
        Hash: value.cid
      });
      childrenSize += BigInt(size2 ?? 0);
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS$1({
    type: "hamt-sharded-directory",
    data,
    fanout: BigInt(bucket.tableSize()),
    hashType: hamtHashCode,
    mtime: shardRoot == null ? void 0 : shardRoot.mtime,
    mode: shardRoot == null ? void 0 : shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links2
  };
  const buffer2 = encode$7(prepare(node));
  const cid = await persist(buffer2, blockstore, options2);
  const size = BigInt(buffer2.byteLength) + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size
  };
}
function isDir(obj) {
  return typeof obj.flush === "function";
}
function calculateSize(bucket, shardRoot, options2) {
  const children = bucket._children;
  const links2 = [];
  for (let i = 0; i < children.length; i++) {
    const child = children.get(i);
    if (child == null) {
      continue;
    }
    const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof Bucket) {
      const size = calculateSize(child, null, options2);
      links2.push({
        Name: labelPrefix,
        Tsize: Number(size),
        Hash: options2.cidVersion === 0 ? CID_V0 : CID_V1
      });
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      const size = dir2.nodeSize();
      links2.push({
        Name: labelPrefix + child.key,
        Tsize: Number(size),
        Hash: options2.cidVersion === 0 ? CID_V0 : CID_V1
      });
    } else {
      const value = child.value;
      if (value.cid == null) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size = value.size;
      links2.push({
        Name: label,
        Tsize: Number(size),
        Hash: value.cid
      });
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS$1({
    type: "hamt-sharded-directory",
    data,
    fanout: BigInt(bucket.tableSize()),
    hashType: hamtHashCode,
    mtime: shardRoot == null ? void 0 : shardRoot.mtime,
    mode: shardRoot == null ? void 0 : shardRoot.mode
  });
  const buffer2 = encode$7(prepare({
    Data: dir.marshal(),
    Links: links2
  }));
  return buffer2.length;
}
const CID_V0 = CID.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn");
const CID_V1 = CID.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi");
const log$d = logger("helia:unixfs:commands:utils:hamt-utils");
const toPrefix = (position) => {
  return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
};
const createShard = async (blockstore, contents, options2) => {
  const shard = new DirSharded2({
    root: true,
    dir: true,
    parent: void 0,
    parentKey: void 0,
    path: "",
    dirty: true,
    flat: false,
    mtime: options2.mtime,
    mode: options2.mode
  }, options2);
  for (let i = 0; i < contents.length; i++) {
    await shard._bucket.put(contents[i].name, {
      size: contents[i].size,
      cid: contents[i].cid
    });
  }
  const res = await last(shard.flush(blockstore));
  if (res == null) {
    throw new Error("Flushing shard yielded no result");
  }
  return res;
};
const updateShardedDirectory = async (path, blockstore, options2) => {
  const shardRoot = UnixFS$1.unmarshal(path[0].node.Data ?? new Uint8Array(0));
  const fanout = BigInt(Math.pow(2, hamtBucketBits));
  path.reverse();
  let cid;
  let node;
  for (let i = 0; i < path.length; i++) {
    const isRoot = i === path.length - 1;
    const segment = path[i];
    const data = Uint8Array.from(segment.children.bitField().reverse());
    const dir = new UnixFS$1({
      type: "hamt-sharded-directory",
      data,
      fanout,
      hashType: hamtHashCode
    });
    if (isRoot) {
      dir.mtime = shardRoot.mtime;
      dir.mode = shardRoot.mode;
    }
    node = {
      Data: dir.marshal(),
      Links: segment.node.Links
    };
    const block = encode$7(prepare(node));
    cid = await persist(block, blockstore, options2);
    if (!isRoot) {
      const nextSegment = path[i + 1];
      if (nextSegment == null) {
        throw new Error("Was not operating on shard root but also had no parent?");
      }
      log$d("updating link in parent sub-shard with prefix %s", nextSegment.prefix);
      nextSegment.node.Links = nextSegment.node.Links.filter((l) => l.Name !== nextSegment.prefix);
      nextSegment.node.Links.push({
        Name: nextSegment.prefix,
        Hash: cid,
        Tsize: segment.node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), block.byteLength)
      });
    }
  }
  if (cid == null || node == null) {
    throw new Error("Noting persisted");
  }
  return { cid, node };
};
const recreateShardedDirectory = async (cid, fileName, blockstore, options2) => {
  const wrapped = wrapHash(hamtHashFn);
  const hash2 = wrapped(fromString$1(fileName));
  const path = [];
  while (true) {
    const block = await blockstore.get(cid, options2);
    const node = decode$a(block);
    const children = new SparseArray2();
    const index2 = await hash2.take(hamtBucketBits);
    const prefix = toPrefix(index2);
    path.push({
      prefix,
      children,
      node
    });
    let childLink;
    for (const link of node.Links) {
      const linkName2 = link.Name ?? "";
      if (linkName2.length < 2) {
        throw new Error("Invalid HAMT - link name was too short");
      }
      const position = parseInt(linkName2.substring(0, 2), 16);
      children.set(position, true);
      if (linkName2.startsWith(prefix)) {
        childLink = link;
      }
    }
    if (childLink == null) {
      log$d("no link found with prefix %s for %s", prefix, fileName);
      break;
    }
    const linkName = childLink.Name ?? "";
    if (linkName.length < 2) {
      throw new Error("Invalid HAMT - link name was too short");
    }
    if (linkName.length === 2) {
      cid = childLink.Hash;
      log$d("descend into sub-shard with prefix %s", linkName);
      continue;
    }
    break;
  }
  return { path, hash: hash2 };
};
async function isOverShardThreshold(node, blockstore, threshold, options2) {
  if (node.Data == null) {
    throw new Error("DagPB node had no data");
  }
  const unixfs2 = UnixFS$1.unmarshal(node.Data);
  let size;
  if (unixfs2.type === "directory") {
    size = estimateNodeSize(node);
  } else if (unixfs2.type === "hamt-sharded-directory") {
    size = await estimateShardSize(node, 0, threshold, blockstore, options2);
  } else {
    throw new Error("Can only estimate the size of directories or shards");
  }
  return size > threshold;
}
function estimateNodeSize(node) {
  let size = 0;
  for (const link of node.Links) {
    size += (link.Name ?? "").length;
    size += link.Hash.version === 1 ? CID_V1.bytes.byteLength : CID_V0.bytes.byteLength;
  }
  return size;
}
async function estimateShardSize(node, current, max, blockstore, options2) {
  if (current > max) {
    return max;
  }
  if (node.Data == null) {
    return current;
  }
  const unixfs2 = UnixFS$1.unmarshal(node.Data);
  if (!unixfs2.isDirectory()) {
    return current;
  }
  for (const link of node.Links) {
    let name2 = link.Name ?? "";
    name2 = name2.substring(2);
    current += name2.length;
    current += link.Hash.bytes.byteLength;
    if (link.Hash.code === code$5) {
      const block = await blockstore.get(link.Hash, options2);
      const node2 = decode$a(block);
      current += await estimateShardSize(node2, current, max, blockstore, options2);
    }
  }
  return current;
}
const log$c = logger("helia:unixfs:components:utils:add-link");
async function addLink(parent, child, blockstore, options2) {
  if (parent.node.Data == null) {
    throw new InvalidParametersError("Invalid parent passed to addLink");
  }
  const meta = UnixFS$1.unmarshal(parent.node.Data);
  if (meta.type === "hamt-sharded-directory") {
    log$c("adding link to sharded directory");
    return addToShardedDirectory(parent, child, blockstore, options2);
  }
  log$c(`adding ${child.Name} (${child.Hash}) to regular directory`);
  const result = await addToDirectory(parent, child, blockstore, options2);
  if (await isOverShardThreshold(result.node, blockstore, options2.shardSplitThresholdBytes, options2)) {
    log$c("converting directory to sharded directory");
    const converted = await convertToShardedDirectory(result, blockstore);
    result.cid = converted.cid;
    result.node = decode$a(await blockstore.get(converted.cid, options2));
  }
  return result;
}
const convertToShardedDirectory = async (parent, blockstore) => {
  if (parent.node.Data == null) {
    throw new InvalidParametersError("Invalid parent passed to convertToShardedDirectory");
  }
  const unixfs2 = UnixFS$1.unmarshal(parent.node.Data);
  const result = await createShard(blockstore, parent.node.Links.map((link) => ({
    name: link.Name ?? "",
    size: BigInt(link.Tsize ?? 0),
    cid: link.Hash
  })), {
    mode: unixfs2.mode,
    mtime: unixfs2.mtime,
    cidVersion: parent.cid.version
  });
  log$c(`converted directory to sharded directory ${result.cid}`);
  return result;
};
const addToDirectory = async (parent, child, blockstore, options2) => {
  const parentLinks = parent.node.Links.filter((link) => {
    const matches = link.Name === child.Name;
    if (matches && !options2.allowOverwriting) {
      throw new AlreadyExistsError();
    }
    return !matches;
  });
  parentLinks.push(child);
  if (parent.node.Data == null) {
    throw new InvalidPBNodeError("Parent node with no data passed to addToDirectory");
  }
  const node = UnixFS$1.unmarshal(parent.node.Data);
  let data;
  if (node.mtime != null) {
    const ms2 = Date.now();
    const secs = Math.floor(ms2 / 1e3);
    node.mtime = {
      secs: BigInt(secs),
      nsecs: (ms2 - secs * 1e3) * 1e3
    };
    data = node.marshal();
  } else {
    data = parent.node.Data;
  }
  parent.node = prepare({
    Data: data,
    Links: parentLinks
  });
  const buf2 = encode$7(parent.node);
  const hash2 = await sha256$1.digest(buf2);
  const cid = CID.create(parent.cid.version, code$5, hash2);
  await blockstore.put(cid, buf2);
  return {
    node: parent.node,
    cid
  };
};
const addToShardedDirectory = async (parent, child, blockstore, options2) => {
  var _a3;
  const { path, hash: hash2 } = await recreateShardedDirectory(parent.cid, child.Name, blockstore, options2);
  const finalSegment = path[path.length - 1];
  if (finalSegment == null) {
    throw new Error("Invalid HAMT, could not generate path");
  }
  const prefix = finalSegment.prefix;
  const index2 = parseInt(prefix, 16);
  log$c("next prefix for %s is %s", child.Name, prefix);
  const linkName = `${prefix}${child.Name}`;
  const existingLink = finalSegment.node.Links.find((l) => (l.Name ?? "").startsWith(prefix));
  if (existingLink != null) {
    log$c("link %s was present in shard", linkName);
    if (existingLink.Name === linkName) {
      if (!options2.allowOverwriting) {
        throw new AlreadyExistsError();
      }
      log$c("overwriting %s in subshard", child.Name);
      finalSegment.node.Links = finalSegment.node.Links.filter((l) => l.Name !== linkName);
      finalSegment.node.Links.push({
        Name: linkName,
        Hash: child.Hash,
        Tsize: child.Tsize
      });
    } else if (((_a3 = existingLink.Name) == null ? void 0 : _a3.length) === 2) {
      throw new Error("Existing link was subshard?!");
    } else {
      log$c("prefix %s already exists, creating new subshard", prefix);
      const index3 = finalSegment.node.Links.findIndex((l) => {
        var _a4;
        return (_a4 = l.Name) == null ? void 0 : _a4.startsWith(prefix);
      });
      const sibling = finalSegment.node.Links.splice(index3, 1)[0];
      const siblingName = (sibling.Name ?? "").substring(2);
      const wrapped = wrapHash(hamtHashFn);
      const siblingHash = wrapped(fromString$1(siblingName));
      for (let i = 0; i < path.length; i++) {
        await siblingHash.take(hamtBucketBits);
      }
      while (true) {
        const siblingIndex = await siblingHash.take(hamtBucketBits);
        const siblingPrefix = toPrefix(siblingIndex);
        sibling.Name = `${siblingPrefix}${siblingName}`;
        const newIndex = await hash2.take(hamtBucketBits);
        const newPrefix = toPrefix(newIndex);
        if (siblingPrefix === newPrefix) {
          const children2 = new SparseArray2();
          children2.set(newIndex, true);
          path.push({
            prefix: newPrefix,
            children: children2,
            node: {
              Links: []
            }
          });
          continue;
        }
        const children = new SparseArray2();
        children.set(newIndex, true);
        children.set(siblingIndex, true);
        path.push({
          prefix,
          children,
          node: {
            Links: [
              sibling,
              {
                Name: `${newPrefix}${child.Name}`,
                Hash: child.Hash,
                Tsize: child.Tsize
              }
            ]
          }
        });
        break;
      }
    }
  } else {
    log$c("link %s was not present in sub-shard", linkName);
    child.Name = linkName;
    finalSegment.node.Links.push(child);
    finalSegment.children.set(index2, true);
    log$c("adding %s to existing sub-shard", linkName);
  }
  return updateShardedDirectory(path, blockstore, options2);
};
async function cidToDirectory(cid, blockstore, options2 = {}) {
  const entry = await exporter$1(cid, blockstore, options2);
  if (entry.type !== "directory") {
    throw new NotADirectoryError(`${cid.toString()} was not a UnixFS directory`);
  }
  return {
    cid,
    node: entry.node
  };
}
async function cidToPBLink(cid, name2, blockstore, options2) {
  const sourceEntry = await exporter$1(cid, blockstore, options2);
  if (sourceEntry.type !== "directory" && sourceEntry.type !== "file" && sourceEntry.type !== "raw") {
    throw new NotUnixFSError(`${cid.toString()} was not a UnixFS node`);
  }
  return {
    Name: name2,
    Tsize: sourceEntry.node instanceof Uint8Array ? sourceEntry.node.byteLength : dagNodeTsize(sourceEntry.node),
    Hash: cid
  };
}
function dagNodeTsize(node) {
  const linkSizes = node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0);
  return encode$7(node).byteLength + linkSizes;
}
const log$b = logger("helia:unixfs:components:utils:resolve");
async function resolve(cid, path, blockstore, options2) {
  if (path == null || path === "") {
    return { cid };
  }
  const p = `/ipfs/${cid}${path == null ? "" : `/${path}`}`;
  const segments = await all(walkPath(p, blockstore, options2));
  if (segments.length === 0) {
    throw new DoesNotExistError("Could not find path in directory");
  }
  log$b("resolved %s to %c", path, cid);
  return {
    cid: segments[segments.length - 1].cid,
    path,
    segments
  };
}
async function updatePathCids(cid, result, blockstore, options2) {
  if (result.segments == null || result.segments.length === 0) {
    return cid;
  }
  let child = result.segments.pop();
  if (child == null) {
    throw new Error("Insufficient segments");
  }
  child.cid = cid;
  result.segments.reverse();
  for (const parent of result.segments) {
    const [directory, pblink] = await Promise.all([
      cidToDirectory(parent.cid, blockstore, options2),
      cidToPBLink(child.cid, child.name, blockstore, options2)
    ]);
    const result2 = await addLink(directory, pblink, blockstore, {
      ...options2,
      allowOverwriting: true,
      cidVersion: cid.version
    });
    cid = result2.cid;
    parent.cid = cid;
    child = parent;
  }
  return cid;
}
const mergeOptions$7 = mergeOptions$9.bind({ ignoreUndefined: true });
const defaultOptions$a = {};
async function* cat(cid, blockstore, options2 = {}) {
  const opts = mergeOptions$7(defaultOptions$a, options2);
  const resolved = await resolve(cid, opts.path, blockstore, opts);
  const result = await exporter$1(resolved.cid, blockstore, opts);
  if (result.type !== "file" && result.type !== "raw") {
    throw new NotAFileError();
  }
  if (result.content == null) {
    throw new NoContentError();
  }
  yield* result.content(opts);
}
const SHARD_SPLIT_THRESHOLD_BYTES = 262144;
const mergeOptions$6 = mergeOptions$9.bind({ ignoreUndefined: true });
const log$a = logger("helia:unixfs:chmod");
const defaultOptions$9 = {
  recursive: false,
  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES
};
async function chmod(cid, mode, blockstore, options2 = {}) {
  const opts = mergeOptions$6(defaultOptions$9, options2);
  const resolved = await resolve(cid, opts.path, blockstore, options2);
  log$a("chmod %c %d", resolved.cid, mode);
  if (opts.recursive) {
    const root2 = await pipe(
      async function* () {
        for await (const entry of recursive(resolved.cid, blockstore, options2)) {
          let metadata2;
          let links3 = [];
          if (entry.type === "raw") {
            metadata2 = new UnixFS$1({ type: "file", data: entry.node });
          } else if (entry.type === "file" || entry.type === "directory") {
            metadata2 = entry.unixfs;
            links3 = entry.node.Links;
          } else {
            throw new NotUnixFSError();
          }
          metadata2.mode = mode;
          const node = {
            Data: metadata2.marshal(),
            Links: links3
          };
          yield {
            path: entry.path,
            content: node
          };
        }
      },
      // @ts-expect-error cannot combine progress types
      (source) => importer(source, blockstore, {
        ...opts,
        dagBuilder: async function* (source2, block2) {
          for await (const entry of source2) {
            yield async function() {
              const node = entry.content;
              const buf2 = encode$7(node);
              const updatedCid2 = await persist(buf2, block2, {
                ...opts,
                cidVersion: cid.version
              });
              if (node.Data == null) {
                throw new InvalidPBNodeError(`${updatedCid2} had no data`);
              }
              const unixfs2 = UnixFS$1.unmarshal(node.Data);
              return {
                cid: updatedCid2,
                size: BigInt(buf2.length),
                path: entry.path,
                unixfs: unixfs2
              };
            };
          }
        }
      }),
      async (nodes) => last(nodes)
    );
    if (root2 == null) {
      throw new UnknownError(`Could not chmod ${resolved.cid.toString()}`);
    }
    return updatePathCids(root2.cid, resolved, blockstore, opts);
  }
  const block = await blockstore.get(resolved.cid, options2);
  let metadata;
  let links2 = [];
  if (resolved.cid.code === code$3) {
    metadata = new UnixFS$1({ type: "file", data: block });
  } else {
    const node = decode$a(block);
    if (node.Data == null) {
      throw new InvalidPBNodeError(`${resolved.cid.toString()} had no data`);
    }
    links2 = node.Links;
    metadata = UnixFS$1.unmarshal(node.Data);
  }
  metadata.mode = mode;
  const updatedBlock = encode$7({
    Data: metadata.marshal(),
    Links: links2
  });
  const hash2 = await sha256$1.digest(updatedBlock);
  const updatedCid = CID.create(resolved.cid.version, code$5, hash2);
  await blockstore.put(updatedCid, updatedBlock);
  return updatePathCids(updatedCid, resolved, blockstore, opts);
}
const mergeOptions$5 = mergeOptions$9.bind({ ignoreUndefined: true });
const log$9 = logger("helia:unixfs:cp");
const defaultOptions$8 = {
  force: false,
  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES
};
async function cp(source, target, name2, blockstore, options2 = {}) {
  const opts = mergeOptions$5(defaultOptions$8, options2);
  if (name2.includes("/")) {
    throw new InvalidParametersError("Name must not have slashes");
  }
  const [directory, pblink] = await Promise.all([
    cidToDirectory(target, blockstore, opts),
    cidToPBLink(source, name2, blockstore, opts)
  ]);
  log$9('Adding %c as "%s" to %c', source, name2, target);
  const result = await addLink(directory, pblink, blockstore, {
    allowOverwriting: opts.force,
    cidVersion: target.version,
    ...opts
  });
  return result.cid;
}
const mergeOptions$4 = mergeOptions$9.bind({ ignoreUndefined: true });
const defaultOptions$7 = {};
async function* ls(cid, blockstore, options2 = {}) {
  const opts = mergeOptions$4(defaultOptions$7, options2);
  const resolved = await resolve(cid, opts.path, blockstore, opts);
  const result = await exporter$1(resolved.cid, blockstore);
  if (result.type === "file" || result.type === "raw") {
    yield result;
    return;
  }
  if (result.content == null) {
    throw new NoContentError();
  }
  if (result.type !== "directory") {
    throw new NotADirectoryError();
  }
  yield* result.content({
    offset: options2.offset,
    length: options2.length
  });
}
const mergeOptions$3 = mergeOptions$9.bind({ ignoreUndefined: true });
const log$8 = logger("helia:unixfs:mkdir");
const defaultOptions$6 = {
  cidVersion: 1,
  force: false,
  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES
};
async function mkdir(parentCid, dirname, blockstore, options2 = {}) {
  const opts = mergeOptions$3(defaultOptions$6, options2);
  if (dirname.includes("/")) {
    throw new InvalidParametersError("Path must not have slashes");
  }
  const entry = await exporter$1(parentCid, blockstore, options2);
  if (entry.type !== "directory") {
    throw new NotADirectoryError(`${parentCid.toString()} was not a UnixFS directory`);
  }
  log$8("creating %s", dirname);
  const metadata = new UnixFS$1({
    type: "directory",
    mode: opts.mode,
    mtime: opts.mtime
  });
  const node = {
    Data: metadata.marshal(),
    Links: []
  };
  const buf2 = encode$7(node);
  const hash2 = await sha256$1.digest(buf2);
  const emptyDirCid = CID.create(opts.cidVersion, code$5, hash2);
  await blockstore.put(emptyDirCid, buf2);
  const [directory, pblink] = await Promise.all([
    cidToDirectory(parentCid, blockstore, opts),
    cidToPBLink(emptyDirCid, dirname, blockstore, opts)
  ]);
  log$8("adding empty dir called %s to %c", dirname, parentCid);
  const result = await addLink(directory, pblink, blockstore, {
    ...opts,
    allowOverwriting: opts.force
  });
  return result.cid;
}
const log$7 = logger("helia:unixfs:utils:remove-link");
async function removeLink(parent, name2, blockstore, options2) {
  if (parent.node.Data == null) {
    throw new InvalidPBNodeError("Parent node had no data");
  }
  const meta = UnixFS$1.unmarshal(parent.node.Data);
  if (meta.type === "hamt-sharded-directory") {
    log$7(`removing ${name2} from sharded directory`);
    const result = await removeFromShardedDirectory(parent, name2, blockstore, options2);
    if (!await isOverShardThreshold(result.node, blockstore, options2.shardSplitThresholdBytes, options2)) {
      log$7("converting shard to flat directory %c", parent.cid);
      return convertToFlatDirectory(result, blockstore, options2);
    }
    return result;
  }
  log$7(`removing link ${name2} regular directory`);
  return removeFromDirectory(parent, name2, blockstore, options2);
}
const removeFromDirectory = async (parent, name2, blockstore, options2) => {
  parent.node.Links = parent.node.Links.filter((link) => {
    return link.Name !== name2;
  });
  const parentBlock = encode$7(parent.node);
  const parentCid = await persist(parentBlock, blockstore, {
    ...options2,
    cidVersion: parent.cid.version
  });
  log$7(`Updated regular directory ${parentCid}`);
  return {
    node: parent.node,
    cid: parentCid
  };
};
const removeFromShardedDirectory = async (parent, name2, blockstore, options2) => {
  const { path } = await recreateShardedDirectory(parent.cid, name2, blockstore, options2);
  const finalSegment = path[path.length - 1];
  if (finalSegment == null) {
    throw new Error("Invalid HAMT, could not generate path");
  }
  const linkName = finalSegment.node.Links.filter((l) => (l.Name ?? "").substring(2) === name2).map((l) => l.Name).pop();
  if (linkName == null) {
    throw new Error("File not found");
  }
  const prefix = linkName.substring(0, 2);
  const index2 = parseInt(prefix, 16);
  finalSegment.node.Links = finalSegment.node.Links.filter((link) => link.Name !== linkName);
  finalSegment.children.unset(index2);
  if (finalSegment.node.Links.length === 1) {
    while (true) {
      if (path.length === 1) {
        break;
      }
      const segment = path[path.length - 1];
      if (segment == null || segment.node.Links.length > 1) {
        break;
      }
      path.pop();
      const nextSegment = path[path.length - 1];
      if (nextSegment == null) {
        break;
      }
      const link = segment.node.Links[0];
      nextSegment.node.Links = nextSegment.node.Links.filter((l) => !(l.Name ?? "").startsWith(nextSegment.prefix));
      nextSegment.node.Links.push({
        Hash: link.Hash,
        Name: `${nextSegment.prefix}${(link.Name ?? "").substring(2)}`,
        Tsize: link.Tsize
      });
    }
  }
  return updateShardedDirectory(path, blockstore, options2);
};
const convertToFlatDirectory = async (parent, blockstore, options2) => {
  if (parent.node.Data == null) {
    throw new InvalidParametersError("Invalid parent passed to convertToFlatDirectory");
  }
  const rootNode = {
    Links: []
  };
  const dir = await exporter$1(parent.cid, blockstore);
  if (dir.type !== "directory") {
    throw new Error("Unexpected node type");
  }
  for await (const entry of dir.content()) {
    let tsize = 0;
    if (entry.node instanceof Uint8Array) {
      tsize = entry.node.byteLength;
    } else {
      tsize = encode$7(entry.node).length;
    }
    rootNode.Links.push({
      Hash: entry.cid,
      Name: entry.name,
      Tsize: tsize
    });
  }
  const oldUnixfs = UnixFS$1.unmarshal(parent.node.Data);
  rootNode.Data = new UnixFS$1({ type: "directory", mode: oldUnixfs.mode, mtime: oldUnixfs.mtime }).marshal();
  const block = encode$7(prepare(rootNode));
  const cid = await persist(block, blockstore, {
    codec: dagPB,
    cidVersion: parent.cid.version,
    signal: options2.signal
  });
  return {
    cid,
    node: rootNode
  };
};
const mergeOptions$2 = mergeOptions$9.bind({ ignoreUndefined: true });
const log$6 = logger("helia:unixfs:rm");
const defaultOptions$5 = {
  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES
};
async function rm(target, name2, blockstore, options2 = {}) {
  const opts = mergeOptions$2(defaultOptions$5, options2);
  if (name2.includes("/")) {
    throw new InvalidParametersError("Name must not have slashes");
  }
  const directory = await cidToDirectory(target, blockstore, opts);
  log$6("Removing %s from %c", name2, target);
  const result = await removeLink(directory, name2, blockstore, {
    ...opts,
    cidVersion: target.version
  });
  return result.cid;
}
const mergeOptions$1 = mergeOptions$9.bind({ ignoreUndefined: true });
const log$5 = logger("helia:unixfs:stat");
const defaultOptions$4 = {};
async function stat(cid, blockstore, options2 = {}) {
  var _a3;
  const opts = mergeOptions$1(defaultOptions$4, options2);
  const resolved = await resolve(cid, options2.path, blockstore, opts);
  log$5("stat %c", resolved.cid);
  const result = await exporter$1(resolved.cid, blockstore, opts);
  if (result.type !== "file" && result.type !== "directory" && result.type !== "raw") {
    throw new NotUnixFSError();
  }
  let fileSize = 0n;
  let dagSize = 0n;
  let localFileSize = 0n;
  let localDagSize = 0n;
  let blocks = 0;
  let mode;
  let mtime;
  const type = result.type;
  let unixfs2;
  if (result.type === "raw") {
    fileSize = BigInt(result.node.byteLength);
    dagSize = BigInt(result.node.byteLength);
    localFileSize = BigInt(result.node.byteLength);
    localDagSize = BigInt(result.node.byteLength);
    blocks = 1;
  }
  if (result.type === "directory") {
    fileSize = 0n;
    dagSize = BigInt(result.unixfs.marshal().byteLength);
    localFileSize = 0n;
    localDagSize = dagSize;
    blocks = 1;
    mode = result.unixfs.mode;
    mtime = result.unixfs.mtime;
    unixfs2 = result.unixfs;
  }
  if (result.type === "file") {
    const results = await inspectDag(resolved.cid, blockstore, opts);
    fileSize = result.unixfs.fileSize();
    dagSize = BigInt((((_a3 = result.node.Data) == null ? void 0 : _a3.byteLength) ?? 0) + result.node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0));
    localFileSize = BigInt(results.localFileSize);
    localDagSize = BigInt(results.localDagSize);
    blocks = results.blocks;
    mode = result.unixfs.mode;
    mtime = result.unixfs.mtime;
    unixfs2 = result.unixfs;
  }
  return {
    cid: resolved.cid,
    mode,
    mtime,
    fileSize,
    dagSize,
    localFileSize,
    localDagSize,
    blocks,
    type,
    unixfs: unixfs2
  };
}
async function inspectDag(cid, blockstore, options2) {
  const results = {
    localFileSize: 0,
    localDagSize: 0,
    blocks: 0
  };
  if (await blockstore.has(cid, options2)) {
    const block = await blockstore.get(cid, options2);
    results.blocks++;
    results.localDagSize += block.byteLength;
    if (cid.code === code$3) {
      results.localFileSize += block.byteLength;
    } else if (cid.code === code$5) {
      const pbNode = decode$a(block);
      if (pbNode.Links.length > 0) {
        for (const link of pbNode.Links) {
          const linkResult = await inspectDag(link.Hash, blockstore, options2);
          results.localFileSize += linkResult.localFileSize;
          results.localDagSize += linkResult.localDagSize;
          results.blocks += linkResult.blocks;
        }
      } else {
        if (pbNode.Data == null) {
          throw new InvalidPBNodeError(`PBNode ${cid.toString()} had no data`);
        }
        const unixfs2 = UnixFS$1.unmarshal(pbNode.Data);
        if (unixfs2.data == null) {
          throw new InvalidPBNodeError(`UnixFS node ${cid.toString()} had no data`);
        }
        results.localFileSize += unixfs2.data.byteLength ?? 0;
      }
    } else {
      throw new UnknownError(`${cid.toString()} was neither DAG_PB nor RAW`);
    }
  }
  return results;
}
const mergeOptions = mergeOptions$9.bind({ ignoreUndefined: true });
const log$4 = logger("helia:unixfs:touch");
const defaultOptions$3 = {
  recursive: false,
  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES
};
async function touch(cid, blockstore, options2 = {}) {
  const opts = mergeOptions(defaultOptions$3, options2);
  const resolved = await resolve(cid, opts.path, blockstore, opts);
  const mtime = opts.mtime ?? {
    secs: BigInt(Math.round(Date.now() / 1e3)),
    nsecs: 0
  };
  log$4("touch %c %o", resolved.cid, mtime);
  if (opts.recursive) {
    const root2 = await pipe(
      async function* () {
        for await (const entry of recursive(resolved.cid, blockstore)) {
          let metadata2;
          let links3;
          if (entry.type === "raw") {
            metadata2 = new UnixFS$1({ data: entry.node });
            links3 = [];
          } else if (entry.type === "file" || entry.type === "directory") {
            metadata2 = entry.unixfs;
            links3 = entry.node.Links;
          } else {
            throw new NotUnixFSError();
          }
          metadata2.mtime = mtime;
          const node = {
            Data: metadata2.marshal(),
            Links: links3
          };
          yield {
            path: entry.path,
            content: node
          };
        }
      },
      // @ts-expect-error blockstore types are incompatible
      (source) => importer(source, blockstore, {
        ...opts,
        dagBuilder: async function* (source2, block2) {
          for await (const entry of source2) {
            yield async function() {
              const node = entry.content;
              const buf2 = encode$7(node);
              const updatedCid2 = await persist(buf2, block2, {
                ...opts,
                cidVersion: cid.version
              });
              if (node.Data == null) {
                throw new InvalidPBNodeError(`${updatedCid2} had no data`);
              }
              const unixfs2 = UnixFS$1.unmarshal(node.Data);
              return {
                cid: updatedCid2,
                size: BigInt(buf2.length),
                path: entry.path,
                unixfs: unixfs2
              };
            };
          }
        }
      }),
      async (nodes) => last(nodes)
    );
    if (root2 == null) {
      throw new UnknownError(`Could not chmod ${resolved.cid.toString()}`);
    }
    return updatePathCids(root2.cid, resolved, blockstore, opts);
  }
  const block = await blockstore.get(resolved.cid, options2);
  let metadata;
  let links2 = [];
  if (resolved.cid.code === code$3) {
    metadata = new UnixFS$1({ data: block });
  } else {
    const node = decode$a(block);
    links2 = node.Links;
    if (node.Data == null) {
      throw new InvalidPBNodeError(`${resolved.cid.toString()} had no data`);
    }
    metadata = UnixFS$1.unmarshal(node.Data);
  }
  metadata.mtime = mtime;
  const updatedBlock = encode$7({
    Data: metadata.marshal(),
    Links: links2
  });
  const hash2 = await sha256$1.digest(updatedBlock);
  const updatedCid = CID.create(resolved.cid.version, code$5, hash2);
  await blockstore.put(updatedCid, updatedBlock);
  return updatePathCids(updatedCid, resolved, blockstore, opts);
}
class UnixFS2 {
  constructor(components) {
    __publicField(this, "components");
    this.components = components;
  }
  async *addAll(source, options2 = {}) {
    yield* addAll(source, this.components.blockstore, options2);
  }
  async addBytes(bytes2, options2 = {}) {
    return addBytes(bytes2, this.components.blockstore, options2);
  }
  async addByteStream(bytes2, options2 = {}) {
    return addByteStream(bytes2, this.components.blockstore, options2);
  }
  async addFile(file, options2 = {}) {
    return addFile(file, this.components.blockstore, options2);
  }
  async addDirectory(dir = {}, options2 = {}) {
    return addDirectory(dir, this.components.blockstore, options2);
  }
  async *cat(cid, options2 = {}) {
    yield* cat(cid, this.components.blockstore, options2);
  }
  async chmod(cid, mode, options2 = {}) {
    return chmod(cid, mode, this.components.blockstore, options2);
  }
  async cp(source, target, name2, options2 = {}) {
    return cp(source, target, name2, this.components.blockstore, options2);
  }
  async *ls(cid, options2 = {}) {
    yield* ls(cid, this.components.blockstore, options2);
  }
  async mkdir(cid, dirname, options2 = {}) {
    return mkdir(cid, dirname, this.components.blockstore, options2);
  }
  async rm(cid, path, options2 = {}) {
    return rm(cid, path, this.components.blockstore, options2);
  }
  async stat(cid, options2 = {}) {
    return stat(cid, this.components.blockstore, options2);
  }
  async touch(cid, options2 = {}) {
    return touch(cid, this.components.blockstore, options2);
  }
}
function unixfs(helia) {
  return new UnixFS2(helia);
}
var encode_1 = encode;
var MSB$1 = 128, REST$1 = 127, MSBALL = ~REST$1, INT = Math.pow(2, 31);
function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0;
    throw new RangeError("Could not encode varint");
  }
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB$1;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB$1;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}
var decode$1 = read;
var MSB = 128, REST = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode$1,
  encodingLength: length
};
const varint$1 = /* @__PURE__ */ getDefaultExportFromCjs(varint);
const CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
const V2_HEADER_LENGTH = (
  /* characteristics */
  16 + 8 + 8 + 8
);
function decodeVarint(bytes2, seeker) {
  if (!bytes2.length) {
    throw new Error("Unexpected end of data");
  }
  const i = varint$1.decode(bytes2);
  seeker.seek(
    /** @type {number} */
    varint$1.decode.bytes
  );
  return i;
}
function decodeV2Header(bytes2) {
  const dv = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  let offset = 0;
  const header = {
    version: 2,
    /** @type {[bigint, bigint]} */
    characteristics: [
      dv.getBigUint64(offset, true),
      dv.getBigUint64(offset += 8, true)
    ],
    dataOffset: Number(dv.getBigUint64(offset += 8, true)),
    dataSize: Number(dv.getBigUint64(offset += 8, true)),
    indexOffset: Number(dv.getBigUint64(offset += 8, true))
  };
  return header;
}
function getMultihashLength(bytes2) {
  varint$1.decode(bytes2);
  const codeLength = (
    /** @type {number} */
    varint$1.decode.bytes
  );
  const length2 = varint$1.decode(bytes2.subarray(varint$1.decode.bytes));
  const lengthLength = (
    /** @type {number} */
    varint$1.decode.bytes
  );
  const mhLength = codeLength + lengthLength + length2;
  return mhLength;
}
const Kinds = {
  Null: (
    /** @returns {undefined|null} */
    (obj) => obj === null ? obj : void 0
  ),
  Int: (
    /** @returns {undefined|number} */
    (obj) => Number.isInteger(obj) ? obj : void 0
  ),
  Float: (
    /** @returns {undefined|number} */
    (obj) => typeof obj === "number" && Number.isFinite(obj) ? obj : void 0
  ),
  String: (
    /** @returns {undefined|string} */
    (obj) => typeof obj === "string" ? obj : void 0
  ),
  Bool: (
    /** @returns {undefined|boolean} */
    (obj) => typeof obj === "boolean" ? obj : void 0
  ),
  Bytes: (
    /** @returns {undefined|Uint8Array} */
    (obj) => obj instanceof Uint8Array ? obj : void 0
  ),
  Link: (
    /** @returns {undefined|object} */
    (obj) => obj !== null && typeof obj === "object" && obj.asCID === obj ? obj : void 0
  ),
  List: (
    /** @returns {undefined|Array<any>} */
    (obj) => Array.isArray(obj) ? obj : void 0
  ),
  Map: (
    /** @returns {undefined|object} */
    (obj) => obj !== null && typeof obj === "object" && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : void 0
  )
};
const Types = {
  "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
  "CarV1HeaderOrV2Pragma > roots (anon)": (
    /** @returns {undefined|any} */
    (obj) => {
      if (Kinds.List(obj) === void 0) {
        return void 0;
      }
      for (let i = 0; i < obj.length; i++) {
        let v = obj[i];
        v = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
        if (v === void 0) {
          return void 0;
        }
        if (v !== obj[i]) {
          const ret = obj.slice(0, i);
          for (let j = i; j < obj.length; j++) {
            let v2 = obj[j];
            v2 = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
            if (v2 === void 0) {
              return void 0;
            }
            ret.push(v2);
          }
          return ret;
        }
      }
      return obj;
    }
  ),
  Int: Kinds.Int,
  CarV1HeaderOrV2Pragma: (
    /** @returns {undefined|any} */
    (obj) => {
      if (Kinds.Map(obj) === void 0) {
        return void 0;
      }
      const entries = Object.entries(obj);
      let ret = obj;
      let requiredCount = 1;
      for (let i = 0; i < entries.length; i++) {
        const [key, value] = entries[i];
        switch (key) {
          case "roots":
            {
              const v = Types["CarV1HeaderOrV2Pragma > roots (anon)"](obj[key]);
              if (v === void 0) {
                return void 0;
              }
              if (v !== value || ret !== obj) {
                if (ret === obj) {
                  ret = {};
                  for (let j = 0; j < i; j++) {
                    ret[entries[j][0]] = entries[j][1];
                  }
                }
                ret.roots = v;
              }
            }
            break;
          case "version":
            {
              requiredCount--;
              const v = Types.Int(obj[key]);
              if (v === void 0) {
                return void 0;
              }
              if (v !== value || ret !== obj) {
                if (ret === obj) {
                  ret = {};
                  for (let j = 0; j < i; j++) {
                    ret[entries[j][0]] = entries[j][1];
                  }
                }
                ret.version = v;
              }
            }
            break;
          default:
            return void 0;
        }
      }
      if (requiredCount > 0) {
        return void 0;
      }
      return ret;
    }
  )
};
const Reprs = {
  "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
  "CarV1HeaderOrV2Pragma > roots (anon)": (
    /** @returns {undefined|any} */
    (obj) => {
      if (Kinds.List(obj) === void 0) {
        return void 0;
      }
      for (let i = 0; i < obj.length; i++) {
        let v = obj[i];
        v = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
        if (v === void 0) {
          return void 0;
        }
        if (v !== obj[i]) {
          const ret = obj.slice(0, i);
          for (let j = i; j < obj.length; j++) {
            let v2 = obj[j];
            v2 = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
            if (v2 === void 0) {
              return void 0;
            }
            ret.push(v2);
          }
          return ret;
        }
      }
      return obj;
    }
  ),
  Int: Kinds.Int,
  CarV1HeaderOrV2Pragma: (
    /** @returns {undefined|any} */
    (obj) => {
      if (Kinds.Map(obj) === void 0) {
        return void 0;
      }
      const entries = Object.entries(obj);
      let ret = obj;
      let requiredCount = 1;
      for (let i = 0; i < entries.length; i++) {
        const [key, value] = entries[i];
        switch (key) {
          case "roots":
            {
              const v = Reprs["CarV1HeaderOrV2Pragma > roots (anon)"](value);
              if (v === void 0) {
                return void 0;
              }
              if (v !== value || ret !== obj) {
                if (ret === obj) {
                  ret = {};
                  for (let j = 0; j < i; j++) {
                    ret[entries[j][0]] = entries[j][1];
                  }
                }
                ret.roots = v;
              }
            }
            break;
          case "version":
            {
              requiredCount--;
              const v = Reprs.Int(value);
              if (v === void 0) {
                return void 0;
              }
              if (v !== value || ret !== obj) {
                if (ret === obj) {
                  ret = {};
                  for (let j = 0; j < i; j++) {
                    ret[entries[j][0]] = entries[j][1];
                  }
                }
                ret.version = v;
              }
            }
            break;
          default:
            return void 0;
        }
      }
      if (requiredCount > 0) {
        return void 0;
      }
      return ret;
    }
  )
};
const CarV1HeaderOrV2Pragma = {
  toTyped: Types.CarV1HeaderOrV2Pragma,
  toRepresentation: Reprs.CarV1HeaderOrV2Pragma
};
makeCborEncoders();
async function readHeader(reader, strictVersion) {
  const length2 = decodeVarint(await reader.upTo(8), reader);
  if (length2 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader.exactly(length2, true);
  const block = decode$4(header);
  if (CarV1HeaderOrV2Pragma.toTyped(block) === void 0) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  if (block.version === 1) {
    if (!Array.isArray(block.roots)) {
      throw new Error("Invalid CAR header format");
    }
    return block;
  }
  if (block.roots !== void 0) {
    throw new Error("Invalid CAR header format");
  }
  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true));
  reader.seek(v2Header.dataOffset - reader.pos);
  const v1Header = await readHeader(reader, 1);
  return Object.assign(v1Header, v2Header);
}
async function readCid(reader) {
  const first2 = await reader.exactly(2, false);
  if (first2[0] === CIDV0_BYTES.SHA2_256 && first2[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader.exactly(34, true);
    const multihash2 = decode$d(bytes3);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version2 = decodeVarint(await reader.upTo(8), reader);
  if (version2 !== 1) {
    throw new Error(`Unexpected CID version (${version2})`);
  }
  const codec = decodeVarint(await reader.upTo(8), reader);
  const bytes2 = await reader.exactly(getMultihashLength(await reader.upTo(8)), true);
  const multihash = decode$d(bytes2);
  return CID.create(version2, codec, multihash);
}
async function readBlockHead(reader) {
  const start2 = reader.pos;
  let length2 = decodeVarint(await reader.upTo(8), reader);
  if (length2 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length2 += reader.pos - start2;
  const cid = await readCid(reader);
  const blockLength = length2 - Number(reader.pos - start2);
  return { cid, length: length2, blockLength };
}
async function readBlock(reader) {
  const { cid, blockLength } = await readBlockHead(reader);
  const bytes2 = await reader.exactly(blockLength, true);
  return { bytes: bytes2, cid };
}
async function readBlockIndex(reader) {
  const offset = reader.pos;
  const { cid, length: length2, blockLength } = await readBlockHead(reader);
  const index2 = { cid, length: length2, blockLength, offset, blockOffset: reader.pos };
  reader.seek(index2.blockLength);
  return index2;
}
function createDecoder(reader) {
  const headerPromise = (async () => {
    const header = await readHeader(reader);
    if (header.version === 2) {
      const v1length = reader.pos - header.dataOffset;
      reader = limitReader(reader, header.dataSize - v1length);
    }
    return header;
  })();
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlock(reader);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlockIndex(reader);
      }
    }
  };
}
function bytesReader(bytes2) {
  let pos = 0;
  return {
    async upTo(length2) {
      const out = bytes2.subarray(pos, pos + Math.min(length2, bytes2.length - pos));
      return out;
    },
    async exactly(length2, seek = false) {
      if (length2 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      const out = bytes2.subarray(pos, pos + length2);
      if (seek) {
        pos += length2;
      }
      return out;
    },
    seek(length2) {
      pos += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = async (length2) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length2) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset = 0;
  };
  return {
    async upTo(length2) {
      if (currentChunk.length - offset < length2) {
        await read2(length2);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
    },
    async exactly(length2, seek = false) {
      if (currentChunk.length - offset < length2) {
        await read2(length2);
      }
      if (currentChunk.length - offset < length2) {
        throw new Error("Unexpected end of data");
      }
      const out = currentChunk.subarray(offset, offset + length2);
      if (seek) {
        pos += length2;
        offset += length2;
      }
      return out;
    },
    seek(length2) {
      pos += length2;
      offset += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
function limitReader(reader, byteLimit) {
  let bytesRead = 0;
  return {
    async upTo(length2) {
      let bytes2 = await reader.upTo(length2);
      if (bytes2.length + bytesRead > byteLimit) {
        bytes2 = bytes2.subarray(0, byteLimit - bytesRead);
      }
      return bytes2;
    },
    async exactly(length2, seek = false) {
      const bytes2 = await reader.exactly(length2, seek);
      if (bytes2.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      if (seek) {
        bytesRead += length2;
      }
      return bytes2;
    },
    seek(length2) {
      bytesRead += length2;
      reader.seek(length2);
    },
    get pos() {
      return reader.pos;
    }
  };
}
const CAR_V1_VERSION = 1;
function createHeader$1(roots) {
  const headerBytes = encode$1({ version: CAR_V1_VERSION, roots });
  const varintBytes = varint$1.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer) {
  return {
    /**
     * @param {CID[]} roots
     * @returns {Promise<void>}
     */
    async setRoots(roots) {
      const bytes2 = createHeader$1(roots);
      await writer.write(bytes2);
    },
    /**
     * @param {Block} block
     * @returns {Promise<void>}
     */
    async writeBlock(block) {
      const { cid, bytes: bytes2 } = block;
      await writer.write(new Uint8Array(varint$1.encode(cid.bytes.length + bytes2.length)));
      await writer.write(cid.bytes);
      if (bytes2.length) {
        await writer.write(bytes2);
      }
    },
    /**
     * @returns {Promise<void>}
     */
    async close() {
      await writer.end();
    },
    /**
     * @returns {number}
     */
    version() {
      return CAR_V1_VERSION;
    }
  };
}
function noop() {
}
function create$1() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve2) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop;
          resolve2();
        };
      });
    }
    return drainer;
  };
  const writer = {
    /**
     * @param {T} chunk
     * @returns {Promise<void>}
     */
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      await drainer2;
    }
  };
  const iterator = {
    /** @returns {Promise<IteratorResult<T>>} */
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return { done: false, value: chunk };
      }
      if (ended) {
        drainerResolver();
        return { done: true, value: void 0 };
      }
      if (!outWait) {
        outWait = new Promise((resolve2) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop;
            return resolve2(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return { writer, iterator };
}
class CarWriter {
  /**
   * @param {CID[]} roots
   * @param {CarEncoder} encoder
   */
  constructor(roots, encoder) {
    this._encoder = encoder;
    this._mutex = encoder.setRoots(roots);
    this._ended = false;
  }
  /**
   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
   *
   * @function
   * @memberof CarWriter
   * @instance
   * @async
   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
   * @returns {Promise<void>} The returned promise will only resolve once the
   * bytes this block generates are written to the `out` iterable.
   */
  async put(block) {
    if (!(block.bytes instanceof Uint8Array) || !block.cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    if (this._ended) {
      throw new Error("Already closed");
    }
    const cid = CID.asCID(block.cid);
    if (!cid) {
      throw new TypeError("Can only write {cid, bytes} objects");
    }
    this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }));
    return this._mutex;
  }
  /**
   * Finalise the CAR archive and signal that the `out` iterable should end once
   * any remaining bytes are written.
   *
   * @function
   * @memberof CarWriter
   * @instance
   * @async
   * @returns {Promise<void>}
   */
  async close() {
    if (this._ended) {
      throw new Error("Already closed");
    }
    await this._mutex;
    this._ended = true;
    return this._encoder.close();
  }
  /**
   * Returns the version number of the CAR file being written
   *
   * @returns {number}
   */
  version() {
    return this._encoder.version();
  }
  /**
   * Create a new CAR writer "channel" which consists of a
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {CID[] | CID | void} roots
   * @returns {WriterChannel} The channel takes the form of
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
   */
  static create(roots) {
    roots = toRoots(roots);
    const { encoder, iterator } = encodeWriter();
    const writer = new CarWriter(roots, encoder);
    const out = new CarWriterOut(iterator);
    return { writer, out };
  }
  /**
   * Create a new CAR appender "channel" which consists of a
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
   * This appender does not consider roots and does not produce a CAR header.
   * It is designed to append blocks to an _existing_ CAR archive. It is
   * expected that `out` will be concatenated onto the end of an existing
   * archive that already has a properly formatted header.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @returns {WriterChannel} The channel takes the form of
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
   */
  static createAppender() {
    const { encoder, iterator } = encodeWriter();
    encoder.setRoots = () => Promise.resolve();
    const writer = new CarWriter([], encoder);
    const out = new CarWriterOut(iterator);
    return { writer, out };
  }
  /**
   * Update the list of roots in the header of an existing CAR as represented
   * in a Uint8Array.
   *
   * This operation is an _overwrite_, the total length of the CAR will not be
   * modified. A rejection will occur if the new header will not be the same
   * length as the existing header, in which case the CAR will not be modified.
   * It is the responsibility of the user to ensure that the roots being
   * replaced encode as the same length as the new roots.
   *
   * The byte array passed in an argument will be modified and also returned
   * upon successful modification.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {Uint8Array} bytes
   * @param {CID[]} roots - A new list of roots to replace the existing list in
   * the CAR header. The new header must take up the same number of bytes as the
   * existing header, so the roots should collectively be the same byte length
   * as the existing roots.
   * @returns {Promise<Uint8Array>}
   */
  static async updateRootsInBytes(bytes2, roots) {
    const reader = bytesReader(bytes2);
    await readHeader(reader);
    const newHeader = createHeader$1(roots);
    if (Number(reader.pos) !== newHeader.length) {
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
    }
    bytes2.set(newHeader, 0);
    return bytes2;
  }
}
class CarWriterOut {
  /**
   * @param {AsyncIterator<Uint8Array>} iterator
   */
  constructor(iterator) {
    this._iterator = iterator;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating) {
      throw new Error("Multiple iterator not supported");
    }
    this._iterating = true;
    return this._iterator;
  }
}
function encodeWriter() {
  const iw = create$1();
  const { writer, iterator } = iw;
  const encoder = createEncoder(writer);
  return { encoder, iterator };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid = CID.asCID(roots);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root2 of roots) {
    const _root = CID.asCID(root2);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}
function isAsyncIterable$3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain(source) {
  if (isAsyncIterable$3(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
const DAG_WALK_QUEUE_CONCURRENCY$1 = 1;
class DefaultCar {
  constructor(components, init) {
    __privateAdd(this, _DefaultCar_instances);
    __publicField(this, "components");
    this.components = components;
  }
  async import(reader, options2) {
    await drain(this.components.blockstore.putMany(map(reader.blocks(), ({ cid, bytes: bytes2 }) => ({ cid, block: bytes2 })), options2));
  }
  async export(root2, writer, options2) {
    const deferred = pDefer();
    const roots = Array.isArray(root2) ? root2 : [root2];
    const queue = new PQueue({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY$1
    });
    queue.on("idle", () => {
      deferred.resolve();
    });
    queue.on("error", (err) => {
      queue.clear();
      deferred.reject(err);
    });
    for (const root3 of roots) {
      void queue.add(async () => {
        await __privateMethod(this, _DefaultCar_instances, walkDag_fn).call(this, root3, queue, async (cid, bytes2) => {
          var _a3, _b2;
          if (((_a3 = options2 == null ? void 0 : options2.blockFilter) == null ? void 0 : _a3.has(cid.multihash.bytes)) === true) {
            return;
          }
          (_b2 = options2 == null ? void 0 : options2.blockFilter) == null ? void 0 : _b2.add(cid.multihash.bytes);
          await writer.put({ cid, bytes: bytes2 });
        }, options2);
      }).catch(() => {
      });
    }
    try {
      await deferred.promise;
    } finally {
      await writer.close();
    }
  }
  async *stream(root2, options2) {
    const { writer, out } = CarWriter.create(root2);
    this.export(root2, writer, options2).catch(() => {
    });
    for await (const buf2 of out) {
      yield buf2;
    }
  }
}
_DefaultCar_instances = new WeakSet();
walkDag_fn = async function(cid, queue, withBlock, options2) {
  const dagWalker = this.components.dagWalkers[cid.code];
  if (dagWalker == null) {
    throw new Error(`No dag walker found for cid codec ${cid.code}`);
  }
  const block = await this.components.blockstore.get(cid, options2);
  await withBlock(cid, block);
  for await (const cid2 of dagWalker.walk(block)) {
    void queue.add(async () => {
      await __privateMethod(this, _DefaultCar_instances, walkDag_fn).call(this, cid2, queue, withBlock, options2);
    });
  }
};
function car(helia, init = {}) {
  return new DefaultCar(helia, init);
}
const defaultOptions$2 = {};
class CarPreprocessorPlugin extends BasePlugin {
  constructor(uppy, opts) {
    super(uppy, { ...defaultOptions$2, ...opts });
    __privateAdd(this, _CarPreprocessorPlugin_instances);
    this.id = this.opts.id || "CarPreprocessor";
    this.type = "preprocessor";
  }
  install() {
    this.uppy.addPreProcessor(__privateMethod(this, _CarPreprocessorPlugin_instances, processor_fn).bind(this));
  }
  async processFile(file) {
    try {
      const [carStream, cid] = await __privateMethod(this, _CarPreprocessorPlugin_instances, createCarStreamMemory_fn).call(this, file, (progress) => {
        this.uppy.emit("preprocess-progress", asUppyFile(file), {
          mode: "determinate",
          message: "Processing file...",
          value: progress
        });
      });
      this.uppy.emit("preprocess-complete", asUppyFile(file), {
        mode: "determinate",
        message: "Processing file...",
        value: 100
      });
      const carBlob = await streamToBlob(
        carStream,
        "application/vnd.ipld.car"
      );
      file.data = new File([carBlob], cid.toString());
      this.uppy.setFileState(file.id, {
        data: file.data,
        // @ts-ignore
        car: true
      });
    } catch (error) {
      console.error("Error processing file:", error);
      throw error;
    }
  }
}
_CarPreprocessorPlugin_instances = new WeakSet();
createCarStreamMemory_fn = async function(file, onProgress) {
  const helia = await __privateMethod(this, _CarPreprocessorPlugin_instances, createHelia_fn).call(this);
  const fs = unixfs(helia);
  const c = car(helia);
  const tracker = new ProgressTracker(BigInt(file.size || 0));
  let blocksCount = 0n;
  const cid = await fs.addByteStream(file.data.stream(), {
    onProgress(event) {
      if (event.type === "unixfs:importer:progress:file:read") {
        tracker.updateDataProgress("fileRead", event.detail.bytesRead);
      } else if (event.type === "unixfs:importer:progress:file:write") {
        tracker.updateDataProgress("unixfsImport", event.detail.bytesWritten);
      } else if (event.type === "blocks:put:blockstore:put") {
        blocksCount++;
      }
      onProgress(tracker.getOverallProgress());
    }
  });
  const { writer, out } = await CarWriter.create(cid);
  let carBlocksWritten = 0n;
  const options2 = {
    onProgress(event) {
      if (event.type === "blocks:get:blockstore:get") {
        carBlocksWritten++;
        if (blocksCount === 0n) {
          return;
        }
        tracker.updateBlockProgress(carBlocksWritten * 100n / blocksCount);
        onProgress(tracker.getOverallProgress());
      }
    }
  };
  c.export(cid, writer, options2);
  return [
    new ReadableStream({
      async start(controller) {
        for await (const chunk of out) {
          controller.enqueue(chunk);
        }
        controller.close();
      }
    }),
    cid
  ];
};
processor_fn = async function(fileIDs, uploadID) {
  for (const fileID of fileIDs) {
    const file = this.uppy.getFile(fileID);
    if (__privateMethod(this, _CarPreprocessorPlugin_instances, isIPFSFile_fn).call(this, file)) {
      const isCarFile = await __privateMethod(this, _CarPreprocessorPlugin_instances, isCarFile_fn).call(this, file);
      if (isCarFile) {
        console.log(
          `File ${file.name} is a valid CAR file, skipping processing.`
        );
        this.uppy.emit("preprocess-complete", asUppyFile(file));
      } else {
        await this.processFile(file);
      }
    }
  }
  console.log(`Processed files for upload ${uploadID}`);
};
/*
  #isLargeFile(file: UppyFileDefault) {
    return (
      file.plugins &&
      file.plugins.filter((plugin) => PLUGIN_LARGE_SUFFIX_REGEX.test(plugin))
        .length > 0
    );
  }
*/
isIPFSFile_fn = function(file) {
  return file.plugins && file.plugins.filter((plugin) => /ipfs/.test(plugin)).length > 0;
};
createHelia_fn = async function() {
  var _a3;
  return (_a3 = dashboardStore.getState().getServiceById(SERVICE_ID)) == null ? void 0 : _a3.getHelia();
};
isCarFile_fn = async function(file) {
  var _a3;
  if (file.type !== "application/vnd.ipld.car" && !((_a3 = file.name) == null ? void 0 : _a3.endsWith(".car"))) {
    return false;
  }
  try {
    const fileIterable = {
      [Symbol.asyncIterator]: async function* () {
        const reader2 = file.data.stream().getReader();
        while (true) {
          const { done, value } = await reader2.read();
          if (done) break;
          yield value;
        }
      }
    };
    const reader = asyncIterableReader(fileIterable);
    const decoder = createDecoder(reader);
    let header;
    try {
      header = await decoder.header();
    } catch {
      return false;
    }
    return header.roots.length > 0;
  } catch (error) {
    console.error("Error verifying CAR file:", error);
    return false;
  }
};
async function streamToBlob(readableStream, mimeType) {
  const reader = readableStream.getReader();
  const chunks = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
  }
  const concatenated = new Uint8Array(
    chunks.reduce((acc, chunk) => acc + chunk.length, 0)
  );
  let offset = 0;
  for (const chunk of chunks) {
    concatenated.set(chunk, offset);
    offset += chunk.length;
  }
  return new Blob([concatenated], { type: mimeType });
}
function asUppyFile(file) {
  return file;
}
class ProgressTracker {
  constructor(fileSize) {
    this.state = {
      fileRead: 0,
      unixfsImport: 0,
      carExport: 0
    };
    this.fileSize = fileSize;
  }
  updateDataProgress(stage, value) {
    this.state[stage] = Number(value * 100n / this.fileSize);
  }
  updateBlockProgress(value) {
    this.state["carExport"] = Number(value);
  }
  getOverallProgress() {
    const { fileRead, unixfsImport, carExport } = this.state;
    return fileRead * 0.3 + unixfsImport * 0.4 + carExport * 0.3;
  }
}
function getPortalUrl() {
  var _a3;
  const state = baseStore.getState();
  if (state.portalUrl) {
    return state.portalUrl;
  }
  return `https://${(_a3 = state.meta) == null ? void 0 : _a3.domain}`;
}
async function getProtocolDomain(proto) {
  const meta = await fetchPortalMeta(getPortalUrl());
  return `${proto}.${meta.domain}`;
}
var queryString = {};
var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components, split2) {
  try {
    return [decodeURIComponent(components.join(""))];
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split2 = split2 || 1;
  var left = components.slice(0, split2);
  var right = components.slice(split2);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher) || [];
    for (var i = 1; i < tokens.length; i++) {
      input = decodeComponents(tokens, i).join("");
      tokens = input.match(singleMatcher) || [];
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  var replaceMap = {
    "%FE%FF": "",
    "%FF%FE": ""
  };
  var match = multiMatcher.exec(input);
  while (match) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher.exec(input);
  }
  replaceMap["%C2"] = "";
  var entries = Object.keys(replaceMap);
  for (var i = 0; i < entries.length; i++) {
    var key = entries[i];
    input = input.replace(new RegExp(key, "g"), replaceMap[key]);
  }
  return input;
}
var decodeUriComponent = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent(encodedURI);
  }
};
var splitOnFirst = (string2, separator) => {
  if (!(typeof string2 === "string" && typeof separator === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (separator === "") {
    return [string2];
  }
  const separatorIndex = string2.indexOf(separator);
  if (separatorIndex === -1) {
    return [string2];
  }
  return [
    string2.slice(0, separatorIndex),
    string2.slice(separatorIndex + separator.length)
  ];
};
var filterObj = function(obj, predicate) {
  var ret = {};
  var keys = Object.keys(obj);
  var isArr = Array.isArray(predicate);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var val = obj[key];
    if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
      ret[key] = val;
    }
  }
  return ret;
};
(function(exports) {
  const strictUriEncode$1 = strictUriEncode;
  const decodeComponent = decodeUriComponent;
  const splitOnFirst$1 = splitOnFirst;
  const filterObject = filterObj;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options2) {
    switch (options2.arrayFormat) {
      case "index":
        return (key) => (result, value) => {
          const index2 = result.length;
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode2(key, options2), "[", index2, "]"].join("")];
          }
          return [
            ...result,
            [encode2(key, options2), "[", encode2(index2, options2), "]=", encode2(value, options2)].join("")
          ];
        };
      case "bracket":
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode2(key, options2), "[]"].join("")];
          }
          return [...result, [encode2(key, options2), "[]=", encode2(value, options2)].join("")];
        };
      case "colon-list-separator":
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode2(key, options2), ":list="].join("")];
          }
          return [...result, [encode2(key, options2), ":list=", encode2(value, options2)].join("")];
        };
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options2.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode2(key, options2), keyValueSep, encode2(value, options2)].join("")];
          }
          return [[result, encode2(value, options2)].join(options2.arrayFormatSeparator)];
        };
      }
      default:
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode2(key, options2)];
          }
          return [...result, [encode2(key, options2), "=", encode2(value, options2)].join("")];
        };
    }
  }
  function parserForArrayFormat(options2) {
    let result;
    switch (options2.arrayFormat) {
      case "index":
        return (key, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key);
          key = key.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = {};
          }
          accumulator[key][result[1]] = value;
        };
      case "bracket":
        return (key, value, accumulator) => {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "colon-list-separator":
        return (key, value, accumulator) => {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "comma":
      case "separator":
        return (key, value, accumulator) => {
          const isArray = typeof value === "string" && value.includes(options2.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray && decode2(value, options2).includes(options2.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options2) : value;
          const newValue = isArray || isEncodedArray ? value.split(options2.arrayFormatSeparator).map((item) => decode2(item, options2)) : value === null ? value : decode2(value, options2);
          accumulator[key] = newValue;
        };
      case "bracket-separator":
        return (key, value, accumulator) => {
          const isArray = /(\[\])$/.test(key);
          key = key.replace(/\[\]$/, "");
          if (!isArray) {
            accumulator[key] = value ? decode2(value, options2) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options2.arrayFormatSeparator).map((item) => decode2(item, options2));
          if (accumulator[key] === void 0) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };
      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === void 0) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode2(value, options2) {
    if (options2.encode) {
      return options2.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options2) {
    if (options2.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash2(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash2 = url.slice(hashStart);
    }
    return hash2;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options2) {
    if (options2.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options2.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(query, options2) {
    options2 = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options2);
    validateArrayFormatSeparator(options2.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options2);
    const ret = /* @__PURE__ */ Object.create(null);
    if (typeof query !== "string") {
      return ret;
    }
    query = query.trim().replace(/^[?#&]/, "");
    if (!query) {
      return ret;
    }
    for (const param of query.split("&")) {
      if (param === "") {
        continue;
      }
      let [key, value] = splitOnFirst$1(options2.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options2.arrayFormat) ? value : decode2(value, options2);
      formatter(decode2(key, options2), value, ret);
    }
    for (const key of Object.keys(ret)) {
      const value = ret[key];
      if (typeof value === "object" && value !== null) {
        for (const k of Object.keys(value)) {
          value[k] = parseValue(value[k], options2);
        }
      } else {
        ret[key] = parseValue(value, options2);
      }
    }
    if (options2.sort === false) {
      return ret;
    }
    return (options2.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options2.sort)).reduce((result, key) => {
      const value = ret[key];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports.extract = extract;
  exports.parse = parse2;
  exports.stringify = (object, options2) => {
    if (!object) {
      return "";
    }
    options2 = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options2);
    validateArrayFormatSeparator(options2.arrayFormatSeparator);
    const shouldFilter = (key) => options2.skipNull && isNullOrUndefined(object[key]) || options2.skipEmptyString && object[key] === "";
    const formatter = encoderForArrayFormat(options2);
    const objectCopy = {};
    for (const key of Object.keys(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = object[key];
      }
    }
    const keys = Object.keys(objectCopy);
    if (options2.sort !== false) {
      keys.sort(options2.sort);
    }
    return keys.map((key) => {
      const value = object[key];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode2(key, options2);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options2.arrayFormat === "bracket-separator") {
          return encode2(key, options2) + "[]";
        }
        return value.reduce(formatter(key), []).join("&");
      }
      return encode2(key, options2) + "=" + encode2(value, options2);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports.parseUrl = (url, options2) => {
    options2 = Object.assign({
      decode: true
    }, options2);
    const [url_, hash2] = splitOnFirst$1(url, "#");
    return Object.assign(
      {
        url: url_.split("?")[0] || "",
        query: parse2(extract(url), options2)
      },
      options2 && options2.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options2) } : {}
    );
  };
  exports.stringifyUrl = (object, options2) => {
    options2 = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options2);
    const url = removeHash(object.url).split("?")[0] || "";
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString2 = exports.stringify(query, options2);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash2 = getHash2(object.url);
    if (object.fragmentIdentifier) {
      hash2 = `#${options2[encodeFragmentIdentifier] ? encode2(object.fragmentIdentifier, options2) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString2}${hash2}`;
  };
  exports.pick = (input, filter2, options2) => {
    options2 = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options2);
    const { url, query, fragmentIdentifier } = exports.parseUrl(input, options2);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter2),
      fragmentIdentifier
    }, options2);
  };
  exports.exclude = (input, filter2, options2) => {
    const exclusionFilter = Array.isArray(filter2) ? (key) => !filter2.includes(key) : (key, value) => !filter2(key, value);
    return exports.pick(input, exclusionFilter, options2);
  };
})(queryString);
var M = (r) => {
  switch (r) {
    case "ne":
    case "gte":
    case "lte":
      return `_${r}`;
    case "contains":
      return "_like";
    default:
      return "";
  }
};
var f = (r) => {
  if (r && r.length > 0) {
    let s2 = [], e = [];
    return r.map((t) => {
      s2.push(t.field), e.push(t.order);
    }), { _sort: s2, _order: e };
  }
};
var g = (r) => {
  let s2 = {};
  return r && r.map((e) => {
    if (e.operator === "or" || e.operator === "and") throw new Error(`[@refinedev/simple-rest]: \`operator: ${e.operator}\` is not supported. You can create custom data provider. https://refine.dev/docs/api-reference/core/providers/data-provider/#creating-a-data-provider`);
    if ("field" in e) {
      let { field: t, operator: o, value: n } = e;
      if (t === "q") {
        s2[t] = n;
        return;
      }
      let d2 = M(o);
      s2[`${t}${d2}`] = n;
    }
  }), s2;
};
var h = axios.create();
h.interceptors.response.use((r) => r, (r) => {
  var e, t, o;
  let s2 = { ...r, message: (t = (e = r.response) == null ? void 0 : e.data) == null ? void 0 : t.message, statusCode: (o = r.response) == null ? void 0 : o.status };
  return Promise.reject(s2);
});
var q = (r, s2 = h) => ({ getList: async ({ resource: e, pagination: t, filters: o, sorters: n, meta: d2 }) => {
  let i = `${r}/${e}`, { current: c = 1, pageSize: a = 10, mode: p = "server" } = t ?? {}, { headers: $, method: m2 } = d2 ?? {}, x2 = m2 ?? "get", v = g(o), u = {};
  p === "server" && (u._start = (c - 1) * a, u._end = c * a);
  let l = f(n);
  if (l) {
    let { _sort: T, _order: b } = l;
    u._sort = T.join(","), u._order = b.join(",");
  }
  let _ = { ...u, ...v }, O = Object.keys(_).length ? `${i}?${queryString.stringify(_)}` : i, { data: w2, headers: F } = await s2[x2](O, { headers: $ }), S = +F["x-total-count"];
  return { data: w2, total: S || w2.length };
}, getMany: async ({ resource: e, ids: t, meta: o }) => {
  let { headers: n, method: d2 } = o ?? {}, i = d2 ?? "get", { data: c } = await s2[i](`${r}/${e}?${queryString.stringify({ id: t })}`, { headers: n });
  return { data: c };
}, create: async ({ resource: e, variables: t, meta: o }) => {
  let n = `${r}/${e}`, { headers: d2, method: i } = o ?? {}, c = i ?? "post", { data: a } = await s2[c](n, t, { headers: d2 });
  return { data: a };
}, update: async ({ resource: e, id: t, variables: o, meta: n }) => {
  let d2 = `${r}/${e}/${t}`, { headers: i, method: c } = n ?? {}, a = c ?? "patch", { data: p } = await s2[a](d2, o, { headers: i });
  return { data: p };
}, getOne: async ({ resource: e, id: t, meta: o }) => {
  let n = `${r}/${e}/${t}`, { headers: d2, method: i } = o ?? {}, c = i ?? "get", { data: a } = await s2[c](n, { headers: d2 });
  return { data: a };
}, deleteOne: async ({ resource: e, id: t, variables: o, meta: n }) => {
  let d2 = `${r}/${e}/${t}`, { headers: i, method: c } = n ?? {}, a = c ?? "delete", { data: p } = await s2[a](d2, { data: o, headers: i });
  return { data: p };
}, getApiUrl: () => r, custom: async ({ url: e, method: t, filters: o, sorters: n, payload: d2, query: i, headers: c }) => {
  let a = `${e}?`;
  if (n) {
    let m2 = f(n);
    if (m2) {
      let { _sort: x2, _order: v } = m2, u = { _sort: x2.join(","), _order: v.join(",") };
      a = `${a}&${queryString.stringify(u)}`;
    }
  }
  if (o) {
    let m2 = g(o);
    a = `${a}&${queryString.stringify(m2)}`;
  }
  i && (a = `${a}&${queryString.stringify(i)}`);
  let p;
  switch (t) {
    case "put":
    case "post":
    case "patch":
      p = await s2[t](e, d2, { headers: c });
      break;
    case "delete":
      p = await s2.delete(e, { data: d2, headers: c });
      break;
    default:
      p = await s2.get(a, { headers: c });
      break;
  }
  let { data: $ } = p;
  return Promise.resolve({ data: $ });
} });
var N = q;
let BaseBlockstore$1 = class BaseBlockstore {
  has(key, options2) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  put(key, val, options2) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  async *putMany(source, options2) {
    for await (const { cid, block } of source) {
      await this.put(cid, block, options2);
      yield cid;
    }
  }
  get(key, options2) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  async *getMany(source, options2) {
    for await (const key of source) {
      yield {
        cid: key,
        block: await this.get(key, options2)
      };
    }
  }
  delete(key, options2) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *deleteMany(source, options2) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  async *getAll(options2) {
    throw new Error(".getAll is not implemented");
  }
};
class OpenFailedError extends Error {
  constructor(message2 = "Open failed") {
    super(message2);
    this.name = "OpenFailedError";
  }
}
class PutFailedError extends Error {
  constructor(message2 = "Put failed") {
    super(message2);
    this.name = "PutFailedError";
  }
}
class GetFailedError extends Error {
  constructor(message2 = "Get failed") {
    super(message2);
    this.name = "GetFailedError";
  }
}
class DeleteFailedError extends Error {
  constructor(message2 = "Delete failed") {
    super(message2);
    this.name = "DeleteFailedError";
  }
}
class NotFoundError extends Error {
  constructor(message2 = "Not Found") {
    super(message2);
    this.name = "NotFoundError";
  }
}
logger("blockstore:core:tiered");
const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve2, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve2(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve2, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve2();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func2) {
  if (getCursorAdvanceMethods().includes(func2)) {
    return function(...args) {
      func2.apply(unwrap(this), args);
      return wrap(this.request);
    };
  }
  return function(...args) {
    return wrap(func2.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);
function openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name2, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
function deleteDB(name2, { blocked } = {}) {
  const request = indexedDB.deleteDatabase(name2);
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event
    ));
  }
  return wrap(request).then(() => void 0);
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
const advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
const methodMap = {};
const advanceResults = /* @__PURE__ */ new WeakMap();
const ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
const cursorIteratorTraps = {
  get(target, prop) {
    if (!advanceMethodProps.includes(prop))
      return target[prop];
    let cachedFunc = methodMap[prop];
    if (!cachedFunc) {
      cachedFunc = methodMap[prop] = function(...args) {
        advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
      };
    }
    return cachedFunc;
  }
};
async function* iterate(...args) {
  let cursor = this;
  if (!(cursor instanceof IDBCursor)) {
    cursor = await cursor.openCursor(...args);
  }
  if (!cursor)
    return;
  cursor = cursor;
  const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
  ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
  reverseTransformCache.set(proxiedCursor, unwrap(cursor));
  while (cursor) {
    yield proxiedCursor;
    cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
    advanceResults.delete(proxiedCursor);
  }
}
function isIteratorProp(target, prop) {
  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get(target, prop, receiver) {
    if (isIteratorProp(target, prop))
      return iterate;
    return oldTraps.get(target, prop, receiver);
  },
  has(target, prop) {
    return isIteratorProp(target, prop) || oldTraps.has(target, prop);
  }
}));
class IDBBlockstore extends BaseBlockstore$1 {
  constructor(location, init = {}) {
    super();
    __privateAdd(this, _IDBBlockstore_instances);
    __publicField(this, "location");
    __publicField(this, "version");
    __publicField(this, "db");
    __publicField(this, "base");
    this.location = `${init.prefix ?? ""}${location}`;
    this.version = init.version ?? 1;
    this.base = init.base ?? base32upper;
  }
  async open() {
    try {
      const location = this.location;
      this.db = await openDB(location, this.version, {
        upgrade(db) {
          db.createObjectStore(location);
        }
      });
    } catch (err) {
      throw new OpenFailedError(String(err));
    }
  }
  async close() {
    var _a3;
    (_a3 = this.db) == null ? void 0 : _a3.close();
  }
  async put(key, val) {
    if (this.db == null) {
      throw new Error("Blockstore needs to be opened.");
    }
    try {
      await this.db.put(this.location, val, __privateMethod(this, _IDBBlockstore_instances, encode_fn).call(this, key));
      return key;
    } catch (err) {
      throw new PutFailedError(String(err));
    }
  }
  async get(key) {
    if (this.db == null) {
      throw new Error("Blockstore needs to be opened.");
    }
    let val;
    try {
      val = await this.db.get(this.location, __privateMethod(this, _IDBBlockstore_instances, encode_fn).call(this, key));
    } catch (err) {
      throw new PutFailedError(String(err));
    }
    if (val === void 0) {
      throw new NotFoundError();
    }
    return val;
  }
  async delete(key) {
    if (this.db == null) {
      throw new Error("Blockstore needs to be opened.");
    }
    try {
      await this.db.delete(this.location, __privateMethod(this, _IDBBlockstore_instances, encode_fn).call(this, key));
    } catch (err) {
      throw new PutFailedError(String(err));
    }
  }
  async has(key) {
    if (this.db == null) {
      throw new Error("Blockstore needs to be opened.");
    }
    try {
      return Boolean(await this.db.getKey(this.location, __privateMethod(this, _IDBBlockstore_instances, encode_fn).call(this, key)));
    } catch (err) {
      throw new PutFailedError(String(err));
    }
  }
  async *getAll(options2) {
    if (this.db == null) {
      throw new Error("Blockstore needs to be opened.");
    }
    for (const key of await this.db.getAllKeys(this.location)) {
      const cid = __privateMethod(this, _IDBBlockstore_instances, decode_fn).call(this, key.toString());
      const block = await this.get(cid);
      yield { cid, block };
    }
  }
  async destroy() {
    await deleteDB(this.location);
  }
}
_IDBBlockstore_instances = new WeakSet();
encode_fn = function(cid) {
  return `/${this.base.encoder.encode(cid.multihash.bytes)}`;
};
decode_fn = function(key) {
  return CID.createV1(code$3, decode$d(this.base.decoder.decode(key.substring(1))));
};
function toString$2(array, encoding = "utf8") {
  const base = BASES[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base.encoder.encode(array).substring(1);
}
const pathSepS = "/";
const pathSepB = new TextEncoder().encode(pathSepS);
const pathSep = pathSepB[0];
class Key {
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s2, clean) {
    __publicField(this, "_buf");
    if (typeof s2 === "string") {
      this._buf = fromString$1(s2);
    } else if (s2 instanceof Uint8Array) {
      this._buf = s2;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString$2(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes2 = new Uint8Array(this._buf.byteLength + 1);
      bytes2.fill(pathSep, 0, 1);
      bytes2.set(this._buf, 1);
      this._buf = bytes2;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s2) {
    return new Key(this.toString() + ":" + s2);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new Key(pathSepS);
    }
    return new Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
}
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}
const SHARDING_FN$1 = "SHARDING";
function isAsyncIterable$2(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable$2(source)) {
    return async function* () {
      const arr = await all(source);
      yield* arr.sort(sorter);
    }();
  }
  return function* () {
    const arr = all(source);
    yield* arr.sort(sorter);
  }();
}
function isAsyncIterable$1(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
  if (isAsyncIterable$1(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
let BaseDatastore$1 = class BaseDatastore {
  put(key, val, options2) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options2) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options2) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options2) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options2 = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options2);
      yield key;
    }
  }
  async *getMany(source, options2 = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options2)
      };
    }
  }
  async *deleteMany(source, options2 = {}) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options2) => {
        await drain(this.putMany(puts, options2));
        puts = [];
        await drain(this.deleteMany(dels, options2));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q2, options2) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q2, options2) {
    throw new Error("._allKeys is not implemented");
  }
  query(q2, options2) {
    let it = this._all(q2, options2);
    if (q2.prefix != null) {
      const prefix = q2.prefix;
      it = filter(it, (e) => e.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q2.filters)) {
      it = q2.filters.reduce((it2, f2) => filter(it2, f2), it);
    }
    if (Array.isArray(q2.orders)) {
      it = q2.orders.reduce((it2, f2) => sort(it2, f2), it);
    }
    if (q2.offset != null) {
      let i = 0;
      const offset = q2.offset;
      it = filter(it, () => i++ >= offset);
    }
    if (q2.limit != null) {
      it = take(it, q2.limit);
    }
    return it;
  }
  queryKeys(q2, options2) {
    let it = this._allKeys(q2, options2);
    if (q2.prefix != null) {
      const prefix = q2.prefix;
      it = filter(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q2.filters)) {
      it = q2.filters.reduce((it2, f2) => filter(it2, f2), it);
    }
    if (Array.isArray(q2.orders)) {
      it = q2.orders.reduce((it2, f2) => sort(it2, f2), it);
    }
    if (q2.offset != null) {
      const offset = q2.offset;
      let i = 0;
      it = filter(it, () => i++ >= offset);
    }
    if (q2.limit != null) {
      it = take(it, q2.limit);
    }
    return it;
  }
};
new Key(SHARDING_FN$1);
logger("datastore:core:tiered");
class IDBDatastore extends BaseDatastore$1 {
  constructor(location, init = {}) {
    super();
    __privateAdd(this, _IDBDatastore_instances);
    __publicField(this, "location");
    __publicField(this, "version");
    __publicField(this, "db");
    this.location = `${init.prefix ?? ""}${location}`;
    this.version = init.version ?? 1;
  }
  async open() {
    try {
      const location = this.location;
      this.db = await openDB(location, this.version, {
        upgrade(db) {
          db.createObjectStore(location);
        }
      });
    } catch (err) {
      throw new OpenFailedError(String(err));
    }
  }
  async close() {
    var _a3;
    (_a3 = this.db) == null ? void 0 : _a3.close();
  }
  async put(key, val) {
    if (this.db == null) {
      throw new Error("Datastore needs to be opened.");
    }
    try {
      await this.db.put(this.location, val, key.toString());
      return key;
    } catch (err) {
      throw new PutFailedError(String(err));
    }
  }
  async get(key) {
    if (this.db == null) {
      throw new Error("Datastore needs to be opened.");
    }
    let val;
    try {
      val = await this.db.get(this.location, key.toString());
    } catch (err) {
      throw new GetFailedError(String(err));
    }
    if (val === void 0) {
      throw new NotFoundError();
    }
    return val;
  }
  async has(key) {
    if (this.db == null) {
      throw new Error("Datastore needs to be opened.");
    }
    try {
      return Boolean(await this.db.getKey(this.location, key.toString()));
    } catch (err) {
      throw new GetFailedError(String(err));
    }
  }
  async delete(key) {
    if (this.db == null) {
      throw new Error("Datastore needs to be opened.");
    }
    try {
      await this.db.delete(this.location, key.toString());
    } catch (err) {
      throw new DeleteFailedError(String(err));
    }
  }
  batch() {
    const puts = [];
    const dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async () => {
        if (this.db == null) {
          throw new Error("Datastore needs to be opened.");
        }
        const tx = this.db.transaction(this.location, "readwrite");
        try {
          const ops = puts.filter(({ key }) => {
            return dels.find((delKey) => delKey.toString() === key.toString()) == null;
          }).map((put) => {
            return async () => {
              await tx.store.put(put.value, put.key.toString());
            };
          }).concat(dels.map((key) => {
            return async () => {
              await tx.store.delete(key.toString());
            };
          })).concat(async () => {
            await tx.done;
          });
          await Promise.all(ops.map(async (op) => {
            await op();
          }));
        } catch {
          tx.abort();
        }
      }
    };
  }
  async *query(q2) {
    let it = __privateMethod(this, _IDBDatastore_instances, queryIt_fn).call(this, q2, (key, value) => {
      return { key, value };
    });
    if (Array.isArray(q2.filters)) {
      it = q2.filters.reduce((it2, f2) => filter(it2, f2), it);
    }
    if (Array.isArray(q2.orders)) {
      it = q2.orders.reduce((it2, f2) => sort(it2, f2), it);
    }
    yield* it;
  }
  async *queryKeys(q2) {
    let it = __privateMethod(this, _IDBDatastore_instances, queryIt_fn).call(this, q2, (key) => key);
    if (Array.isArray(q2.filters)) {
      it = q2.filters.reduce((it2, f2) => filter(it2, f2), it);
    }
    if (Array.isArray(q2.orders)) {
      it = q2.orders.reduce((it2, f2) => sort(it2, f2), it);
    }
    yield* it;
  }
  async destroy() {
    await deleteDB(this.location);
  }
}
_IDBDatastore_instances = new WeakSet();
queryIt_fn = async function* (q2, transform) {
  if (this.db == null) {
    throw new Error("Datastore needs to be opened.");
  }
  let yielded = 0;
  let index2 = -1;
  for (const key of await this.db.getAllKeys(this.location)) {
    if (q2.prefix != null && !key.toString().startsWith(q2.prefix)) {
      continue;
    }
    if (q2.limit != null && yielded === q2.limit) {
      return;
    }
    index2++;
    if (q2.offset != null && index2 < q2.offset) {
      continue;
    }
    const k = new Key(key.toString());
    let value;
    try {
      value = await this.get(k);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
      continue;
    }
    if (value == null) {
      continue;
    }
    yield transform(k, value);
    yielded++;
  }
};
const contentRoutingSymbol = Symbol.for("@libp2p/content-routing");
const peerIdSymbol = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return other != null && Boolean(other[peerIdSymbol]);
}
const peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");
let AbortError$3 = (_b = class extends Error {
  constructor(message2 = "The operation was aborted") {
    super(message2);
    __publicField(this, "code");
    __publicField(this, "type");
    this.name = "AbortError";
    this.code = _b.code;
    this.type = _b.type;
  }
}, __publicField(_b, "code", "ABORT_ERR"), __publicField(_b, "type", "aborted"), _b);
class CodeError extends Error {
  constructor(message2, code2, props) {
    super(message2);
    __publicField(this, "code");
    __publicField(this, "props");
    this.code = code2;
    this.name = (props == null ? void 0 : props.name) ?? "CodeError";
    this.props = props ?? {};
  }
}
function setMaxListeners$1() {
}
const setMaxListeners = (n, ...eventTargets) => {
  try {
    setMaxListeners$1(n, ...eventTargets);
  } catch {
  }
};
class TypedEventEmitter extends EventTarget {
  constructor() {
    super();
    __privateAdd(this, _listeners, /* @__PURE__ */ new Map());
    setMaxListeners(Infinity, this);
  }
  listenerCount(type) {
    const listeners2 = __privateGet(this, _listeners).get(type);
    if (listeners2 == null) {
      return 0;
    }
    return listeners2.length;
  }
  addEventListener(type, listener, options2) {
    super.addEventListener(type, listener, options2);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      list = [];
      __privateGet(this, _listeners).set(type, list);
    }
    list.push({
      callback: listener,
      once: (options2 !== true && options2 !== false && (options2 == null ? void 0 : options2.once)) ?? false
    });
  }
  removeEventListener(type, listener, options2) {
    super.removeEventListener(type.toString(), listener ?? null, options2);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __privateGet(this, _listeners).set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __privateGet(this, _listeners).get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    __privateGet(this, _listeners).set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail = {}) {
    return this.dispatchEvent(new CustomEvent$1(type, detail));
  }
}
_listeners = new WeakMap();
class CustomEventPolyfill extends Event {
  constructor(message2, data) {
    super(message2, data);
    /** Returns any custom data event was created with. Typically used for synthetic events. */
    __publicField(this, "detail");
    this.detail = data == null ? void 0 : data.detail;
  }
}
const CustomEvent$1 = globalThis.CustomEvent ?? CustomEventPolyfill;
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
async function start(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s2) => {
    if (s2.beforeStart != null) {
      await s2.beforeStart();
    }
  }));
  await Promise.all(startables.map(async (s2) => {
    await s2.start();
  }));
  await Promise.all(startables.map(async (s2) => {
    if (s2.afterStart != null) {
      await s2.afterStart();
    }
  }));
}
async function stop(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s2) => {
    if (s2.beforeStop != null) {
      await s2.beforeStop();
    }
  }));
  await Promise.all(startables.map(async (s2) => {
    await s2.stop();
  }));
  await Promise.all(startables.map(async (s2) => {
    if (s2.afterStop != null) {
      await s2.afterStop();
    }
  }));
}
function anySignal(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if ((signal2 == null ? void 0 : signal2.removeEventListener) != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if ((signal2 == null ? void 0 : signal2.aborted) === true) {
      onAbort();
      break;
    }
    if ((signal2 == null ? void 0 : signal2.addEventListener) != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if ((signal2 == null ? void 0 : signal2.removeEventListener) != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}
let AbortError$2 = class AbortError3 extends Error {
  constructor(message2, code2) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.name = "AbortError";
    this.code = code2 ?? "ABORT_ERR";
  }
};
async function raceEvent(emitter, eventName, signal, opts) {
  const error = new AbortError$2(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode);
  if ((signal == null ? void 0 : signal.aborted) === true) {
    return Promise.reject(error);
  }
  return new Promise((resolve2, reject) => {
    function removeListeners() {
      signal == null ? void 0 : signal.removeEventListener("abort", abortListener);
      emitter.removeEventListener(eventName, eventListener);
      if ((opts == null ? void 0 : opts.errorEvent) != null) {
        emitter.removeEventListener(opts.errorEvent, errorEventListener);
      }
    }
    const eventListener = (evt) => {
      var _a3;
      try {
        if (((_a3 = opts == null ? void 0 : opts.filter) == null ? void 0 : _a3.call(opts, evt)) === false) {
          return;
        }
      } catch (err) {
        removeListeners();
        reject(err);
        return;
      }
      removeListeners();
      resolve2(evt);
    };
    const errorEventListener = (evt) => {
      removeListeners();
      reject(evt.detail);
    };
    const abortListener = () => {
      removeListeners();
      reject(error);
    };
    signal == null ? void 0 : signal.addEventListener("abort", abortListener);
    emitter.addEventListener(eventName, eventListener);
    if ((opts == null ? void 0 : opts.errorEvent) != null) {
      emitter.addEventListener(opts.errorEvent, errorEventListener);
    }
  });
}
let AbortError$1 = class AbortError4 extends Error {
  constructor(message2, code2, name2) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.name = name2 ?? "AbortError";
    this.code = code2 ?? "ABORT_ERR";
  }
};
async function raceSignal(promise, signal, opts) {
  if (signal == null) {
    return promise;
  }
  if (signal.aborted) {
    return Promise.reject(new AbortError$1(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode, opts == null ? void 0 : opts.errorName));
  }
  let listener;
  const error = new AbortError$1(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode, opts == null ? void 0 : opts.errorName);
  try {
    return await Promise.race([
      promise,
      new Promise((resolve2, reject) => {
        listener = () => {
          reject(error);
        };
        signal.addEventListener("abort", listener);
      })
    ]);
  } finally {
    if (listener != null) {
      signal.removeEventListener("abort", listener);
    }
  }
}
class JobRecipient {
  constructor(signal) {
    __publicField(this, "deferred");
    __publicField(this, "signal");
    var _a3;
    this.signal = signal;
    this.deferred = pDefer();
    this.onAbort = this.onAbort.bind(this);
    (_a3 = this.signal) == null ? void 0 : _a3.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    var _a3;
    this.deferred.reject(((_a3 = this.signal) == null ? void 0 : _a3.reason) ?? new AbortError$3());
  }
  cleanup() {
    var _a3;
    (_a3 = this.signal) == null ? void 0 : _a3.removeEventListener("abort", this.onAbort);
  }
}
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
class Job {
  constructor(fn, options2) {
    __publicField(this, "id");
    __publicField(this, "fn");
    __publicField(this, "options");
    __publicField(this, "recipients");
    __publicField(this, "status");
    __publicField(this, "timeline");
    __publicField(this, "controller");
    this.id = randomId();
    this.status = "queued";
    this.fn = fn;
    this.options = options2;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      var _a3;
      return acc && ((_a3 = curr.signal) == null ? void 0 : _a3.aborted) === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError$3());
      this.cleanup();
    }
  }
  async join(options2 = {}) {
    var _a3;
    const recipient = new JobRecipient(options2.signal);
    this.recipients.push(recipient);
    (_a3 = options2.signal) == null ? void 0 : _a3.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      var _a3;
      recipient.cleanup();
      (_a3 = recipient.signal) == null ? void 0 : _a3.removeEventListener("abort", this.onAbort);
    });
  }
}
let Queue$1 = class Queue extends TypedEventEmitter {
  constructor(init = {}) {
    var _a3;
    super();
    __publicField(this, "concurrency");
    __publicField(this, "queue");
    __publicField(this, "pending");
    __publicField(this, "sort");
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    if (init.metricName != null) {
      (_a3 = init.metrics) == null ? void 0 : _a3.registerMetricGroup(init.metricName, {
        calculate: () => {
          return {
            size: this.queue.length,
            running: this.pending,
            queued: this.queue.length - this.pending
          };
        }
      });
    }
    this.sort = init.sort;
    this.queue = [];
  }
  tryToStartAnother() {
    if (this.size === 0) {
      queueMicrotask(() => {
        this.safeDispatchEvent("empty");
      });
      if (this.running === 0) {
        queueMicrotask(() => {
          this.safeDispatchEvent("idle");
        });
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
        this.pending--;
        this.tryToStartAnother();
        this.safeDispatchEvent("next");
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options2) {
    var _a3;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    const job = new Job(fn, options2);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    this.tryToStartAnother();
    return job.join(options2).then((result) => {
      this.safeDispatchEvent("completed", { detail: result });
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("error", { detail: err });
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError$3());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options2) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options2 == null ? void 0 : options2.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options2) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options2 == null ? void 0 : options2.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options2) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options2 == null ? void 0 : options2.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options2) {
    var _a3, _b2, _c2;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail);
      }
    };
    const onQueueError = (evt) => {
      cleanup(evt.detail);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new CodeError("Queue aborted", "ERR_QUEUE_ABORTED"));
    };
    this.addEventListener("completed", onQueueJobComplete);
    this.addEventListener("error", onQueueError);
    this.addEventListener("idle", onQueueIdle);
    (_b2 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _b2.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("completed", onQueueJobComplete);
      this.removeEventListener("error", onQueueError);
      this.removeEventListener("idle", onQueueIdle);
      (_c2 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _c2.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};
class PeerQueue extends Queue$1 {
  has(peerId2) {
    return this.find(peerId2) != null;
  }
  find(peerId2) {
    return this.queue.find((job) => {
      return peerId2.equals(job.options.peerId);
    });
  }
}
const inspect$2 = Symbol.for("nodejs.util.inspect.custom");
const baseDecoder = Object.values(bases).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases.identity.decoder);
const LIBP2P_KEY_CODE = 114;
const MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
const MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
class PeerIdImpl {
  constructor(init) {
    __publicField(this, "type");
    __publicField(this, "multihash");
    __publicField(this, "privateKey");
    __publicField(this, "publicKey");
    __publicField(this, "string");
    __publicField(this, _c, true);
    this.type = init.type;
    this.multihash = init.multihash;
    this.privateKey = init.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  // return self-describing String representation
  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  /**
   * Returns Multiaddr as a JSON string
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Checks the equality of `this` peer against a given PeerId
   */
  equals(id2) {
    var _a3;
    if (id2 == null) {
      return false;
    }
    if (id2 instanceof Uint8Array) {
      return equals(this.multihash.bytes, id2);
    } else if (typeof id2 === "string") {
      return peerIdFromString(id2).equals(this);
    } else if (((_a3 = id2 == null ? void 0 : id2.multihash) == null ? void 0 : _a3.bytes) != null) {
      return equals(this.multihash.bytes, id2.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
  /**
   * Returns PeerId as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```TypeScript
   * import { peerIdFromString } from '@libp2p/peer-id'
   *
   * console.info(peerIdFromString('QmFoo'))
   * // 'PeerId(QmFoo)'
   * ```
   */
  [(_c = peerIdSymbol, inspect$2)]() {
    return `PeerId(${this.toString()})`;
  }
}
class RSAPeerIdImpl extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "RSA" });
    __publicField(this, "type", "RSA");
    __publicField(this, "publicKey");
    this.publicKey = init.publicKey;
  }
}
class Ed25519PeerIdImpl extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    __publicField(this, "type", "Ed25519");
    __publicField(this, "publicKey");
    this.publicKey = init.multihash.digest;
  }
}
class Secp256k1PeerIdImpl extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    __publicField(this, "type", "secp256k1");
    __publicField(this, "publicKey");
    this.publicKey = init.multihash.digest;
  }
}
const TRANSPORT_IPFS_GATEWAY_HTTP_CODE$1 = 2336;
class URLPeerIdImpl {
  constructor(url) {
    __publicField(this, "type", "url");
    __publicField(this, "multihash");
    __publicField(this, "privateKey");
    __publicField(this, "publicKey");
    __publicField(this, "url");
    __publicField(this, _d, true);
    this.url = url.toString();
    this.multihash = identity.digest(fromString$1(this.url));
  }
  [(_e = inspect$2, _d = peerIdSymbol, _e)]() {
    return `PeerId(${this.url})`;
  }
  toString() {
    return this.toCID().toString();
  }
  toCID() {
    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE$1, this.multihash);
  }
  toBytes() {
    return this.toCID().bytes;
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString$2(other);
    }
    return other.toString() === this.toString();
  }
}
function peerIdFromString(str, decoder) {
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode$d(base58btc.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf2) {
  try {
    const multihash = decode$d(buf2);
    if (multihash.code === identity.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha256$1.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID.decode(buf2));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
  if ((cid == null ? void 0 : cid.multihash) == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE$1) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE$1) {
    const url = toString$2(cid.multihash.digest);
    return new URLPeerIdImpl(new URL(url));
  }
  const multihash = cid.multihash;
  if (multihash.code === sha256$1.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}
async function peerIdFromKeys(publicKey, privateKey) {
  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
    return new Ed25519PeerIdImpl({ multihash: create$2(identity.code, publicKey), privateKey });
  }
  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
    return new Secp256k1PeerIdImpl({ multihash: create$2(identity.code, publicKey), privateKey });
  }
  return new RSAPeerIdImpl({ multihash: await sha256$1.digest(publicKey), publicKey, privateKey });
}
const webcrypto = {
  get(win = globalThis) {
    const nativeCrypto = win.crypto;
    if ((nativeCrypto == null ? void 0 : nativeCrypto.subtle) == null) {
      throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
    }
    return nativeCrypto;
  }
};
function isPromise$1(thing) {
  if (thing == null) {
    return false;
  }
  return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
}
function number$1(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function isBytes$1(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes$1(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(h2.outputLen);
  number$1(h2.blockLen);
}
function exists$1(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
const crypto$1 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word2, shift) => word2 << 32 - shift | word2 >>> shift;
new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
const nextTick = async () => {
};
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes$1(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes$1(data) {
  if (typeof data === "string")
    data = utf8ToBytes$1(data);
  bytes(data);
  return data;
}
function concatBytes$1(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    bytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
const toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes$1(bytesLength = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues === "function") {
    return crypto$1.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
const Chi = (a, b, c) => a & b ^ ~a & c;
const Maj = (a, b, c) => a & b ^ a & c ^ b & c;
class HashMD extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists$1(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes$1(data);
    const len2 = data.length;
    for (let pos = 0; pos < len2; ) {
      const take2 = Math.min(blockLen - this.pos, len2 - pos);
      if (take2 === blockLen) {
        const dataView2 = createView(data);
        for (; blockLen <= len2 - pos; pos += blockLen)
          this.process(dataView2, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists$1(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView(out);
    const len2 = this.outputLen;
    if (len2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len2 / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length: length2, finished, destroyed, pos } = this;
    to.length = length2;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length2 % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h2, l];
  }
  return [Ah, Al];
}
const toBig = (h2, l) => BigInt(h2 >>> 0) << _32n | BigInt(l >>> 0);
const shrSH = (h2, _l2, s2) => h2 >>> s2;
const shrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
const rotrSH = (h2, l, s2) => h2 >>> s2 | l << 32 - s2;
const rotrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
const rotrBH = (h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32;
const rotrBL = (h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2;
const rotr32H = (_h2, l) => l;
const rotr32L = (h2, _l2) => h2;
const rotlSH = (h2, l, s2) => h2 << s2 | l >>> 32 - s2;
const rotlSL = (h2, l, s2) => l << s2 | h2 >>> 32 - s2;
const rotlBH = (h2, l, s2) => l << s2 - 32 | h2 >>> 64 - s2;
const rotlBL = (h2, l, s2) => h2 << s2 - 32 | l >>> 64 - s2;
function add(Ah, Al, Bh, Bl2) {
  const l = (Al >>> 0) + (Bl2 >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
const add3L = (Al, Bl2, Cl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl2, Cl, Dl) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl2, Cl, Dl, El) => (Al >>> 0) + (Bl2 >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
const u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends HashMD {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl2 | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl: Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl2 ^ Al & Cl ^ Bl2 & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl2 | 0;
      Bh = Ah | 0;
      Bl2 = Al | 0;
      const All = u64.add3L(T1l, sigma0l, MAJl);
      Ah = u64.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl2 } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl2, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = /* @__PURE__ */ BigInt(0);
const _1n$6 = /* @__PURE__ */ BigInt(1);
const _2n$4 = /* @__PURE__ */ BigInt(2);
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(`${title} must be valid boolean, got "${value}".`);
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  abytes(bytes2);
  let hex = "";
  for (let i = 0; i < bytes2.length; i++) {
    hex += hexes[bytes2[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes(bytes2);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n, len2) {
  return hexToBytes(n.toString(16).padStart(len2 * 2, "0"));
}
function numberToBytesLE(n, len2) {
  return numberToBytesBE(n, len2).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len2 = res.length;
  if (typeof expectedLength === "number" && len2 !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len2}`);
  return res;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
const isPosBig = (n) => typeof n === "bigint" && _0n$4 <= n;
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);
}
function bitLen(n) {
  let len2;
  for (len2 = 0; n > _0n$4; n >>= _1n$6, len2 += 1)
    ;
  return len2;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n$6;
}
function bitSet(n, pos, value) {
  return n | (value ? _1n$6 : _0n$4) << BigInt(pos);
}
const bitMask = (n) => (_2n$4 << BigInt(n - 1)) - _1n$6;
const u8n = (data) => new Uint8Array(data);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h2 = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h2(u8fr([0]), seed);
    v = h2();
    if (seed.length === 0)
      return;
    k = h2(u8fr([1]), seed);
    v = h2();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len2 = 0;
    const out = [];
    while (len2 < qByteLen) {
      v = h2();
      const sl = v.slice();
      out.push(sl);
      len2 += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
const notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(fn) {
  const map2 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map2.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map2.set(arg, computed);
    return computed;
  };
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange,
  abool,
  abytes,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  inRange,
  isBytes,
  memoized,
  notImplemented,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$5 = BigInt(1), _2n$3 = BigInt(2), _3n$1 = BigInt(3);
const _4n = BigInt(4), _5n$1 = BigInt(5), _8n$2 = BigInt(8);
BigInt(9);
BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n$3 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n$3 || power < _0n$3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n$5)
    return _0n$3;
  let res = _1n$5;
  while (power > _0n$3) {
    if (power & _1n$5)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n$5;
  }
  return res;
}
function pow2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$3 || modulo <= _0n$3) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b = modulo;
  let x2 = _0n$3, u = _1n$5;
  while (a !== _0n$3) {
    const q2 = b / a;
    const r = b % a;
    const m2 = x2 - u * q2;
    b = a, a = r, x2 = u, u = m2;
  }
  const gcd = b;
  if (gcd !== _1n$5)
    throw new Error("invert: does not exist");
  return mod(x2, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n$5) / _2n$3;
  let Q, S, Z;
  for (Q = P - _1n$5, S = 0; Q % _2n$3 === _0n$3; Q /= _2n$3, S++)
    ;
  for (Z = _2n$3; Z < P && pow(Z, legendreC, P) !== P - _1n$5; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n$5) / _4n;
    return function tonelliFast(Fp2, n) {
      const root2 = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  const Q1div2 = (Q + _1n$5) / _2n$3;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g2 = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x2 = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m2 = 1;
      for (let t2 = Fp2.sqr(b); m2 < r; m2++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge = Fp2.pow(g2, _1n$5 << BigInt(r - m2 - 1));
      g2 = Fp2.sqr(ge);
      x2 = Fp2.mul(x2, ge);
      b = Fp2.mul(b, g2);
      r = m2;
    }
    return x2;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n$1) {
    const p1div4 = (P + _1n$5) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root2 = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root2), n))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  if (P % _8n$2 === _5n$1) {
    const c1 = (P - _5n$1) / _8n$2;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n$3);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n$3), v);
      const root2 = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root2), n))
        throw new Error("Cannot find square root");
      return root2;
    };
  }
  return tonelliShanks(P);
}
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$5) === _1n$5;
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n$3)
    throw new Error("Expected power > 0");
  if (power === _0n$3)
    return f2.ONE;
  if (power === _1n$5)
    return num;
  let p = f2.ONE;
  let d2 = num;
  while (power > _0n$3) {
    if (power & _1n$5)
      p = f2.mul(p, d2);
    d2 = f2.sqr(d2);
    power >>= _1n$5;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE = false, redef = {}) {
  if (ORDER <= _0n$3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$3,
    ONE: _1n$5,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n$3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$3,
    isOdd: (num) => (num & _1n$5) === _1n$5,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f2, n)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length2 = getFieldBytesLength(fieldOrder);
  return length2 + Math.ceil(length2 / 2);
}
function mapHashToField(key, fieldOrder, isLE = false) {
  const len2 = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len2 < 16 || len2 < minLen || len2 > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len2}`);
  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n$5) + _1n$5;
  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0);
const _1n$4 = BigInt(1);
const pointPrecomputes = /* @__PURE__ */ new WeakMap();
const pointWindowSizes = /* @__PURE__ */ new WeakMap();
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const validateW = (W) => {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
      throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);
  };
  const opts = (W) => {
    validateW(W);
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d2 = elm;
      while (n > _0n$2) {
        if (n & _1n$4)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n$4;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f2 = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n$4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P, n, transform) {
      const W = pointWindowSizes.get(P) || 1;
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes.set(P, transform(comp));
      }
      return this.wNAF(W, comp, n);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW(W);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0), _1n$3 = BigInt(1), _2n$2 = BigInt(2), _8n$1 = BigInt(8);
const VERIFY_DEFAULT = { zip215: true };
function validateOpts$1(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts$1(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n$2 << BigInt(nByteLength * 8) - _1n$3;
  const modP = Fp2.create;
  const uvRatio2 = CURVE.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp2.sqrt(u * Fp2.inv(v)) };
    } catch (e) {
      return { isValid: false, value: _0n$1 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title, n) {
    aInRange("coordinate " + title, n, _0n$1, MASK);
  }
  function assertPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x2, ey: y2, ez: z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n$1 : Fp2.inv(z);
    const ax = modP(x2 * iz);
    const ay = modP(y2 * iz);
    const zz = modP(z * iz);
    if (is0)
      return { x: _0n$1, y: _1n$3 };
    if (zz !== _1n$3)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d: d2 } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z, et: T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point {
    constructor(ex, ey, ez, et) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez);
      aCoordinate("t", et);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point)
        throw new Error("extended point not allowed");
      const { x: x2, y: y2 } = p || {};
      aCoordinate("x", x2);
      aCoordinate("y", y2);
      return new Point(x2, y2, _1n$3, modP(x2 * y2));
    }
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.ez));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      assertPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n$2 * modP(Z1 * Z1));
      const D = modP(a * A);
      const x1y1 = X1 + Y1;
      const E2 = modP(modP(x1y1 * x1y1) - A - B);
      const G3 = D + B;
      const F = G3 - C;
      const H = D - B;
      const X3 = modP(E2 * F);
      const Y3 = modP(G3 * H);
      const T3 = modP(E2 * H);
      const Z3 = modP(F * G3);
      return new Point(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      assertPoint(other);
      const { a, d: d2 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      if (a === BigInt(-1)) {
        const A2 = modP((Y1 - X1) * (Y2 + X2));
        const B2 = modP((Y1 + X1) * (Y2 - X2));
        const F2 = modP(B2 - A2);
        if (F2 === _0n$1)
          return this.double();
        const C2 = modP(Z1 * _2n$2 * T2);
        const D2 = modP(T1 * _2n$2 * Z2);
        const E3 = D2 + C2;
        const G4 = B2 + A2;
        const H2 = D2 - C2;
        const X32 = modP(E3 * F2);
        const Y32 = modP(G4 * H2);
        const T32 = modP(E3 * H2);
        const Z32 = modP(F2 * G4);
        return new Point(X32, Y32, Z32, T32);
      }
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d2 * T2);
      const D = modP(Z1 * Z2);
      const E2 = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D - C;
      const G3 = D + C;
      const H = modP(B - a * A);
      const X3 = modP(E2 * F);
      const Y3 = modP(G3 * H);
      const T3 = modP(E2 * H);
      const Z3 = modP(F * G3);
      return new Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n = scalar;
      aInRange("scalar", n, _1n$3, CURVE_ORDER);
      const { p, f: f2 } = this.wNAF(n);
      return Point.normalizeZ([p, f2])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(scalar) {
      const n = scalar;
      aInRange("scalar", n, _0n$1, CURVE_ORDER);
      if (n === _0n$1)
        return I;
      if (this.equals(I) || n === _1n$3)
        return this;
      if (this.equals(G2))
        return this.wNAF(n).p;
      return wnaf.unsafeLadder(this, n);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n$3)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d: d2, a } = CURVE;
      const len2 = Fp2.BYTES;
      hex = ensureBytes("pointHex", hex, len2);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len2 - 1];
      normed[len2 - 1] = lastByte & ~128;
      const y2 = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp2.ORDER;
      aInRange("pointHex.y", y2, _0n$1, max);
      const y22 = modP(y2 * y2);
      const u = modP(y22 - _1n$3);
      const v = modP(d2 * y22 - a);
      let { isValid: isValid2, value: x2 } = uvRatio2(u, v);
      if (!isValid2)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x2 & _1n$3) === _1n$3;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x2 === _0n$1 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x2 = modP(-x2);
      return Point.fromAffine({ x: x2, y: y2 });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x: x2, y: y2 } = this.toAffine();
      const bytes2 = numberToBytesLE(y2, Fp2.BYTES);
      bytes2[bytes2.length - 1] |= x2 & _1n$3 ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n$3, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n$1, _1n$3, _1n$3, _0n$1);
  const { BASE: G2, ZERO: I } = Point;
  const wnaf = wNAF(Point, nByteLength * 8);
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function modN_LE(hash2) {
    return modN(bytesToNumberLE(hash2));
  }
  function getExtendedPublicKey(key) {
    const len2 = nByteLength;
    key = ensureBytes("private key", key, len2);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len2);
    const head = adjustScalarBytes2(hashed.slice(0, len2));
    const prefix = hashed.slice(len2, 2 * len2);
    const scalar = modN_LE(head);
    const point = G2.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign2(msg, privKey, options2 = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options2.context, prefix, msg);
    const R = G2.multiply(r).toRawBytes();
    const k = hashDomainToScalar(options2.context, R, pointBytes, msg);
    const s2 = modN(r + k * scalar);
    aInRange("signature.s", s2, _0n$1, CURVE_ORDER);
    const res = concatBytes(R, numberToBytesLE(s2, Fp2.BYTES));
    return ensureBytes("result", res, nByteLength * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options2 = verifyOpts) {
    const { context, zip215 } = options2;
    const len2 = Fp2.BYTES;
    sig = ensureBytes("signature", sig, 2 * len2);
    msg = ensureBytes("message", msg);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s2 = bytesToNumberLE(sig.slice(len2, 2 * len2));
    let A, R, SB;
    try {
      A = Point.fromHex(publicKey, zip215);
      R = Point.fromHex(sig.slice(0, len2), zip215);
      SB = G2.multiplyUnsafe(s2);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
  }
  G2._setWindowSize(8);
  const utils = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes2(Fp2.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign: sign2,
    verify,
    ExtendedPoint: Point,
    utils
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const _1n$2 = BigInt(1), _2n$1 = BigInt(2);
BigInt(3);
const _5n = BigInt(5), _8n = BigInt(8);
function ed25519_pow_2_252_3(x2) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P = ED25519_P;
  const x22 = x2 * x2 % P;
  const b2 = x22 * x2 % P;
  const b4 = pow2(b2, _2n$1, P) * b2 % P;
  const b5 = pow2(b4, _1n$2, P) * x2 % P;
  const b10 = pow2(b5, _5n, P) * b5 % P;
  const b20 = pow2(b10, _10n, P) * b10 % P;
  const b40 = pow2(b20, _20n, P) * b20 % P;
  const b80 = pow2(b40, _40n, P) * b40 % P;
  const b160 = pow2(b80, _80n, P) * b80 % P;
  const b240 = pow2(b160, _80n, P) * b80 % P;
  const b250 = pow2(b240, _10n, P) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n$1, P) * x2 % P;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function uvRatio(u, v) {
  const P = ED25519_P;
  const v3 = mod(v * v * v, P);
  const v7 = mod(v3 * v3 * v, P);
  const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x2 = mod(u * v3 * pow3, P);
  const vx2 = mod(v * x2 * x2, P);
  const root1 = x2;
  const root2 = mod(x2 * ED25519_SQRT_M1, P);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
  if (useRoot1)
    x2 = root1;
  if (useRoot2 || noRoot)
    x2 = root2;
  if (isNegativeLE(x2, P))
    x2 = mod(-x2, P);
  return { isValid: useRoot1 || useRoot2, value: x2 };
}
const Fp$1 = /* @__PURE__ */ (() => Field(ED25519_P, void 0, true))();
const ed25519Defaults = /* @__PURE__ */ (() => ({
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field p over which we'll do calculations; 2n**255n - 19n
  Fp: Fp$1,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: _8n,
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes: randomBytes$1,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
}))();
const ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
const PUBLIC_KEY_BYTE_LENGTH = 32;
const PRIVATE_KEY_BYTE_LENGTH = 64;
const KEYS_BYTE_LENGTH = 32;
function generateKey$2() {
  const privateKeyRaw = ed25519.utils.randomPrivateKey();
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
function generateKeyFromSeed(seed) {
  if (seed.length !== KEYS_BYTE_LENGTH) {
    throw new TypeError('"seed" must be 32 bytes in length.');
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
  }
  const privateKeyRaw = seed;
  const publicKey = ed25519.getPublicKey(privateKeyRaw);
  const privateKey = concatKeys(privateKeyRaw, publicKey);
  return {
    privateKey,
    publicKey
  };
}
function hashAndSign$2(privateKey, msg) {
  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
  return ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
}
function hashAndVerify$2(publicKey, sig, msg) {
  return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
}
function concatKeys(privateKeyRaw, publicKey) {
  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
    privateKey[i] = privateKeyRaw[i];
    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
  }
  return privateKey;
}
const derivedEmptyPasswordKey = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
function create(opts) {
  const algorithm = "AES-GCM";
  let keyLength = 16;
  const nonceLength = 12;
  const digest2 = "SHA-256";
  const saltLength = 16;
  const iterations = 32767;
  const crypto2 = webcrypto.get();
  keyLength *= 8;
  async function encrypt(data, password) {
    const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
    const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString$1(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      } catch {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
      const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
    }
    const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
    return concat$2([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
  }
  async function decrypt(data, password) {
    const salt = data.subarray(0, saltLength);
    const nonce = data.subarray(saltLength, saltLength + nonceLength);
    const ciphertext = data.subarray(saltLength + nonceLength);
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString$1(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
        const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      } catch {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["decrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest2 } };
      const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
    }
    const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
    return new Uint8Array(plaintext);
  }
  const cipher = {
    encrypt,
    decrypt
  };
  return cipher;
}
async function exporter(privateKey, password) {
  const cipher = create();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base64.encode(encryptedKey);
}
var KeyType;
(function(KeyType2) {
  KeyType2["RSA"] = "RSA";
  KeyType2["Ed25519"] = "Ed25519";
  KeyType2["Secp256k1"] = "Secp256k1";
})(KeyType || (KeyType = {}));
var __KeyTypeValues;
(function(__KeyTypeValues2) {
  __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
  __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
  __KeyTypeValues2[__KeyTypeValues2["Secp256k1"] = 2] = "Secp256k1";
})(__KeyTypeValues || (__KeyTypeValues = {}));
(function(KeyType2) {
  KeyType2.codec = () => {
    return enumeration(__KeyTypeValues);
  };
})(KeyType || (KeyType = {}));
var PublicKey;
(function(PublicKey2) {
  let _codec;
  PublicKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          KeyType.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length2) => {
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader);
              break;
            case 2:
              obj.Data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PublicKey2.encode = (obj) => {
    return encodeMessage(obj, PublicKey2.codec());
  };
  PublicKey2.decode = (buf2) => {
    return decodeMessage(buf2, PublicKey2.codec());
  };
})(PublicKey || (PublicKey = {}));
var PrivateKey;
(function(PrivateKey2) {
  let _codec;
  PrivateKey2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.Type != null) {
          w2.uint32(8);
          KeyType.codec().encode(obj.Type, w2);
        }
        if (obj.Data != null) {
          w2.uint32(18);
          w2.bytes(obj.Data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length2) => {
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.Type = KeyType.codec().decode(reader);
              break;
            case 2:
              obj.Data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PrivateKey2.encode = (obj) => {
    return encodeMessage(obj, PrivateKey2.codec());
  };
  PrivateKey2.decode = (buf2) => {
    return decodeMessage(buf2, PrivateKey2.codec());
  };
})(PrivateKey || (PrivateKey = {}));
class Ed25519PublicKey {
  constructor(key) {
    __publicField(this, "_key");
    this._key = ensureKey(key, PUBLIC_KEY_BYTE_LENGTH);
  }
  verify(data, sig) {
    return hashAndVerify$2(this._key, sig, data);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  hash() {
    const p = sha256$1.digest(this.bytes);
    if (isPromise$1(p)) {
      return p.then(({ bytes: bytes2 }) => bytes2);
    }
    return p.bytes;
  }
}
class Ed25519PrivateKey {
  // key       - 64 byte Uint8Array containing private key
  // publicKey - 32 byte Uint8Array containing public key
  constructor(key, publicKey) {
    __publicField(this, "_key");
    __publicField(this, "_publicKey");
    this._key = ensureKey(key, PRIVATE_KEY_BYTE_LENGTH);
    this._publicKey = ensureKey(publicKey, PUBLIC_KEY_BYTE_LENGTH);
  }
  sign(message2) {
    return hashAndSign$2(this._key, message2);
  }
  get public() {
    return new Ed25519PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Ed25519,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const p = sha256$1.digest(this.bytes);
    let bytes2;
    if (isPromise$1(p)) {
      ({ bytes: bytes2 } = await p);
    } else {
      bytes2 = p.bytes;
    }
    return bytes2;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the identity multihash containing its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   *
   * @returns {Promise<string>}
   */
  async id() {
    const encoding = identity.digest(this.public.bytes);
    return base58btc.encode(encoding.bytes).substring(1);
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format = "libp2p-key") {
    if (format === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
}
function unmarshalEd25519PrivateKey(bytes2) {
  if (bytes2.length > PRIVATE_KEY_BYTE_LENGTH) {
    bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH + PUBLIC_KEY_BYTE_LENGTH);
    const privateKeyBytes2 = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
    const publicKeyBytes2 = bytes2.subarray(PRIVATE_KEY_BYTE_LENGTH, bytes2.length);
    return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
  }
  bytes2 = ensureKey(bytes2, PRIVATE_KEY_BYTE_LENGTH);
  const privateKeyBytes = bytes2.subarray(0, PRIVATE_KEY_BYTE_LENGTH);
  const publicKeyBytes = bytes2.subarray(PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
}
function unmarshalEd25519PublicKey(bytes2) {
  bytes2 = ensureKey(bytes2, PUBLIC_KEY_BYTE_LENGTH);
  return new Ed25519PublicKey(bytes2);
}
async function generateKeyPair$2() {
  const { privateKey, publicKey } = generateKey$2();
  return new Ed25519PrivateKey(privateKey, publicKey);
}
async function generateKeyPairFromSeed(seed) {
  const { privateKey, publicKey } = generateKeyFromSeed(seed);
  return new Ed25519PrivateKey(privateKey, publicKey);
}
function ensureKey(key, length2) {
  key = Uint8Array.from(key ?? []);
  if (key.length !== length2) {
    throw new CodeError(`Key must be a Uint8Array of length ${length2}, got ${key.length}`, "ERR_INVALID_KEY_TYPE");
  }
  return key;
}
const Ed25519 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Ed25519PrivateKey,
  Ed25519PublicKey,
  generateKeyPair: generateKeyPair$2,
  generateKeyPairFromSeed,
  unmarshalEd25519PrivateKey,
  unmarshalEd25519PublicKey
}, Symbol.toStringTag, { value: "Module" }));
function randomBytes(length2) {
  if (isNaN(length2) || length2 <= 0) {
    throw new CodeError("random bytes length must be a Number bigger than 0", "ERR_INVALID_LENGTH");
  }
  return randomBytes$1(length2);
}
class HMAC extends Hash {
  constructor(hash$1, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash$1);
    const key = toBytes$1(_key);
    this.iHash = hash$1.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash$1.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash$1.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf2) {
    exists$1(this);
    this.iHash.update(buf2);
    return this;
  }
  digestInto(out) {
    exists$1(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash2, key, message2) => new HMAC(hash2, key).update(message2).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);
function pbkdf2Init(hash$1, _password, _salt, _opts) {
  hash(hash$1);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number$1(c);
  number$1(dkLen);
  number$1(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes$1(_password);
  const salt = toBytes$1(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash$1, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
async function pbkdf2Async(hash2, password, salt, opts) {
  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    await asyncLoop(c - 1, asyncTick, () => {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    });
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
/*!
 * MIT License
 * 
 * Copyright (c) 2017-2022 Peculiar Ventures, LLC
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */
const ARRAY_BUFFER_NAME = "[object ArrayBuffer]";
class BufferSourceConverter {
  static isArrayBuffer(data) {
    return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;
  }
  static toArrayBuffer(data) {
    if (this.isArrayBuffer(data)) {
      return data;
    }
    if (data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return this.toUint8Array(data.buffer).slice(data.byteOffset, data.byteOffset + data.byteLength).buffer;
  }
  static toUint8Array(data) {
    return this.toView(data, Uint8Array);
  }
  static toView(data, type) {
    if (data.constructor === type) {
      return data;
    }
    if (this.isArrayBuffer(data)) {
      return new type(data);
    }
    if (this.isArrayBufferView(data)) {
      return new type(data.buffer, data.byteOffset, data.byteLength);
    }
    throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
  }
  static isBufferSource(data) {
    return this.isArrayBufferView(data) || this.isArrayBuffer(data);
  }
  static isArrayBufferView(data) {
    return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);
  }
  static isEqual(a, b) {
    const aView = BufferSourceConverter.toUint8Array(a);
    const bView = BufferSourceConverter.toUint8Array(b);
    if (aView.length !== bView.byteLength) {
      return false;
    }
    for (let i = 0; i < aView.length; i++) {
      if (aView[i] !== bView[i]) {
        return false;
      }
    }
    return true;
  }
  static concat(...args) {
    let buffers;
    if (Array.isArray(args[0]) && !(args[1] instanceof Function)) {
      buffers = args[0];
    } else if (Array.isArray(args[0]) && args[1] instanceof Function) {
      buffers = args[0];
    } else {
      if (args[args.length - 1] instanceof Function) {
        buffers = args.slice(0, args.length - 1);
      } else {
        buffers = args;
      }
    }
    let size = 0;
    for (const buffer2 of buffers) {
      size += buffer2.byteLength;
    }
    const res = new Uint8Array(size);
    let offset = 0;
    for (const buffer2 of buffers) {
      const view = this.toUint8Array(buffer2);
      res.set(view, offset);
      offset += view.length;
    }
    if (args[args.length - 1] instanceof Function) {
      return this.toView(res, args[args.length - 1]);
    }
    return res.buffer;
  }
}
const STRING_TYPE = "string";
const HEX_REGEX = /^[0-9a-f]+$/i;
const BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
const BASE64URL_REGEX = /^[a-zA-Z0-9-_]+$/;
class Utf8Converter {
  static fromString(text) {
    const s2 = unescape(encodeURIComponent(text));
    const uintArray = new Uint8Array(s2.length);
    for (let i = 0; i < s2.length; i++) {
      uintArray[i] = s2.charCodeAt(i);
    }
    return uintArray.buffer;
  }
  static toString(buffer2) {
    const buf2 = BufferSourceConverter.toUint8Array(buffer2);
    let encodedString = "";
    for (let i = 0; i < buf2.length; i++) {
      encodedString += String.fromCharCode(buf2[i]);
    }
    const decodedString = decodeURIComponent(escape(encodedString));
    return decodedString;
  }
}
class Utf16Converter {
  static toString(buffer2, littleEndian = false) {
    const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer2);
    const dataView2 = new DataView(arrayBuffer);
    let res = "";
    for (let i = 0; i < arrayBuffer.byteLength; i += 2) {
      const code2 = dataView2.getUint16(i, littleEndian);
      res += String.fromCharCode(code2);
    }
    return res;
  }
  static fromString(text, littleEndian = false) {
    const res = new ArrayBuffer(text.length * 2);
    const dataView2 = new DataView(res);
    for (let i = 0; i < text.length; i++) {
      dataView2.setUint16(i * 2, text.charCodeAt(i), littleEndian);
    }
    return res;
  }
}
class Convert {
  static isHex(data) {
    return typeof data === STRING_TYPE && HEX_REGEX.test(data);
  }
  static isBase64(data) {
    return typeof data === STRING_TYPE && BASE64_REGEX.test(data);
  }
  static isBase64Url(data) {
    return typeof data === STRING_TYPE && BASE64URL_REGEX.test(data);
  }
  static ToString(buffer2, enc = "utf8") {
    const buf2 = BufferSourceConverter.toUint8Array(buffer2);
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.ToUtf8String(buf2);
      case "binary":
        return this.ToBinary(buf2);
      case "hex":
        return this.ToHex(buf2);
      case "base64":
        return this.ToBase64(buf2);
      case "base64url":
        return this.ToBase64Url(buf2);
      case "utf16le":
        return Utf16Converter.toString(buf2, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buf2);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static FromString(str, enc = "utf8") {
    if (!str) {
      return new ArrayBuffer(0);
    }
    switch (enc.toLowerCase()) {
      case "utf8":
        return this.FromUtf8String(str);
      case "binary":
        return this.FromBinary(str);
      case "hex":
        return this.FromHex(str);
      case "base64":
        return this.FromBase64(str);
      case "base64url":
        return this.FromBase64Url(str);
      case "utf16le":
        return Utf16Converter.fromString(str, true);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(str);
      default:
        throw new Error(`Unknown type of encoding '${enc}'`);
    }
  }
  static ToBase64(buffer2) {
    const buf2 = BufferSourceConverter.toUint8Array(buffer2);
    if (typeof btoa !== "undefined") {
      const binary = this.ToString(buf2, "binary");
      return btoa(binary);
    } else {
      return Buffer2.from(buf2).toString("base64");
    }
  }
  static FromBase64(base642) {
    const formatted = this.formatString(base642);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!Convert.isBase64(formatted)) {
      throw new TypeError("Argument 'base64Text' is not Base64 encoded");
    }
    if (typeof atob !== "undefined") {
      return this.FromBinary(atob(formatted));
    } else {
      return new Uint8Array(Buffer2.from(formatted, "base64")).buffer;
    }
  }
  static FromBase64Url(base64url2) {
    const formatted = this.formatString(base64url2);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!Convert.isBase64Url(formatted)) {
      throw new TypeError("Argument 'base64url' is not Base64Url encoded");
    }
    return this.FromBase64(this.Base64Padding(formatted.replace(/\-/g, "+").replace(/\_/g, "/")));
  }
  static ToBase64Url(data) {
    return this.ToBase64(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.FromBinary(text);
      case "utf8":
        return Utf8Converter.fromString(text);
      case "utf16":
      case "utf16be":
        return Utf16Converter.fromString(text);
      case "utf16le":
      case "usc2":
        return Utf16Converter.fromString(text, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static ToUtf8String(buffer2, encoding = Convert.DEFAULT_UTF8_ENCODING) {
    switch (encoding) {
      case "ascii":
        return this.ToBinary(buffer2);
      case "utf8":
        return Utf8Converter.toString(buffer2);
      case "utf16":
      case "utf16be":
        return Utf16Converter.toString(buffer2);
      case "utf16le":
      case "usc2":
        return Utf16Converter.toString(buffer2, true);
      default:
        throw new Error(`Unknown type of encoding '${encoding}'`);
    }
  }
  static FromBinary(text) {
    const stringLength = text.length;
    const resultView = new Uint8Array(stringLength);
    for (let i = 0; i < stringLength; i++) {
      resultView[i] = text.charCodeAt(i);
    }
    return resultView.buffer;
  }
  static ToBinary(buffer2) {
    const buf2 = BufferSourceConverter.toUint8Array(buffer2);
    let res = "";
    for (let i = 0; i < buf2.length; i++) {
      res += String.fromCharCode(buf2[i]);
    }
    return res;
  }
  static ToHex(buffer2) {
    const buf2 = BufferSourceConverter.toUint8Array(buffer2);
    let result = "";
    const len2 = buf2.length;
    for (let i = 0; i < len2; i++) {
      const byte = buf2[i];
      if (byte < 16) {
        result += "0";
      }
      result += byte.toString(16);
    }
    return result;
  }
  static FromHex(hexString) {
    let formatted = this.formatString(hexString);
    if (!formatted) {
      return new ArrayBuffer(0);
    }
    if (!Convert.isHex(formatted)) {
      throw new TypeError("Argument 'hexString' is not HEX encoded");
    }
    if (formatted.length % 2) {
      formatted = `0${formatted}`;
    }
    const res = new Uint8Array(formatted.length / 2);
    for (let i = 0; i < formatted.length; i = i + 2) {
      const c = formatted.slice(i, i + 2);
      res[i / 2] = parseInt(c, 16);
    }
    return res.buffer;
  }
  static ToUtf16String(buffer2, littleEndian = false) {
    return Utf16Converter.toString(buffer2, littleEndian);
  }
  static FromUtf16String(text, littleEndian = false) {
    return Utf16Converter.fromString(text, littleEndian);
  }
  static Base64Padding(base642) {
    const padCount = 4 - base642.length % 4;
    if (padCount < 4) {
      for (let i = 0; i < padCount; i++) {
        base642 += "=";
      }
    }
    return base642;
  }
  static formatString(data) {
    return (data === null || data === void 0 ? void 0 : data.replace(/[\n\r\t ]/g, "")) || "";
  }
}
Convert.DEFAULT_UTF8_ENCODING = "utf8";
/*!
 Copyright (c) Peculiar Ventures, LLC
*/
function utilFromBase(inputBuffer, inputBase) {
  let result = 0;
  if (inputBuffer.length === 1) {
    return inputBuffer[0];
  }
  for (let i = inputBuffer.length - 1; i >= 0; i--) {
    result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
  }
  return result;
}
function utilToBase(value, base, reserved = -1) {
  const internalReserved = reserved;
  let internalValue = value;
  let result = 0;
  let biggest = Math.pow(2, base);
  for (let i = 1; i < 8; i++) {
    if (value < biggest) {
      let retBuf;
      if (internalReserved < 0) {
        retBuf = new ArrayBuffer(i);
        result = i;
      } else {
        if (internalReserved < i) {
          return new ArrayBuffer(0);
        }
        retBuf = new ArrayBuffer(internalReserved);
        result = internalReserved;
      }
      const retView = new Uint8Array(retBuf);
      for (let j = i - 1; j >= 0; j--) {
        const basis = Math.pow(2, j * base);
        retView[result - j - 1] = Math.floor(internalValue / basis);
        internalValue -= retView[result - j - 1] * basis;
      }
      return retBuf;
    }
    biggest *= Math.pow(2, base);
  }
  return new ArrayBuffer(0);
}
function utilConcatView(...views) {
  let outputLength = 0;
  let prevLength = 0;
  for (const view of views) {
    outputLength += view.length;
  }
  const retBuf = new ArrayBuffer(outputLength);
  const retView = new Uint8Array(retBuf);
  for (const view of views) {
    retView.set(view, prevLength);
    prevLength += view.length;
  }
  return retView;
}
function utilDecodeTC() {
  const buf2 = new Uint8Array(this.valueHex);
  if (this.valueHex.byteLength >= 2) {
    const condition1 = buf2[0] === 255 && buf2[1] & 128;
    const condition2 = buf2[0] === 0 && (buf2[1] & 128) === 0;
    if (condition1 || condition2) {
      this.warnings.push("Needlessly long format");
    }
  }
  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const bigIntView = new Uint8Array(bigIntBuffer);
  for (let i = 0; i < this.valueHex.byteLength; i++) {
    bigIntView[i] = 0;
  }
  bigIntView[0] = buf2[0] & 128;
  const bigInt = utilFromBase(bigIntView, 8);
  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
  const smallIntView = new Uint8Array(smallIntBuffer);
  for (let j = 0; j < this.valueHex.byteLength; j++) {
    smallIntView[j] = buf2[j];
  }
  smallIntView[0] &= 127;
  const smallInt = utilFromBase(smallIntView, 8);
  return smallInt - bigInt;
}
function utilEncodeTC(value) {
  const modValue = value < 0 ? value * -1 : value;
  let bigInt = 128;
  for (let i = 1; i < 8; i++) {
    if (modValue <= bigInt) {
      if (value < 0) {
        const smallInt = bigInt - modValue;
        const retBuf2 = utilToBase(smallInt, 8, i);
        const retView2 = new Uint8Array(retBuf2);
        retView2[0] |= 128;
        return retBuf2;
      }
      let retBuf = utilToBase(modValue, 8, i);
      let retView = new Uint8Array(retBuf);
      if (retView[0] & 128) {
        const tempBuf = retBuf.slice(0);
        const tempView = new Uint8Array(tempBuf);
        retBuf = new ArrayBuffer(retBuf.byteLength + 1);
        retView = new Uint8Array(retBuf);
        for (let k = 0; k < tempBuf.byteLength; k++) {
          retView[k + 1] = tempView[k];
        }
        retView[0] = 0;
      }
      return retBuf;
    }
    bigInt *= Math.pow(2, 8);
  }
  return new ArrayBuffer(0);
}
function isEqualBuffer(inputBuffer1, inputBuffer2) {
  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {
    return false;
  }
  const view1 = new Uint8Array(inputBuffer1);
  const view2 = new Uint8Array(inputBuffer2);
  for (let i = 0; i < view1.length; i++) {
    if (view1[i] !== view2[i]) {
      return false;
    }
  }
  return true;
}
function padNumber(inputNumber, fullLength) {
  const str = inputNumber.toString(10);
  if (fullLength < str.length) {
    return "";
  }
  const dif = fullLength - str.length;
  const padding = new Array(dif);
  for (let i = 0; i < dif; i++) {
    padding[i] = "0";
  }
  const paddingString = padding.join("");
  return paddingString.concat(str);
}
/*!
 * Copyright (c) 2014, GMO GlobalSign
 * Copyright (c) 2015-2022, Peculiar Ventures
 * All rights reserved.
 * 
 * Author 2014-2019, Yury Strozhevsky
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
function assertBigInt() {
  if (typeof BigInt === "undefined") {
    throw new Error("BigInt is not defined. Your environment doesn't implement BigInt.");
  }
}
function concat(buffers) {
  let outputLength = 0;
  let prevLength = 0;
  for (let i = 0; i < buffers.length; i++) {
    const buffer2 = buffers[i];
    outputLength += buffer2.byteLength;
  }
  const retView = new Uint8Array(outputLength);
  for (let i = 0; i < buffers.length; i++) {
    const buffer2 = buffers[i];
    retView.set(new Uint8Array(buffer2), prevLength);
    prevLength += buffer2.byteLength;
  }
  return retView.buffer;
}
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
  if (!(inputBuffer instanceof Uint8Array)) {
    baseBlock.error = "Wrong parameter: inputBuffer must be 'Uint8Array'";
    return false;
  }
  if (!inputBuffer.byteLength) {
    baseBlock.error = "Wrong parameter: inputBuffer has zero length";
    return false;
  }
  if (inputOffset < 0) {
    baseBlock.error = "Wrong parameter: inputOffset less than zero";
    return false;
  }
  if (inputLength < 0) {
    baseBlock.error = "Wrong parameter: inputLength less than zero";
    return false;
  }
  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
    return false;
  }
  return true;
}
class ViewWriter {
  constructor() {
    this.items = [];
  }
  write(buf2) {
    this.items.push(buf2);
  }
  final() {
    return concat(this.items);
  }
}
const powers2 = [new Uint8Array([1])];
const digitsString = "0123456789";
const EMPTY_STRING = "";
const EMPTY_BUFFER = new ArrayBuffer(0);
const EMPTY_VIEW = new Uint8Array(0);
const END_OF_CONTENT_NAME = "EndOfContent";
const OCTET_STRING_NAME = "OCTET STRING";
const BIT_STRING_NAME = "BIT STRING";
function HexBlock(BaseClass) {
  var _a3;
  return _a3 = class Some extends BaseClass {
    constructor(...args) {
      var _a4;
      super(...args);
      const params = args[0] || {};
      this.isHexOnly = (_a4 = params.isHexOnly) !== null && _a4 !== void 0 ? _a4 : false;
      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;
    }
    get valueHex() {
      return this.valueHexView.slice().buffer;
    }
    set valueHex(value) {
      this.valueHexView = new Uint8Array(value);
    }
    fromBER(inputBuffer, inputOffset, inputLength) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      if (!checkBufferParams(this, view, inputOffset, inputLength)) {
        return -1;
      }
      const endLength = inputOffset + inputLength;
      this.valueHexView = view.subarray(inputOffset, endLength);
      if (!this.valueHexView.length) {
        this.warnings.push("Zero buffer length");
        return inputOffset;
      }
      this.blockLength = inputLength;
      return endLength;
    }
    toBER(sizeOnly = false) {
      if (!this.isHexOnly) {
        this.error = "Flag 'isHexOnly' is not set, abort";
        return EMPTY_BUFFER;
      }
      if (sizeOnly) {
        return new ArrayBuffer(this.valueHexView.byteLength);
      }
      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;
    }
    toJSON() {
      return {
        ...super.toJSON(),
        isHexOnly: this.isHexOnly,
        valueHex: Convert.ToHex(this.valueHexView)
      };
    }
  }, _a3.NAME = "hexBlock", _a3;
}
class LocalBaseBlock {
  constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {
    this.blockLength = blockLength;
    this.error = error;
    this.warnings = warnings;
    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);
  }
  static blockName() {
    return this.NAME;
  }
  get valueBeforeDecode() {
    return this.valueBeforeDecodeView.slice().buffer;
  }
  set valueBeforeDecode(value) {
    this.valueBeforeDecodeView = new Uint8Array(value);
  }
  toJSON() {
    return {
      blockName: this.constructor.NAME,
      blockLength: this.blockLength,
      error: this.error,
      warnings: this.warnings,
      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)
    };
  }
}
LocalBaseBlock.NAME = "baseBlock";
class ValueBlock extends LocalBaseBlock {
  fromBER(inputBuffer, inputOffset, inputLength) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
  toBER(sizeOnly, writer) {
    throw TypeError("User need to make a specific function in a class which extends 'ValueBlock'");
  }
}
ValueBlock.NAME = "valueBlock";
class LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {
  constructor({ idBlock = {} } = {}) {
    var _a3, _b2, _c2, _d2;
    super();
    if (idBlock) {
      this.isHexOnly = (_a3 = idBlock.isHexOnly) !== null && _a3 !== void 0 ? _a3 : false;
      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;
      this.tagClass = (_b2 = idBlock.tagClass) !== null && _b2 !== void 0 ? _b2 : -1;
      this.tagNumber = (_c2 = idBlock.tagNumber) !== null && _c2 !== void 0 ? _c2 : -1;
      this.isConstructed = (_d2 = idBlock.isConstructed) !== null && _d2 !== void 0 ? _d2 : false;
    } else {
      this.tagClass = -1;
      this.tagNumber = -1;
      this.isConstructed = false;
    }
  }
  toBER(sizeOnly = false) {
    let firstOctet = 0;
    switch (this.tagClass) {
      case 1:
        firstOctet |= 0;
        break;
      case 2:
        firstOctet |= 64;
        break;
      case 3:
        firstOctet |= 128;
        break;
      case 4:
        firstOctet |= 192;
        break;
      default:
        this.error = "Unknown tag class";
        return EMPTY_BUFFER;
    }
    if (this.isConstructed)
      firstOctet |= 32;
    if (this.tagNumber < 31 && !this.isHexOnly) {
      const retView2 = new Uint8Array(1);
      if (!sizeOnly) {
        let number2 = this.tagNumber;
        number2 &= 31;
        firstOctet |= number2;
        retView2[0] = firstOctet;
      }
      return retView2.buffer;
    }
    if (!this.isHexOnly) {
      const encodedBuf = utilToBase(this.tagNumber, 7);
      const encodedView = new Uint8Array(encodedBuf);
      const size = encodedBuf.byteLength;
      const retView2 = new Uint8Array(size + 1);
      retView2[0] = firstOctet | 31;
      if (!sizeOnly) {
        for (let i = 0; i < size - 1; i++)
          retView2[i + 1] = encodedView[i] | 128;
        retView2[size] = encodedView[size - 1];
      }
      return retView2.buffer;
    }
    const retView = new Uint8Array(this.valueHexView.byteLength + 1);
    retView[0] = firstOctet | 31;
    if (!sizeOnly) {
      const curView = this.valueHexView;
      for (let i = 0; i < curView.length - 1; i++)
        retView[i + 1] = curView[i] | 128;
      retView[this.valueHexView.byteLength] = curView[curView.length - 1];
    }
    return retView.buffer;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    const tagClassMask = intBuffer[0] & 192;
    switch (tagClassMask) {
      case 0:
        this.tagClass = 1;
        break;
      case 64:
        this.tagClass = 2;
        break;
      case 128:
        this.tagClass = 3;
        break;
      case 192:
        this.tagClass = 4;
        break;
      default:
        this.error = "Unknown tag class";
        return -1;
    }
    this.isConstructed = (intBuffer[0] & 32) === 32;
    this.isHexOnly = false;
    const tagNumberMask = intBuffer[0] & 31;
    if (tagNumberMask !== 31) {
      this.tagNumber = tagNumberMask;
      this.blockLength = 1;
    } else {
      let count2 = 1;
      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);
      let tagNumberBufferMaxLength = 255;
      while (intBuffer[count2] & 128) {
        intTagNumberBuffer[count2 - 1] = intBuffer[count2] & 127;
        count2++;
        if (count2 >= intBuffer.length) {
          this.error = "End of input reached before message was fully decoded";
          return -1;
        }
        if (count2 === tagNumberBufferMaxLength) {
          tagNumberBufferMaxLength += 255;
          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);
          for (let i = 0; i < intTagNumberBuffer.length; i++)
            tempBufferView2[i] = intTagNumberBuffer[i];
          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);
        }
      }
      this.blockLength = count2 + 1;
      intTagNumberBuffer[count2 - 1] = intBuffer[count2] & 127;
      const tempBufferView = new Uint8Array(count2);
      for (let i = 0; i < count2; i++)
        tempBufferView[i] = intTagNumberBuffer[i];
      intTagNumberBuffer = this.valueHexView = new Uint8Array(count2);
      intTagNumberBuffer.set(tempBufferView);
      if (this.blockLength <= 9)
        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);
      else {
        this.isHexOnly = true;
        this.warnings.push("Tag too long, represented as hex-coded");
      }
    }
    if (this.tagClass === 1 && this.isConstructed) {
      switch (this.tagNumber) {
        case 1:
        case 2:
        case 5:
        case 6:
        case 9:
        case 13:
        case 14:
        case 23:
        case 24:
        case 31:
        case 32:
        case 33:
        case 34:
          this.error = "Constructed encoding used for primitive type";
          return -1;
      }
    }
    return inputOffset + this.blockLength;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      tagClass: this.tagClass,
      tagNumber: this.tagNumber,
      isConstructed: this.isConstructed
    };
  }
}
LocalIdentificationBlock.NAME = "identificationBlock";
class LocalLengthBlock extends LocalBaseBlock {
  constructor({ lenBlock = {} } = {}) {
    var _a3, _b2, _c2;
    super();
    this.isIndefiniteForm = (_a3 = lenBlock.isIndefiniteForm) !== null && _a3 !== void 0 ? _a3 : false;
    this.longFormUsed = (_b2 = lenBlock.longFormUsed) !== null && _b2 !== void 0 ? _b2 : false;
    this.length = (_c2 = lenBlock.length) !== null && _c2 !== void 0 ? _c2 : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);
    if (intBuffer.length === 0) {
      this.error = "Zero buffer length";
      return -1;
    }
    if (intBuffer[0] === 255) {
      this.error = "Length block 0xFF is reserved by standard";
      return -1;
    }
    this.isIndefiniteForm = intBuffer[0] === 128;
    if (this.isIndefiniteForm) {
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    this.longFormUsed = !!(intBuffer[0] & 128);
    if (this.longFormUsed === false) {
      this.length = intBuffer[0];
      this.blockLength = 1;
      return inputOffset + this.blockLength;
    }
    const count2 = intBuffer[0] & 127;
    if (count2 > 8) {
      this.error = "Too big integer";
      return -1;
    }
    if (count2 + 1 > intBuffer.length) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    const lenOffset = inputOffset + 1;
    const lengthBufferView = view.subarray(lenOffset, lenOffset + count2);
    if (lengthBufferView[count2 - 1] === 0)
      this.warnings.push("Needlessly long encoded length");
    this.length = utilFromBase(lengthBufferView, 8);
    if (this.longFormUsed && this.length <= 127)
      this.warnings.push("Unnecessary usage of long length form");
    this.blockLength = count2 + 1;
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly = false) {
    let retBuf;
    let retView;
    if (this.length > 127)
      this.longFormUsed = true;
    if (this.isIndefiniteForm) {
      retBuf = new ArrayBuffer(1);
      if (sizeOnly === false) {
        retView = new Uint8Array(retBuf);
        retView[0] = 128;
      }
      return retBuf;
    }
    if (this.longFormUsed) {
      const encodedBuf = utilToBase(this.length, 8);
      if (encodedBuf.byteLength > 127) {
        this.error = "Too big length";
        return EMPTY_BUFFER;
      }
      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);
      if (sizeOnly)
        return retBuf;
      const encodedView = new Uint8Array(encodedBuf);
      retView = new Uint8Array(retBuf);
      retView[0] = encodedBuf.byteLength | 128;
      for (let i = 0; i < encodedBuf.byteLength; i++)
        retView[i + 1] = encodedView[i];
      return retBuf;
    }
    retBuf = new ArrayBuffer(1);
    if (sizeOnly === false) {
      retView = new Uint8Array(retBuf);
      retView[0] = this.length;
    }
    return retBuf;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      longFormUsed: this.longFormUsed,
      length: this.length
    };
  }
}
LocalLengthBlock.NAME = "lengthBlock";
const typeStore = {};
class BaseBlock extends LocalBaseBlock {
  constructor({ name: name2 = EMPTY_STRING, optional: optional2 = false, primitiveSchema, ...parameters } = {}, valueBlockType) {
    super(parameters);
    this.name = name2;
    this.optional = optional2;
    if (primitiveSchema) {
      this.primitiveSchema = primitiveSchema;
    }
    this.idBlock = new LocalIdentificationBlock(parameters);
    this.lenBlock = new LocalLengthBlock(parameters);
    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer2 = writer || new ViewWriter();
    if (!writer) {
      prepareIndefiniteForm(this);
    }
    const idBlockBuf = this.idBlock.toBER(sizeOnly);
    _writer2.write(idBlockBuf);
    if (this.lenBlock.isIndefiniteForm) {
      _writer2.write(new Uint8Array([128]).buffer);
      this.valueBlock.toBER(sizeOnly, _writer2);
      _writer2.write(new ArrayBuffer(2));
    } else {
      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);
      this.lenBlock.length = valueBlockBuf.byteLength;
      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);
      _writer2.write(lenBlockBuf);
      _writer2.write(valueBlockBuf);
    }
    if (!writer) {
      return _writer2.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      idBlock: this.idBlock.toJSON(),
      lenBlock: this.lenBlock.toJSON(),
      valueBlock: this.valueBlock.toJSON(),
      name: this.name,
      optional: this.optional
    };
    if (this.primitiveSchema)
      object.primitiveSchema = this.primitiveSchema.toJSON();
    return object;
  }
  toString(encoding = "ascii") {
    if (encoding === "ascii") {
      return this.onAsciiEncoding();
    }
    return Convert.ToHex(this.toBER());
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;
  }
  isEqual(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof this.constructor)) {
      return false;
    }
    const thisRaw = this.toBER();
    const otherRaw = other.toBER();
    return isEqualBuffer(thisRaw, otherRaw);
  }
}
BaseBlock.NAME = "BaseBlock";
function prepareIndefiniteForm(baseBlock) {
  if (baseBlock instanceof typeStore.Constructed) {
    for (const value of baseBlock.valueBlock.value) {
      if (prepareIndefiniteForm(value)) {
        baseBlock.lenBlock.isIndefiniteForm = true;
      }
    }
  }
  return !!baseBlock.lenBlock.isIndefiniteForm;
}
class BaseStringBlock extends BaseBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {
    super(parameters, stringValueBlockType);
    if (value) {
      this.fromString(value);
    }
  }
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    this.fromBuffer(this.valueBlock.valueHexView);
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : '${this.valueBlock.value}'`;
  }
}
BaseStringBlock.NAME = "BaseStringBlock";
class LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {
  constructor({ isHexOnly = true, ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = isHexOnly;
  }
}
LocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";
var _a$w;
class Primitive extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalPrimitiveValueBlock);
    this.idBlock.isConstructed = false;
  }
}
_a$w = Primitive;
(() => {
  typeStore.Primitive = _a$w;
})();
Primitive.NAME = "PRIMITIVE";
function localChangeType(inputObject, newType) {
  if (inputObject instanceof newType) {
    return inputObject;
  }
  const newObject = new newType();
  newObject.idBlock = inputObject.idBlock;
  newObject.lenBlock = inputObject.lenBlock;
  newObject.warnings = inputObject.warnings;
  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;
  return newObject;
}
function localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {
  const incomingOffset = inputOffset;
  let returnObject = new BaseBlock({}, ValueBlock);
  const baseBlock = new LocalBaseBlock();
  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {
    returnObject.error = baseBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);
  if (!intBuffer.length) {
    returnObject.error = "Zero buffer length";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.idBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.idBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.idBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.idBlock.blockLength;
  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);
  if (returnObject.lenBlock.warnings.length) {
    returnObject.warnings.concat(returnObject.lenBlock.warnings);
  }
  if (resultOffset === -1) {
    returnObject.error = returnObject.lenBlock.error;
    return {
      offset: -1,
      result: returnObject
    };
  }
  inputOffset = resultOffset;
  inputLength -= returnObject.lenBlock.blockLength;
  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {
    returnObject.error = "Indefinite length form used for primitive encoding form";
    return {
      offset: -1,
      result: returnObject
    };
  }
  let newASN1Type = BaseBlock;
  switch (returnObject.idBlock.tagClass) {
    case 1:
      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {
        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";
        return {
          offset: -1,
          result: returnObject
        };
      }
      switch (returnObject.idBlock.tagNumber) {
        case 0:
          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {
            returnObject.error = "Type [UNIVERSAL 0] is reserved";
            return {
              offset: -1,
              result: returnObject
            };
          }
          newASN1Type = typeStore.EndOfContent;
          break;
        case 1:
          newASN1Type = typeStore.Boolean;
          break;
        case 2:
          newASN1Type = typeStore.Integer;
          break;
        case 3:
          newASN1Type = typeStore.BitString;
          break;
        case 4:
          newASN1Type = typeStore.OctetString;
          break;
        case 5:
          newASN1Type = typeStore.Null;
          break;
        case 6:
          newASN1Type = typeStore.ObjectIdentifier;
          break;
        case 10:
          newASN1Type = typeStore.Enumerated;
          break;
        case 12:
          newASN1Type = typeStore.Utf8String;
          break;
        case 13:
          newASN1Type = typeStore.RelativeObjectIdentifier;
          break;
        case 14:
          newASN1Type = typeStore.TIME;
          break;
        case 15:
          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";
          return {
            offset: -1,
            result: returnObject
          };
        case 16:
          newASN1Type = typeStore.Sequence;
          break;
        case 17:
          newASN1Type = typeStore.Set;
          break;
        case 18:
          newASN1Type = typeStore.NumericString;
          break;
        case 19:
          newASN1Type = typeStore.PrintableString;
          break;
        case 20:
          newASN1Type = typeStore.TeletexString;
          break;
        case 21:
          newASN1Type = typeStore.VideotexString;
          break;
        case 22:
          newASN1Type = typeStore.IA5String;
          break;
        case 23:
          newASN1Type = typeStore.UTCTime;
          break;
        case 24:
          newASN1Type = typeStore.GeneralizedTime;
          break;
        case 25:
          newASN1Type = typeStore.GraphicString;
          break;
        case 26:
          newASN1Type = typeStore.VisibleString;
          break;
        case 27:
          newASN1Type = typeStore.GeneralString;
          break;
        case 28:
          newASN1Type = typeStore.UniversalString;
          break;
        case 29:
          newASN1Type = typeStore.CharacterString;
          break;
        case 30:
          newASN1Type = typeStore.BmpString;
          break;
        case 31:
          newASN1Type = typeStore.DATE;
          break;
        case 32:
          newASN1Type = typeStore.TimeOfDay;
          break;
        case 33:
          newASN1Type = typeStore.DateTime;
          break;
        case 34:
          newASN1Type = typeStore.Duration;
          break;
        default: {
          const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();
          newObject.idBlock = returnObject.idBlock;
          newObject.lenBlock = returnObject.lenBlock;
          newObject.warnings = returnObject.warnings;
          returnObject = newObject;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
    default: {
      newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;
    }
  }
  returnObject = localChangeType(returnObject, newASN1Type);
  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);
  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);
  return {
    offset: resultOffset,
    result: returnObject
  };
}
function fromBER(inputBuffer) {
  if (!inputBuffer.byteLength) {
    const result = new BaseBlock({}, ValueBlock);
    result.error = "Input buffer has zero length";
    return {
      offset: -1,
      result
    };
  }
  return localFromBER(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);
}
function checkLen(indefiniteLength, length2) {
  if (indefiniteLength) {
    return 1;
  }
  return length2;
}
class LocalConstructedValueBlock extends ValueBlock {
  constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {
    super(parameters);
    this.value = value;
    this.isIndefiniteForm = isIndefiniteForm;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const view = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, view, inputOffset, inputLength)) {
      return -1;
    }
    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);
    if (this.valueBeforeDecodeView.length === 0) {
      this.warnings.push("Zero buffer length");
      return inputOffset;
    }
    let currentOffset = inputOffset;
    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {
      const returnObject = localFromBER(view, currentOffset, inputLength);
      if (returnObject.offset === -1) {
        this.error = returnObject.result.error;
        this.warnings.concat(returnObject.result.warnings);
        return -1;
      }
      currentOffset = returnObject.offset;
      this.blockLength += returnObject.result.blockLength;
      inputLength -= returnObject.result.blockLength;
      this.value.push(returnObject.result);
      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {
        break;
      }
    }
    if (this.isIndefiniteForm) {
      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {
        this.value.pop();
      } else {
        this.warnings.push("No EndOfContent block encoded");
      }
    }
    return currentOffset;
  }
  toBER(sizeOnly, writer) {
    const _writer2 = writer || new ViewWriter();
    for (let i = 0; i < this.value.length; i++) {
      this.value[i].toBER(sizeOnly, _writer2);
    }
    if (!writer) {
      return _writer2.final();
    }
    return EMPTY_BUFFER;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      isIndefiniteForm: this.isIndefiniteForm,
      value: []
    };
    for (const value of this.value) {
      object.value.push(value.toJSON());
    }
    return object;
  }
}
LocalConstructedValueBlock.NAME = "ConstructedValueBlock";
var _a$v;
class Constructed extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalConstructedValueBlock);
    this.idBlock.isConstructed = true;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);
    if (resultOffset === -1) {
      this.error = this.valueBlock.error;
      return resultOffset;
    }
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    if (!this.valueBlock.error.length)
      this.blockLength += this.valueBlock.blockLength;
    return resultOffset;
  }
  onAsciiEncoding() {
    const values = [];
    for (const value of this.valueBlock.value) {
      values.push(value.toString("ascii").split("\n").map((o) => `  ${o}`).join("\n"));
    }
    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;
    return values.length ? `${blockName} :
${values.join("\n")}` : `${blockName} :`;
  }
}
_a$v = Constructed;
(() => {
  typeStore.Constructed = _a$v;
})();
Constructed.NAME = "CONSTRUCTED";
class LocalEndOfContentValueBlock extends ValueBlock {
  fromBER(inputBuffer, inputOffset, inputLength) {
    return inputOffset;
  }
  toBER(sizeOnly) {
    return EMPTY_BUFFER;
  }
}
LocalEndOfContentValueBlock.override = "EndOfContentValueBlock";
var _a$u;
class EndOfContent extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalEndOfContentValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 0;
  }
}
_a$u = EndOfContent;
(() => {
  typeStore.EndOfContent = _a$u;
})();
EndOfContent.NAME = END_OF_CONTENT_NAME;
var _a$t;
class Null extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, ValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 5;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (this.lenBlock.length > 0)
      this.warnings.push("Non-zero length of value block for Null type");
    if (!this.idBlock.error.length)
      this.blockLength += this.idBlock.blockLength;
    if (!this.lenBlock.error.length)
      this.blockLength += this.lenBlock.blockLength;
    this.blockLength += inputLength;
    if (inputOffset + inputLength > inputBuffer.byteLength) {
      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
      return -1;
    }
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    const retBuf = new ArrayBuffer(2);
    if (!sizeOnly) {
      const retView = new Uint8Array(retBuf);
      retView[0] = 5;
      retView[1] = 0;
    }
    if (writer) {
      writer.write(retBuf);
    }
    return retBuf;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME}`;
  }
}
_a$t = Null;
(() => {
  typeStore.Null = _a$t;
})();
Null.NAME = "NULL";
class LocalBooleanValueBlock extends HexBlock(ValueBlock) {
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    if (parameters.valueHex) {
      this.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);
    } else {
      this.valueHexView = new Uint8Array(1);
    }
    if (value) {
      this.value = value;
    }
  }
  get value() {
    for (const octet of this.valueHexView) {
      if (octet > 0) {
        return true;
      }
    }
    return false;
  }
  set value(value) {
    this.valueHexView[0] = value ? 255 : 0;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);
    if (inputLength > 1)
      this.warnings.push("Boolean value encoded in more then 1 octet");
    this.isHexOnly = true;
    utilDecodeTC.call(this);
    this.blockLength = inputLength;
    return inputOffset + inputLength;
  }
  toBER() {
    return this.valueHexView.slice();
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalBooleanValueBlock.NAME = "BooleanValueBlock";
var _a$s;
let Boolean$1 = class Boolean2 extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalBooleanValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 1;
  }
  getValue() {
    return this.valueBlock.value;
  }
  setValue(value) {
    this.valueBlock.value = value;
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.getValue}`;
  }
};
_a$s = Boolean$1;
(() => {
  typeStore.Boolean = _a$s;
})();
Boolean$1.NAME = "BOOLEAN";
class LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
  constructor({ isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.isConstructed = isConstructed;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = 0;
    if (this.isConstructed) {
      this.isHexOnly = false;
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (let i = 0; i < this.value.length; i++) {
        const currentBlockName = this.value[i].constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== OCTET_STRING_NAME) {
          this.error = "OCTET STRING may consists of OCTET STRINGs only";
          return -1;
        }
      }
    } else {
      this.isHexOnly = true;
      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
      this.blockLength = inputLength;
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed)
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      isConstructed: this.isConstructed
    };
  }
}
LocalOctetStringValueBlock.NAME = "OctetStringValueBlock";
var _a$r;
class OctetString extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b2, _c2;
    (_b2 = parameters.isConstructed) !== null && _b2 !== void 0 ? _b2 : parameters.isConstructed = !!((_c2 = parameters.value) === null || _c2 === void 0 ? void 0 : _c2.length);
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalOctetStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 4;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    if (inputLength === 0) {
      if (this.idBlock.error.length === 0)
        this.blockLength += this.idBlock.blockLength;
      if (this.lenBlock.error.length === 0)
        this.blockLength += this.lenBlock.blockLength;
      return inputOffset;
    }
    if (!this.valueBlock.isConstructed) {
      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;
      const buf2 = view.subarray(inputOffset, inputOffset + inputLength);
      try {
        if (buf2.byteLength) {
          const asn = localFromBER(buf2, 0, buf2.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength) {
            this.valueBlock.value = [asn.result];
          }
        }
      } catch (e) {
      }
    }
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    }
    return `${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueHexView)}`;
  }
  getValue() {
    if (!this.idBlock.isConstructed) {
      return this.valueBlock.valueHexView.slice().buffer;
    }
    const array = [];
    for (const content of this.valueBlock.value) {
      if (content instanceof OctetString) {
        array.push(content.valueBlock.valueHexView);
      }
    }
    return BufferSourceConverter.concat(array);
  }
}
_a$r = OctetString;
(() => {
  typeStore.OctetString = _a$r;
})();
OctetString.NAME = OCTET_STRING_NAME;
class LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {
  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {
    super(parameters);
    this.unusedBits = unusedBits;
    this.isConstructed = isConstructed;
    this.blockLength = this.valueHexView.byteLength;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    let resultOffset = -1;
    if (this.isConstructed) {
      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);
      if (resultOffset === -1)
        return resultOffset;
      for (const value of this.value) {
        const currentBlockName = value.constructor.NAME;
        if (currentBlockName === END_OF_CONTENT_NAME) {
          if (this.isIndefiniteForm)
            break;
          else {
            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";
            return -1;
          }
        }
        if (currentBlockName !== BIT_STRING_NAME) {
          this.error = "BIT STRING may consists of BIT STRINGs only";
          return -1;
        }
        const valueBlock = value.valueBlock;
        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {
          this.error = 'Using of "unused bits" inside constructive BIT STRING allowed for least one only';
          return -1;
        }
        this.unusedBits = valueBlock.unusedBits;
      }
      return resultOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.unusedBits = intBuffer[0];
    if (this.unusedBits > 7) {
      this.error = "Unused bits for BitString must be in range 0-7";
      return -1;
    }
    if (!this.unusedBits) {
      const buf2 = intBuffer.subarray(1);
      try {
        if (buf2.byteLength) {
          const asn = localFromBER(buf2, 0, buf2.byteLength);
          if (asn.offset !== -1 && asn.offset === inputLength - 1) {
            this.value = [asn.result];
          }
        }
      } catch (e) {
      }
    }
    this.valueHexView = intBuffer.subarray(1);
    this.blockLength = intBuffer.length;
    return inputOffset + inputLength;
  }
  toBER(sizeOnly, writer) {
    if (this.isConstructed) {
      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);
    }
    if (sizeOnly) {
      return new ArrayBuffer(this.valueHexView.byteLength + 1);
    }
    if (!this.valueHexView.byteLength) {
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(this.valueHexView.length + 1);
    retView[0] = this.unusedBits;
    retView.set(this.valueHexView, 1);
    return retView.buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      unusedBits: this.unusedBits,
      isConstructed: this.isConstructed
    };
  }
}
LocalBitStringValueBlock.NAME = "BitStringValueBlock";
var _a$q;
class BitString extends BaseBlock {
  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {
    var _b2, _c2;
    (_b2 = parameters.isConstructed) !== null && _b2 !== void 0 ? _b2 : parameters.isConstructed = !!((_c2 = parameters.value) === null || _c2 === void 0 ? void 0 : _c2.length);
    super({
      idBlock: {
        isConstructed: parameters.isConstructed,
        ...idBlock
      },
      lenBlock: {
        ...lenBlock,
        isIndefiniteForm: !!parameters.isIndefiniteForm
      },
      ...parameters
    }, LocalBitStringValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 3;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    this.valueBlock.isConstructed = this.idBlock.isConstructed;
    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;
    return super.fromBER(inputBuffer, inputOffset, inputLength);
  }
  onAsciiEncoding() {
    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {
      return Constructed.prototype.onAsciiEncoding.call(this);
    } else {
      const bits = [];
      const valueHex = this.valueBlock.valueHexView;
      for (const byte of valueHex) {
        bits.push(byte.toString(2).padStart(8, "0"));
      }
      const bitsStr = bits.join("");
      return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;
    }
  }
}
_a$q = BitString;
(() => {
  typeStore.BitString = _a$q;
})();
BitString.NAME = BIT_STRING_NAME;
var _a$p;
function viewAdd(first2, second) {
  const c = new Uint8Array([0]);
  const firstView = new Uint8Array(first2);
  const secondView = new Uint8Array(second);
  let firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value = 0;
  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;
  let counter = 0;
  for (let i = max; i >= 0; i--, counter++) {
    switch (true) {
      case counter < secondViewCopy.length:
        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];
        break;
      default:
        value = firstViewCopy[firstViewCopyLength - counter] + c[0];
    }
    c[0] = value / 10;
    switch (true) {
      case counter >= firstViewCopy.length:
        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);
        break;
      default:
        firstViewCopy[firstViewCopyLength - counter] = value % 10;
    }
  }
  if (c[0] > 0)
    firstViewCopy = utilConcatView(c, firstViewCopy);
  return firstViewCopy;
}
function power2(n) {
  if (n >= powers2.length) {
    for (let p = powers2.length; p <= n; p++) {
      const c = new Uint8Array([0]);
      let digits = powers2[p - 1].slice(0);
      for (let i = digits.length - 1; i >= 0; i--) {
        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);
        c[0] = newValue[0] / 10;
        digits[i] = newValue[0] % 10;
      }
      if (c[0] > 0)
        digits = utilConcatView(c, digits);
      powers2.push(digits);
    }
  }
  return powers2[n];
}
function viewSub(first2, second) {
  let b = 0;
  const firstView = new Uint8Array(first2);
  const secondView = new Uint8Array(second);
  const firstViewCopy = firstView.slice(0);
  const firstViewCopyLength = firstViewCopy.length - 1;
  const secondViewCopy = secondView.slice(0);
  const secondViewCopyLength = secondViewCopy.length - 1;
  let value;
  let counter = 0;
  for (let i = secondViewCopyLength; i >= 0; i--, counter++) {
    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;
    switch (true) {
      case value < 0:
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
        break;
      default:
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
    }
  }
  if (b > 0) {
    for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {
      value = firstViewCopy[firstViewCopyLength - counter] - b;
      if (value < 0) {
        b = 1;
        firstViewCopy[firstViewCopyLength - counter] = value + 10;
      } else {
        b = 0;
        firstViewCopy[firstViewCopyLength - counter] = value;
        break;
      }
    }
  }
  return firstViewCopy.slice();
}
class LocalIntegerValueBlock extends HexBlock(ValueBlock) {
  constructor({ value, ...parameters } = {}) {
    super(parameters);
    this._valueDec = 0;
    if (parameters.valueHex) {
      this.setValueHex();
    }
    if (value !== void 0) {
      this.valueDec = value;
    }
  }
  setValueHex() {
    if (this.valueHexView.length >= 4) {
      this.warnings.push("Too big Integer for decoding, hex only");
      this.isHexOnly = true;
      this._valueDec = 0;
    } else {
      this.isHexOnly = false;
      if (this.valueHexView.length > 0) {
        this._valueDec = utilDecodeTC.call(this);
      }
    }
  }
  set valueDec(v) {
    this._valueDec = v;
    this.isHexOnly = false;
    this.valueHexView = new Uint8Array(utilEncodeTC(v));
  }
  get valueDec() {
    return this._valueDec;
  }
  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {
    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);
    if (offset === -1)
      return offset;
    const view = this.valueHexView;
    if (view[0] === 0 && (view[1] & 128) !== 0) {
      this.valueHexView = view.subarray(1);
    } else {
      if (expectedLength !== 0) {
        if (view.length < expectedLength) {
          if (expectedLength - view.length > 1)
            expectedLength = view.length + 1;
          this.valueHexView = view.subarray(expectedLength - view.length);
        }
      }
    }
    return offset;
  }
  toDER(sizeOnly = false) {
    const view = this.valueHexView;
    switch (true) {
      case (view[0] & 128) !== 0:
        {
          const updatedView = new Uint8Array(this.valueHexView.length + 1);
          updatedView[0] = 0;
          updatedView.set(view, 1);
          this.valueHexView = updatedView;
        }
        break;
      case (view[0] === 0 && (view[1] & 128) === 0):
        {
          this.valueHexView = this.valueHexView.subarray(1);
        }
        break;
    }
    return this.toBER(sizeOnly);
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);
    if (resultOffset === -1) {
      return resultOffset;
    }
    this.setValueHex();
    return resultOffset;
  }
  toBER(sizeOnly) {
    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
  toString() {
    const firstBit = this.valueHexView.length * 8 - 1;
    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);
    let bitNumber = 0;
    let currentByte;
    const asn1View = this.valueHexView;
    let result = "";
    let flag = false;
    for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {
      currentByte = asn1View[byteNumber];
      for (let i = 0; i < 8; i++) {
        if ((currentByte & 1) === 1) {
          switch (bitNumber) {
            case firstBit:
              digits = viewSub(power2(bitNumber), digits);
              result = "-";
              break;
            default:
              digits = viewAdd(digits, power2(bitNumber));
          }
        }
        bitNumber++;
        currentByte >>= 1;
      }
    }
    for (let i = 0; i < digits.length; i++) {
      if (digits[i])
        flag = true;
      if (flag)
        result += digitsString.charAt(digits[i]);
    }
    if (flag === false)
      result += digitsString.charAt(0);
    return result;
  }
}
_a$p = LocalIntegerValueBlock;
LocalIntegerValueBlock.NAME = "IntegerValueBlock";
(() => {
  Object.defineProperty(_a$p.prototype, "valueHex", {
    set: function(v) {
      this.valueHexView = new Uint8Array(v);
      this.setValueHex();
    },
    get: function() {
      return this.valueHexView.slice().buffer;
    }
  });
})();
var _a$o;
class Integer extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalIntegerValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 2;
  }
  toBigInt() {
    assertBigInt();
    return BigInt(this.valueBlock.toString());
  }
  static fromBigInt(value) {
    assertBigInt();
    const bigIntValue = BigInt(value);
    const writer = new ViewWriter();
    const hex = bigIntValue.toString(16).replace(/^-/, "");
    const view = new Uint8Array(Convert.FromHex(hex));
    if (bigIntValue < 0) {
      const first2 = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));
      first2[0] |= 128;
      const firstInt = BigInt(`0x${Convert.ToHex(first2)}`);
      const secondInt = firstInt + bigIntValue;
      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));
      second[0] |= 128;
      writer.write(second);
    } else {
      if (view[0] & 128) {
        writer.write(new Uint8Array([0]));
      }
      writer.write(view);
    }
    const res = new Integer({
      valueHex: writer.final()
    });
    return res;
  }
  convertToDER() {
    const integer = new Integer({ valueHex: this.valueBlock.valueHexView });
    integer.valueBlock.toDER();
    return integer;
  }
  convertFromDER() {
    return new Integer({
      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView
    });
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;
  }
}
_a$o = Integer;
(() => {
  typeStore.Integer = _a$o;
})();
Integer.NAME = "INTEGER";
var _a$n;
class Enumerated extends Integer {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 10;
  }
}
_a$n = Enumerated;
(() => {
  typeStore.Enumerated = _a$n;
})();
Enumerated.NAME = "ENUMERATED";
class LocalSidValueBlock extends HexBlock(ValueBlock) {
  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
    this.isFirstSid = isFirstSid;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (!inputLength) {
      return inputOffset;
    }
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {
      return -1;
    }
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0; i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0; i < this.blockLength; i++) {
      tempView[i] = this.valueHexView[i];
    }
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  set valueBigInt(value) {
    assertBigInt();
    let bits = BigInt(value).toString(2);
    while (bits.length % 7) {
      bits = "0" + bits;
    }
    const bytes2 = new Uint8Array(bits.length / 7);
    for (let i = 0; i < bytes2.length; i++) {
      bytes2[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes2.length ? 128 : 0);
    }
    this.fromBER(bytes2.buffer, 0, bytes2.length);
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0; i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len2 = encodedBuf.byteLength - 1;
      for (let i = 0; i < len2; i++)
        retView[i] = encodedView[i] | 128;
      retView[len2] = encodedView[len2];
    }
    return retView;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      if (this.isFirstSid) {
        let sidValue = this.valueDec;
        if (this.valueDec <= 39)
          result = "0.";
        else {
          if (this.valueDec <= 79) {
            result = "1.";
            sidValue -= 40;
          } else {
            result = "2.";
            sidValue -= 80;
          }
        }
        result += sidValue.toString();
      } else
        result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec,
      isFirstSid: this.isFirstSid
    };
  }
}
LocalSidValueBlock.NAME = "sidBlock";
class LocalObjectIdentifierValueBlock extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalSidValueBlock();
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      if (this.value.length === 0)
        sidBlock.isFirstSid = true;
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly) {
    const retBuffers = [];
    for (let i = 0; i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat(retBuffers);
  }
  fromString(string2) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    let flag = false;
    do {
      pos2 = string2.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string2.substring(pos1);
      else
        sid = string2.substring(pos1, pos2);
      pos1 = pos2 + 1;
      if (flag) {
        const sidBlock = this.value[0];
        let plus = 0;
        switch (sidBlock.valueDec) {
          case 0:
            break;
          case 1:
            plus = 40;
            break;
          case 2:
            plus = 80;
            break;
          default:
            this.value = [];
            return;
        }
        const parsedSID = parseInt(sid, 10);
        if (isNaN(parsedSID))
          return;
        sidBlock.valueDec = parsedSID + plus;
        flag = false;
      } else {
        const sidBlock = new LocalSidValueBlock();
        if (sid > Number.MAX_SAFE_INTEGER) {
          assertBigInt();
          const sidValue = BigInt(sid);
          sidBlock.valueBigInt = sidValue;
        } else {
          sidBlock.valueDec = parseInt(sid, 10);
          if (isNaN(sidBlock.valueDec))
            return;
        }
        if (!this.value.length) {
          sidBlock.isFirstSid = true;
          flag = true;
        }
        this.value.push(sidBlock);
      }
    } while (pos2 !== -1);
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0; i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        if (this.value[i].isFirstSid)
          result = `2.{${sidStr} - 80}`;
        else
          result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0; i < this.value.length; i++) {
      object.sidArray.push(this.value[i].toJSON());
    }
    return object;
  }
}
LocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";
var _a$m;
class ObjectIdentifier extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 6;
  }
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$m = ObjectIdentifier;
(() => {
  typeStore.ObjectIdentifier = _a$m;
})();
ObjectIdentifier.NAME = "OBJECT IDENTIFIER";
class LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {
  constructor({ valueDec = 0, ...parameters } = {}) {
    super(parameters);
    this.valueDec = valueDec;
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    if (inputLength === 0)
      return inputOffset;
    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);
    if (!checkBufferParams(this, inputView, inputOffset, inputLength))
      return -1;
    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);
    this.valueHexView = new Uint8Array(inputLength);
    for (let i = 0; i < inputLength; i++) {
      this.valueHexView[i] = intBuffer[i] & 127;
      this.blockLength++;
      if ((intBuffer[i] & 128) === 0)
        break;
    }
    const tempView = new Uint8Array(this.blockLength);
    for (let i = 0; i < this.blockLength; i++)
      tempView[i] = this.valueHexView[i];
    this.valueHexView = tempView;
    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {
      this.error = "End of input reached before message was fully decoded";
      return -1;
    }
    if (this.valueHexView[0] === 0)
      this.warnings.push("Needlessly long format of SID encoding");
    if (this.blockLength <= 8)
      this.valueDec = utilFromBase(this.valueHexView, 7);
    else {
      this.isHexOnly = true;
      this.warnings.push("Too big SID for decoding, hex only");
    }
    return inputOffset + this.blockLength;
  }
  toBER(sizeOnly) {
    if (this.isHexOnly) {
      if (sizeOnly)
        return new ArrayBuffer(this.valueHexView.byteLength);
      const curView = this.valueHexView;
      const retView2 = new Uint8Array(this.blockLength);
      for (let i = 0; i < this.blockLength - 1; i++)
        retView2[i] = curView[i] | 128;
      retView2[this.blockLength - 1] = curView[this.blockLength - 1];
      return retView2.buffer;
    }
    const encodedBuf = utilToBase(this.valueDec, 7);
    if (encodedBuf.byteLength === 0) {
      this.error = "Error during encoding SID value";
      return EMPTY_BUFFER;
    }
    const retView = new Uint8Array(encodedBuf.byteLength);
    if (!sizeOnly) {
      const encodedView = new Uint8Array(encodedBuf);
      const len2 = encodedBuf.byteLength - 1;
      for (let i = 0; i < len2; i++)
        retView[i] = encodedView[i] | 128;
      retView[len2] = encodedView[len2];
    }
    return retView.buffer;
  }
  toString() {
    let result = "";
    if (this.isHexOnly)
      result = Convert.ToHex(this.valueHexView);
    else {
      result = this.valueDec.toString();
    }
    return result;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      valueDec: this.valueDec
    };
  }
}
LocalRelativeSidValueBlock.NAME = "relativeSidBlock";
class LocalRelativeObjectIdentifierValueBlock extends ValueBlock {
  constructor({ value = EMPTY_STRING, ...parameters } = {}) {
    super(parameters);
    this.value = [];
    if (value) {
      this.fromString(value);
    }
  }
  fromBER(inputBuffer, inputOffset, inputLength) {
    let resultOffset = inputOffset;
    while (inputLength > 0) {
      const sidBlock = new LocalRelativeSidValueBlock();
      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);
      if (resultOffset === -1) {
        this.blockLength = 0;
        this.error = sidBlock.error;
        return resultOffset;
      }
      this.blockLength += sidBlock.blockLength;
      inputLength -= sidBlock.blockLength;
      this.value.push(sidBlock);
    }
    return resultOffset;
  }
  toBER(sizeOnly, writer) {
    const retBuffers = [];
    for (let i = 0; i < this.value.length; i++) {
      const valueBuf = this.value[i].toBER(sizeOnly);
      if (valueBuf.byteLength === 0) {
        this.error = this.value[i].error;
        return EMPTY_BUFFER;
      }
      retBuffers.push(valueBuf);
    }
    return concat(retBuffers);
  }
  fromString(string2) {
    this.value = [];
    let pos1 = 0;
    let pos2 = 0;
    let sid = "";
    do {
      pos2 = string2.indexOf(".", pos1);
      if (pos2 === -1)
        sid = string2.substring(pos1);
      else
        sid = string2.substring(pos1, pos2);
      pos1 = pos2 + 1;
      const sidBlock = new LocalRelativeSidValueBlock();
      sidBlock.valueDec = parseInt(sid, 10);
      if (isNaN(sidBlock.valueDec))
        return true;
      this.value.push(sidBlock);
    } while (pos2 !== -1);
    return true;
  }
  toString() {
    let result = "";
    let isHexOnly = false;
    for (let i = 0; i < this.value.length; i++) {
      isHexOnly = this.value[i].isHexOnly;
      let sidStr = this.value[i].toString();
      if (i !== 0)
        result = `${result}.`;
      if (isHexOnly) {
        sidStr = `{${sidStr}}`;
        result += sidStr;
      } else
        result += sidStr;
    }
    return result;
  }
  toJSON() {
    const object = {
      ...super.toJSON(),
      value: this.toString(),
      sidArray: []
    };
    for (let i = 0; i < this.value.length; i++)
      object.sidArray.push(this.value[i].toJSON());
    return object;
  }
}
LocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";
var _a$l;
class RelativeObjectIdentifier extends BaseBlock {
  constructor(parameters = {}) {
    super(parameters, LocalRelativeObjectIdentifierValueBlock);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 13;
  }
  getValue() {
    return this.valueBlock.toString();
  }
  setValue(value) {
    this.valueBlock.fromString(value);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.getValue()
    };
  }
}
_a$l = RelativeObjectIdentifier;
(() => {
  typeStore.RelativeObjectIdentifier = _a$l;
})();
RelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";
var _a$k;
class Sequence extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 16;
  }
}
_a$k = Sequence;
(() => {
  typeStore.Sequence = _a$k;
})();
Sequence.NAME = "SEQUENCE";
var _a$j;
let Set$1 = class Set2 extends Constructed {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 17;
  }
};
_a$j = Set$1;
(() => {
  typeStore.Set = _a$j;
})();
Set$1.NAME = "SET";
class LocalStringValueBlock extends HexBlock(ValueBlock) {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.isHexOnly = true;
    this.value = EMPTY_STRING;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      value: this.value
    };
  }
}
LocalStringValueBlock.NAME = "StringValueBlock";
class LocalSimpleStringValueBlock extends LocalStringValueBlock {
}
LocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";
class LocalSimpleStringBlock extends BaseStringBlock {
  constructor({ ...parameters } = {}) {
    super(parameters, LocalSimpleStringValueBlock);
  }
  fromBuffer(inputBuffer) {
    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));
  }
  fromString(inputString) {
    const strLen = inputString.length;
    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);
    for (let i = 0; i < strLen; i++)
      view[i] = inputString.charCodeAt(i);
    this.valueBlock.value = inputString;
  }
}
LocalSimpleStringBlock.NAME = "SIMPLE STRING";
class LocalUtf8StringValueBlock extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
    try {
      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);
    } catch (ex) {
      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);
      this.valueBlock.value = Convert.ToBinary(inputBuffer);
    }
  }
  fromString(inputString) {
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));
    this.valueBlock.value = inputString;
  }
}
LocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";
var _a$i;
class Utf8String extends LocalUtf8StringValueBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 12;
  }
}
_a$i = Utf8String;
(() => {
  typeStore.Utf8String = _a$i;
})();
Utf8String.NAME = "UTF8String";
class LocalBmpStringValueBlock extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);
    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);
  }
  fromString(inputString) {
    this.valueBlock.value = inputString;
    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));
  }
}
LocalBmpStringValueBlock.NAME = "BmpStringValueBlock";
var _a$h;
class BmpString extends LocalBmpStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 30;
  }
}
_a$h = BmpString;
(() => {
  typeStore.BmpString = _a$h;
})();
BmpString.NAME = "BMPString";
class LocalUniversalStringValueBlock extends LocalSimpleStringBlock {
  fromBuffer(inputBuffer) {
    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);
    const valueView = new Uint8Array(copyBuffer);
    for (let i = 0; i < valueView.length; i += 4) {
      valueView[i] = valueView[i + 3];
      valueView[i + 1] = valueView[i + 2];
      valueView[i + 2] = 0;
      valueView[i + 3] = 0;
    }
    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));
  }
  fromString(inputString) {
    const strLength = inputString.length;
    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);
    for (let i = 0; i < strLength; i++) {
      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);
      const codeView = new Uint8Array(codeBuf);
      if (codeView.length > 4)
        continue;
      const dif = 4 - codeView.length;
      for (let j = codeView.length - 1; j >= 0; j--)
        valueHexView[i * 4 + j + dif] = codeView[j];
    }
    this.valueBlock.value = inputString;
  }
}
LocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";
var _a$g;
class UniversalString extends LocalUniversalStringValueBlock {
  constructor({ ...parameters } = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 28;
  }
}
_a$g = UniversalString;
(() => {
  typeStore.UniversalString = _a$g;
})();
UniversalString.NAME = "UniversalString";
var _a$f;
class NumericString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 18;
  }
}
_a$f = NumericString;
(() => {
  typeStore.NumericString = _a$f;
})();
NumericString.NAME = "NumericString";
var _a$e;
class PrintableString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 19;
  }
}
_a$e = PrintableString;
(() => {
  typeStore.PrintableString = _a$e;
})();
PrintableString.NAME = "PrintableString";
var _a$d;
class TeletexString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 20;
  }
}
_a$d = TeletexString;
(() => {
  typeStore.TeletexString = _a$d;
})();
TeletexString.NAME = "TeletexString";
var _a$c;
class VideotexString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 21;
  }
}
_a$c = VideotexString;
(() => {
  typeStore.VideotexString = _a$c;
})();
VideotexString.NAME = "VideotexString";
var _a$b;
class IA5String extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 22;
  }
}
_a$b = IA5String;
(() => {
  typeStore.IA5String = _a$b;
})();
IA5String.NAME = "IA5String";
var _a$a;
class GraphicString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 25;
  }
}
_a$a = GraphicString;
(() => {
  typeStore.GraphicString = _a$a;
})();
GraphicString.NAME = "GraphicString";
var _a$9;
class VisibleString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 26;
  }
}
_a$9 = VisibleString;
(() => {
  typeStore.VisibleString = _a$9;
})();
VisibleString.NAME = "VisibleString";
var _a$8;
class GeneralString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 27;
  }
}
_a$8 = GeneralString;
(() => {
  typeStore.GeneralString = _a$8;
})();
GeneralString.NAME = "GeneralString";
var _a$7;
class CharacterString extends LocalSimpleStringBlock {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 29;
  }
}
_a$7 = CharacterString;
(() => {
  typeStore.CharacterString = _a$7;
})();
CharacterString.NAME = "CharacterString";
var _a$6;
class UTCTime extends VisibleString {
  constructor({ value, valueDate, ...parameters } = {}) {
    super(parameters);
    this.year = 0;
    this.month = 0;
    this.day = 0;
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    if (value) {
      this.fromString(value);
      this.valueBlock.valueHexView = new Uint8Array(value.length);
      for (let i = 0; i < value.length; i++)
        this.valueBlock.valueHexView[i] = value.charCodeAt(i);
    }
    if (valueDate) {
      this.fromDate(valueDate);
      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());
    }
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 23;
  }
  fromBuffer(inputBuffer) {
    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));
  }
  toBuffer() {
    const str = this.toString();
    const buffer2 = new ArrayBuffer(str.length);
    const view = new Uint8Array(buffer2);
    for (let i = 0; i < str.length; i++)
      view[i] = str.charCodeAt(i);
    return buffer2;
  }
  fromDate(inputDate) {
    this.year = inputDate.getUTCFullYear();
    this.month = inputDate.getUTCMonth() + 1;
    this.day = inputDate.getUTCDate();
    this.hour = inputDate.getUTCHours();
    this.minute = inputDate.getUTCMinutes();
    this.second = inputDate.getUTCSeconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));
  }
  fromString(inputString) {
    const parser2 = /(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/ig;
    const parserArray = parser2.exec(inputString);
    if (parserArray === null) {
      this.error = "Wrong input string for conversion";
      return;
    }
    const year = parseInt(parserArray[1], 10);
    if (year >= 50)
      this.year = 1900 + year;
    else
      this.year = 2e3 + year;
    this.month = parseInt(parserArray[2], 10);
    this.day = parseInt(parserArray[3], 10);
    this.hour = parseInt(parserArray[4], 10);
    this.minute = parseInt(parserArray[5], 10);
    this.second = parseInt(parserArray[6], 10);
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = new Array(7);
      outputArray[0] = padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);
      outputArray[1] = padNumber(this.month, 2);
      outputArray[2] = padNumber(this.day, 2);
      outputArray[3] = padNumber(this.hour, 2);
      outputArray[4] = padNumber(this.minute, 2);
      outputArray[5] = padNumber(this.second, 2);
      outputArray[6] = "Z";
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  onAsciiEncoding() {
    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      year: this.year,
      month: this.month,
      day: this.day,
      hour: this.hour,
      minute: this.minute,
      second: this.second
    };
  }
}
_a$6 = UTCTime;
(() => {
  typeStore.UTCTime = _a$6;
})();
UTCTime.NAME = "UTCTime";
var _a$5;
class GeneralizedTime extends UTCTime {
  constructor(parameters = {}) {
    var _b2;
    super(parameters);
    (_b2 = this.millisecond) !== null && _b2 !== void 0 ? _b2 : this.millisecond = 0;
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 24;
  }
  fromDate(inputDate) {
    super.fromDate(inputDate);
    this.millisecond = inputDate.getUTCMilliseconds();
  }
  toDate() {
    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));
  }
  fromString(inputString) {
    let isUTC = false;
    let timeString = "";
    let dateTimeString = "";
    let fractionPart = 0;
    let parser2;
    let hourDifference = 0;
    let minuteDifference = 0;
    if (inputString[inputString.length - 1] === "Z") {
      timeString = inputString.substring(0, inputString.length - 1);
      isUTC = true;
    } else {
      const number2 = new Number(inputString[inputString.length - 1]);
      if (isNaN(number2.valueOf()))
        throw new Error("Wrong input string for conversion");
      timeString = inputString;
    }
    if (isUTC) {
      if (timeString.indexOf("+") !== -1)
        throw new Error("Wrong input string for conversion");
      if (timeString.indexOf("-") !== -1)
        throw new Error("Wrong input string for conversion");
    } else {
      let multiplier = 1;
      let differencePosition = timeString.indexOf("+");
      let differenceString = "";
      if (differencePosition === -1) {
        differencePosition = timeString.indexOf("-");
        multiplier = -1;
      }
      if (differencePosition !== -1) {
        differenceString = timeString.substring(differencePosition + 1);
        timeString = timeString.substring(0, differencePosition);
        if (differenceString.length !== 2 && differenceString.length !== 4)
          throw new Error("Wrong input string for conversion");
        let number2 = parseInt(differenceString.substring(0, 2), 10);
        if (isNaN(number2.valueOf()))
          throw new Error("Wrong input string for conversion");
        hourDifference = multiplier * number2;
        if (differenceString.length === 4) {
          number2 = parseInt(differenceString.substring(2, 4), 10);
          if (isNaN(number2.valueOf()))
            throw new Error("Wrong input string for conversion");
          minuteDifference = multiplier * number2;
        }
      }
    }
    let fractionPointPosition = timeString.indexOf(".");
    if (fractionPointPosition === -1)
      fractionPointPosition = timeString.indexOf(",");
    if (fractionPointPosition !== -1) {
      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);
      if (isNaN(fractionPartCheck.valueOf()))
        throw new Error("Wrong input string for conversion");
      fractionPart = fractionPartCheck.valueOf();
      dateTimeString = timeString.substring(0, fractionPointPosition);
    } else
      dateTimeString = timeString;
    switch (true) {
      case dateTimeString.length === 8:
        parser2 = /(\d{4})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1)
          throw new Error("Wrong input string for conversion");
        break;
      case dateTimeString.length === 10:
        parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.minute = Math.floor(fractionResult);
          fractionResult = 60 * (fractionResult - this.minute);
          this.second = Math.floor(fractionResult);
          fractionResult = 1e3 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 12:
        parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          let fractionResult = 60 * fractionPart;
          this.second = Math.floor(fractionResult);
          fractionResult = 1e3 * (fractionResult - this.second);
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      case dateTimeString.length === 14:
        parser2 = /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/ig;
        if (fractionPointPosition !== -1) {
          const fractionResult = 1e3 * fractionPart;
          this.millisecond = Math.floor(fractionResult);
        }
        break;
      default:
        throw new Error("Wrong input string for conversion");
    }
    const parserArray = parser2.exec(dateTimeString);
    if (parserArray === null)
      throw new Error("Wrong input string for conversion");
    for (let j = 1; j < parserArray.length; j++) {
      switch (j) {
        case 1:
          this.year = parseInt(parserArray[j], 10);
          break;
        case 2:
          this.month = parseInt(parserArray[j], 10);
          break;
        case 3:
          this.day = parseInt(parserArray[j], 10);
          break;
        case 4:
          this.hour = parseInt(parserArray[j], 10) + hourDifference;
          break;
        case 5:
          this.minute = parseInt(parserArray[j], 10) + minuteDifference;
          break;
        case 6:
          this.second = parseInt(parserArray[j], 10);
          break;
        default:
          throw new Error("Wrong input string for conversion");
      }
    }
    if (isUTC === false) {
      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
      this.year = tempDate.getUTCFullYear();
      this.month = tempDate.getUTCMonth();
      this.day = tempDate.getUTCDay();
      this.hour = tempDate.getUTCHours();
      this.minute = tempDate.getUTCMinutes();
      this.second = tempDate.getUTCSeconds();
      this.millisecond = tempDate.getUTCMilliseconds();
    }
  }
  toString(encoding = "iso") {
    if (encoding === "iso") {
      const outputArray = [];
      outputArray.push(padNumber(this.year, 4));
      outputArray.push(padNumber(this.month, 2));
      outputArray.push(padNumber(this.day, 2));
      outputArray.push(padNumber(this.hour, 2));
      outputArray.push(padNumber(this.minute, 2));
      outputArray.push(padNumber(this.second, 2));
      if (this.millisecond !== 0) {
        outputArray.push(".");
        outputArray.push(padNumber(this.millisecond, 3));
      }
      outputArray.push("Z");
      return outputArray.join("");
    }
    return super.toString(encoding);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      millisecond: this.millisecond
    };
  }
}
_a$5 = GeneralizedTime;
(() => {
  typeStore.GeneralizedTime = _a$5;
})();
GeneralizedTime.NAME = "GeneralizedTime";
var _a$4;
class DATE extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 31;
  }
}
_a$4 = DATE;
(() => {
  typeStore.DATE = _a$4;
})();
DATE.NAME = "DATE";
var _a$3;
class TimeOfDay extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 32;
  }
}
_a$3 = TimeOfDay;
(() => {
  typeStore.TimeOfDay = _a$3;
})();
TimeOfDay.NAME = "TimeOfDay";
var _a$2;
class DateTime extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 33;
  }
}
_a$2 = DateTime;
(() => {
  typeStore.DateTime = _a$2;
})();
DateTime.NAME = "DateTime";
var _a$1;
class Duration extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 34;
  }
}
_a$1 = Duration;
(() => {
  typeStore.Duration = _a$1;
})();
Duration.NAME = "Duration";
var _a;
class TIME extends Utf8String {
  constructor(parameters = {}) {
    super(parameters);
    this.idBlock.tagClass = 1;
    this.idBlock.tagNumber = 14;
  }
}
_a = TIME;
(() => {
  typeStore.TIME = _a;
})();
TIME.NAME = "TIME";
function pkcs1ToJwk(bytes2) {
  const { result } = fromBER(bytes2);
  const values = result.valueBlock.value;
  const key = {
    n: toString$2(bnToBuf(values[1].toBigInt()), "base64url"),
    e: toString$2(bnToBuf(values[2].toBigInt()), "base64url"),
    d: toString$2(bnToBuf(values[3].toBigInt()), "base64url"),
    p: toString$2(bnToBuf(values[4].toBigInt()), "base64url"),
    q: toString$2(bnToBuf(values[5].toBigInt()), "base64url"),
    dp: toString$2(bnToBuf(values[6].toBigInt()), "base64url"),
    dq: toString$2(bnToBuf(values[7].toBigInt()), "base64url"),
    qi: toString$2(bnToBuf(values[8].toBigInt()), "base64url"),
    kty: "RSA",
    alg: "RS256"
  };
  return key;
}
function jwkToPkcs1(jwk) {
  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const root2 = new Sequence({
    value: [
      new Integer({ value: 0 }),
      Integer.fromBigInt(bufToBn(fromString$1(jwk.n, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString$1(jwk.e, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString$1(jwk.d, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString$1(jwk.p, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString$1(jwk.q, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString$1(jwk.dp, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString$1(jwk.dq, "base64url"))),
      Integer.fromBigInt(bufToBn(fromString$1(jwk.qi, "base64url")))
    ]
  });
  const der = root2.toBER();
  return new Uint8Array(der, 0, der.byteLength);
}
function pkixToJwk(bytes2) {
  const { result } = fromBER(bytes2);
  const values = result.valueBlock.value[1].valueBlock.value[0].valueBlock.value;
  return {
    kty: "RSA",
    n: toString$2(bnToBuf(values[0].toBigInt()), "base64url"),
    e: toString$2(bnToBuf(values[1].toBigInt()), "base64url")
  };
}
function jwkToPkix(jwk) {
  if (jwk.n == null || jwk.e == null) {
    throw new CodeError("JWK was missing components", "ERR_INVALID_PARAMETERS");
  }
  const root2 = new Sequence({
    value: [
      new Sequence({
        value: [
          // rsaEncryption
          new ObjectIdentifier({
            value: "1.2.840.113549.1.1.1"
          }),
          new Null()
        ]
      }),
      // this appears to be a bug in asn1js.js - this should really be a Sequence
      // and not a BitString but it generates the same bytes as node-forge so 
      new BitString({
        valueHex: new Sequence({
          value: [
            Integer.fromBigInt(bufToBn(fromString$1(jwk.n, "base64url"))),
            Integer.fromBigInt(bufToBn(fromString$1(jwk.e, "base64url")))
          ]
        }).toBER()
      })
    ]
  });
  const der = root2.toBER();
  return new Uint8Array(der, 0, der.byteLength);
}
function bnToBuf(bn) {
  let hex = bn.toString(16);
  if (hex.length % 2 > 0) {
    hex = `0${hex}`;
  }
  const len2 = hex.length / 2;
  const u8 = new Uint8Array(len2);
  let i = 0;
  let j = 0;
  while (i < len2) {
    u8[i] = parseInt(hex.slice(j, j + 2), 16);
    i += 1;
    j += 2;
  }
  return u8;
}
function bufToBn(u8) {
  const hex = [];
  u8.forEach(function(i) {
    let h2 = i.toString(16);
    if (h2.length % 2 > 0) {
      h2 = `0${h2}`;
    }
    hex.push(h2);
  });
  return BigInt("0x" + hex.join(""));
}
const SALT_LENGTH = 16;
const KEY_SIZE = 32;
const ITERATIONS = 1e4;
async function exportToPem(privateKey, password) {
  const crypto2 = webcrypto.get();
  const keyWrapper = new Sequence({
    value: [
      // version (0)
      new Integer({ value: 0 }),
      // privateKeyAlgorithm
      new Sequence({
        value: [
          // rsaEncryption OID
          new ObjectIdentifier({
            value: "1.2.840.113549.1.1.1"
          }),
          new Null()
        ]
      }),
      // PrivateKey
      new OctetString({
        valueHex: privateKey.marshal()
      })
    ]
  });
  const keyBuf = keyWrapper.toBER();
  const keyArr = new Uint8Array(keyBuf, 0, keyBuf.byteLength);
  const salt = randomBytes(SALT_LENGTH);
  const encryptionKey = await pbkdf2Async(sha512, password, salt, {
    c: ITERATIONS,
    dkLen: KEY_SIZE
  });
  const iv = randomBytes(16);
  const cryptoKey = await crypto2.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["encrypt"]);
  const encrypted = await crypto2.subtle.encrypt({
    name: "AES-CBC",
    iv
  }, cryptoKey, keyArr);
  const pbkdf2Params = new Sequence({
    value: [
      // salt
      new OctetString({ valueHex: salt }),
      // iteration count
      new Integer({ value: ITERATIONS }),
      // key length
      new Integer({ value: KEY_SIZE }),
      // AlgorithmIdentifier
      new Sequence({
        value: [
          // hmacWithSHA512
          new ObjectIdentifier({ value: "1.2.840.113549.2.11" }),
          new Null()
        ]
      })
    ]
  });
  const encryptionAlgorithm = new Sequence({
    value: [
      // pkcs5PBES2
      new ObjectIdentifier({
        value: "1.2.840.113549.1.5.13"
      }),
      new Sequence({
        value: [
          // keyDerivationFunc
          new Sequence({
            value: [
              // pkcs5PBKDF2
              new ObjectIdentifier({
                value: "1.2.840.113549.1.5.12"
              }),
              // PBKDF2-params
              pbkdf2Params
            ]
          }),
          // encryptionScheme
          new Sequence({
            value: [
              // aes256-CBC
              new ObjectIdentifier({
                value: "2.16.840.1.101.3.4.1.42"
              }),
              // iv
              new OctetString({
                valueHex: iv
              })
            ]
          })
        ]
      })
    ]
  });
  const finalWrapper = new Sequence({
    value: [
      encryptionAlgorithm,
      new OctetString({ valueHex: encrypted })
    ]
  });
  const finalWrapperBuf = finalWrapper.toBER();
  const finalWrapperArr = new Uint8Array(finalWrapperBuf, 0, finalWrapperBuf.byteLength);
  return [
    "-----BEGIN ENCRYPTED PRIVATE KEY-----",
    ...toString$2(finalWrapperArr, "base64pad").split(/(.{64})/).filter(Boolean),
    "-----END ENCRYPTED PRIVATE KEY-----"
  ].join("\n");
}
async function generateKey$1(bits) {
  const pair = await webcrypto.get().subtle.generateKey({
    name: "RSASSA-PKCS1-v1_5",
    modulusLength: bits,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: { name: "SHA-256" }
  }, true, ["sign", "verify"]);
  const keys = await exportKey(pair);
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function unmarshalPrivateKey(key) {
  const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["sign"]);
  const pair = [
    privateKey,
    await derivePublicFromPrivate(key)
  ];
  const keys = await exportKey({
    privateKey: pair[0],
    publicKey: pair[1]
  });
  return {
    privateKey: keys[0],
    publicKey: keys[1]
  };
}
async function hashAndSign$1(key, msg) {
  const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["sign"]);
  const sig = await webcrypto.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
  return new Uint8Array(sig, 0, sig.byteLength);
}
async function hashAndVerify$1(key, sig, msg) {
  const publicKey = await webcrypto.get().subtle.importKey("jwk", key, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, false, ["verify"]);
  return webcrypto.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
}
async function exportKey(pair) {
  if (pair.privateKey == null || pair.publicKey == null) {
    throw new CodeError("Private and public key are required", "ERR_INVALID_PARAMETERS");
  }
  return Promise.all([
    webcrypto.get().subtle.exportKey("jwk", pair.privateKey),
    webcrypto.get().subtle.exportKey("jwk", pair.publicKey)
  ]);
}
async function derivePublicFromPrivate(jwKey) {
  return webcrypto.get().subtle.importKey("jwk", {
    kty: jwKey.kty,
    n: jwKey.n,
    e: jwKey.e
  }, {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  }, true, ["verify"]);
}
function keySize(jwk) {
  if (jwk.kty !== "RSA") {
    throw new CodeError("invalid key type", "ERR_INVALID_KEY_TYPE");
  } else if (jwk.n == null) {
    throw new CodeError("invalid key modulus", "ERR_INVALID_KEY_MODULUS");
  }
  const bytes2 = fromString$1(jwk.n, "base64url");
  return bytes2.length * 8;
}
const MAX_RSA_KEY_SIZE = 8192;
class RsaPublicKey {
  constructor(key) {
    __publicField(this, "_key");
    this._key = key;
  }
  verify(data, sig) {
    return hashAndVerify$1(this._key, sig, data);
  }
  marshal() {
    return jwkToPkix(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  hash() {
    const p = sha256$1.digest(this.bytes);
    if (isPromise$1(p)) {
      return p.then(({ bytes: bytes2 }) => bytes2);
    }
    return p.bytes;
  }
}
class RsaPrivateKey {
  constructor(key, publicKey) {
    __publicField(this, "_key");
    __publicField(this, "_publicKey");
    this._key = key;
    this._publicKey = publicKey;
  }
  genSecret() {
    return randomBytes(16);
  }
  sign(message2) {
    return hashAndSign$1(this._key, message2);
  }
  get public() {
    if (this._publicKey == null) {
      throw new CodeError("public key not provided", "ERR_PUBKEY_NOT_PROVIDED");
    }
    return new RsaPublicKey(this._publicKey);
  }
  marshal() {
    return jwkToPkcs1(this._key);
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.RSA,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  hash() {
    const p = sha256$1.digest(this.bytes);
    if (isPromise$1(p)) {
      return p.then(({ bytes: bytes2 }) => bytes2);
    }
    return p.bytes;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash2 = await this.public.hash();
    return toString$2(hash2, "base58btc");
  }
  /**
   * Exports the key as libp2p-key - a aes-gcm encrypted value with the key
   * derived from the password.
   *
   * To export it as a password protected PEM file, please use the `exportPEM`
   * function from `@libp2p/rsa`.
   */
  async export(password, format = "pkcs-8") {
    if (format === "pkcs-8") {
      return exportToPem(this, password);
    } else if (format === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
}
async function unmarshalRsaPrivateKey(bytes2) {
  const jwk = pkcs1ToJwk(bytes2);
  if (keySize(jwk) > MAX_RSA_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await unmarshalPrivateKey(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
function unmarshalRsaPublicKey(bytes2) {
  const jwk = pkixToJwk(bytes2);
  if (keySize(jwk) > MAX_RSA_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  return new RsaPublicKey(jwk);
}
async function fromJwk(jwk) {
  if (keySize(jwk) > MAX_RSA_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await unmarshalPrivateKey(jwk);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
async function generateKeyPair$1(bits) {
  if (bits > MAX_RSA_KEY_SIZE) {
    throw new CodeError("key size is too large", "ERR_KEY_SIZE_TOO_LARGE");
  }
  const keys = await generateKey$1(bits);
  return new RsaPrivateKey(keys.privateKey, keys.publicKey);
}
const RSA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MAX_RSA_KEY_SIZE,
  RsaPrivateKey,
  RsaPublicKey,
  fromJwk,
  generateKeyPair: generateKeyPair$1,
  unmarshalRsaPrivateKey,
  unmarshalRsaPublicKey
}, Symbol.toStringTag, { value: "Module" }));
const SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E: E2, F, G: G2, H } = this;
    return [A, B, C, D, E2, F, G2, H];
  }
  // prettier-ignore
  set(A, B, C, D, E2, F, G2, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E2 | 0;
    this.F = F | 0;
    this.G = G2 | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E: E2, F, G: G2, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H + sigma1 + Chi(E2, F, G2) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G2;
      G2 = F;
      F = E2;
      E2 = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E2 = E2 + this.E | 0;
    F = F + this.F | 0;
    G2 = G2 + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E2, F, G2, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
const DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  },
  _parseInt(data) {
    const { Err: E2 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E2("Invalid signature integer tag");
    const len2 = data[1];
    const res = data.subarray(2, len2 + 2);
    if (!len2 || res.length !== len2)
      throw new E2("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E2("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E2("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len2 + 2) };
  },
  toSig(hex) {
    const { Err: E2 } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    abytes(data);
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E2("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E2("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s2, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E2("Invalid signature: left bytes after parsing");
    return { r, s: s2 };
  },
  hexFromSig(sig) {
    const slice2 = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
    const h2 = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s2 = slice2(h2(sig.s));
    const r = slice2(h2(sig.r));
    const shl = s2.length / 2;
    const rhl = r.length / 2;
    const sl = h2(shl);
    const rl = h2(rhl);
    return `30${h2(rhl + shl + 4)}02${rl}${r}02${sl}${s2}`;
  }
};
const _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y: y2 };
  });
  function weierstrassEquation(x2) {
    const { a, b } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return inRange(num, _1n$1, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N10 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes(key))
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, N10);
    aInRange("private key", num, _1n$1, N10);
    return num;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x2, py: y2, pz: z } = p;
    if (Fp2.eql(z, Fp2.ONE))
      return { x: x2, y: y2 };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp2.ONE : Fp2.inv(z);
    const ax = Fp2.mul(x2, iz);
    const ay = Fp2.mul(y2, iz);
    const zz = Fp2.mul(z, iz);
    if (is0)
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    if (!Fp2.eql(zz, Fp2.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp2.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x2, y: y2 } = p.toAffine();
    if (!Fp2.isValid(x2) || !Fp2.isValid(y2))
      throw new Error("bad point: x or y not FE");
    const left = Fp2.sqr(y2);
    const right = weierstrassEquation(x2);
    if (!Fp2.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x: x2, y: y2 } = p || {};
      if (!p || !Fp2.isValid(x2) || !Fp2.isValid(y2))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x2) && is0(y2))
        return Point.ZERO;
      return new Point(x2, y2, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y2 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y2);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      aInRange("scalar", sc, _0n, CURVE.n);
      const I = Point.ZERO;
      if (sc === _0n)
        return I;
      if (sc === _1n$1)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, sc);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d2 = this;
      while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n$1)
          k1p = k1p.add(d2);
        if (k2 & _1n$1)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N10 } = CURVE;
      aInRange("scalar", scalar, _1n$1, N10);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(scalar);
        point = p;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G2 = Point.BASE;
      const mul = (P, a2) => a2 === _0n || a2 === _1n$1 || !P.equals(G2) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c2, point, isCompressed) {
      const a = point.toAffine();
      const x2 = Fp2.toBytes(a.x);
      const cat2 = concatBytes;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat2(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat2(Uint8Array.from([4]), x2, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes2) {
      const len2 = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len2 === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE(tail);
        if (!inRange(x2, _1n$1, Fp2.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y3;
        try {
          y3 = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y3 & _1n$1) === _1n$1;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y3 = Fp2.neg(y3);
        return { x: x2, y: y3 };
      } else if (len2 === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y: y2 };
      } else {
        throw new Error(`Point of length ${len2} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s2) {
    return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
  }
  const slcNum = (b, from2, to) => bytesToNumberBE(b.slice(from2, to));
  class Signature {
    constructor(r, s2, recovery) {
      this.r = r;
      this.s = s2;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s: s2 } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s2);
    }
    assertValidity() {
      aInRange("r", this.r, _1n$1, CURVE_ORDER);
      aInRange("s", this.s, _1n$1, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s: s2, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s2 * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length2 = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length2), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes(item);
    const str = typeof item === "string";
    const len2 = (arr || str) && item.length;
    if (arr)
      return len2 === compressedLen || len2 === uncompressedLen;
    if (str)
      return len2 === 2 * compressedLen || len2 === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n, ORDER_MASK);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m2 = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q2 = Point.BASE.multiply(k).toAffine();
      const r = modN(q2.x);
      if (r === _0n)
        return;
      const s2 = modN(ik * modN(m2 + r * d2));
      if (s2 === _0n)
        return;
      let recovery = (q2.x === r ? 0 : 2) | Number(q2.y & _1n$1);
      let normS = s2;
      if (lowS && isBiggerThanHalfOrder(s2)) {
        normS = normalizeS(s2);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a3;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    validateSigVerOpts(opts);
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || isBytes(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s3 } = sg;
        _sig = new Signature(r2, s3);
      } else {
        throw new Error("PARSE");
      }
      P = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s: s2 } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is2 = invN(s2);
    const u1 = modN(h2 * is2);
    const u2 = modN(r * is2);
    const R = (_a3 = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a3.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes$1(...msgs)),
    randomBytes: randomBytes$1
  };
}
function createCurve(curveDef, defHash) {
  const create2 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create2(defHash), create: create2 });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b) => (a + b / _2n) / b;
function sqrtMod(y2) {
  const P = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y2 * y2 * y2 % P;
  const b3 = b2 * b2 * y2 % P;
  const b6 = pow2(b3, _3n2, P) * b3 % P;
  const b9 = pow2(b6, _3n2, P) * b3 % P;
  const b11 = pow2(b9, _2n, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n2, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root2 = pow2(t2, _2n, P);
  if (!Fp.eql(Fp.sqr(root2), y2))
    throw new Error("Cannot find square root");
  return root2;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
BigInt(0);
secp256k1.ProjectivePoint;
function generateKey() {
  return secp256k1.utils.randomPrivateKey();
}
function hashAndSign(key, msg) {
  const p = sha256$1.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise$1(p)) {
    return p.then(({ digest: digest2 }) => secp256k1.sign(digest2, key).toDERRawBytes()).catch((err) => {
      throw new CodeError(String(err), "ERR_INVALID_INPUT");
    });
  }
  try {
    return secp256k1.sign(p.digest, key).toDERRawBytes();
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_INPUT");
  }
}
function hashAndVerify(key, sig, msg) {
  const p = sha256$1.digest(msg instanceof Uint8Array ? msg : msg.subarray());
  if (isPromise$1(p)) {
    return p.then(({ digest: digest2 }) => secp256k1.verify(sig, digest2, key)).catch((err) => {
      throw new CodeError(String(err), "ERR_INVALID_INPUT");
    });
  }
  try {
    return secp256k1.verify(sig, p.digest, key);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_INPUT");
  }
}
function compressPublicKey(key) {
  const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
  return point;
}
function validatePrivateKey(key) {
  try {
    secp256k1.getPublicKey(key, true);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PRIVATE_KEY");
  }
}
function validatePublicKey(key) {
  try {
    secp256k1.ProjectivePoint.fromHex(key);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PUBLIC_KEY");
  }
}
function computePublicKey(privateKey) {
  try {
    return secp256k1.getPublicKey(privateKey, true);
  } catch (err) {
    throw new CodeError(String(err), "ERR_INVALID_PRIVATE_KEY");
  }
}
class Secp256k1PublicKey {
  constructor(key) {
    __publicField(this, "_key");
    validatePublicKey(key);
    this._key = key;
  }
  verify(data, sig) {
    return hashAndVerify(this._key, sig, data);
  }
  marshal() {
    return compressPublicKey(this._key);
  }
  get bytes() {
    return PublicKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  async hash() {
    const p = sha256$1.digest(this.bytes);
    let bytes2;
    if (isPromise$1(p)) {
      ({ bytes: bytes2 } = await p);
    } else {
      bytes2 = p.bytes;
    }
    return bytes2;
  }
}
class Secp256k1PrivateKey {
  constructor(key, publicKey) {
    __publicField(this, "_key");
    __publicField(this, "_publicKey");
    this._key = key;
    this._publicKey = publicKey ?? computePublicKey(key);
    validatePrivateKey(this._key);
    validatePublicKey(this._publicKey);
  }
  sign(message2) {
    return hashAndSign(this._key, message2);
  }
  get public() {
    return new Secp256k1PublicKey(this._publicKey);
  }
  marshal() {
    return this._key;
  }
  get bytes() {
    return PrivateKey.encode({
      Type: KeyType.Secp256k1,
      Data: this.marshal()
    }).subarray();
  }
  equals(key) {
    return equals(this.bytes, key.bytes);
  }
  hash() {
    const p = sha256$1.digest(this.bytes);
    if (isPromise$1(p)) {
      return p.then(({ bytes: bytes2 }) => bytes2);
    }
    return p.bytes;
  }
  /**
   * Gets the ID of the key.
   *
   * The key id is the base58 encoding of the SHA-256 multihash of its public key.
   * The public key is a protobuf encoding containing a type and the DER encoding
   * of the PKCS SubjectPublicKeyInfo.
   */
  async id() {
    const hash2 = await this.public.hash();
    return toString$2(hash2, "base58btc");
  }
  /**
   * Exports the key into a password protected `format`
   */
  async export(password, format = "libp2p-key") {
    if (format === "libp2p-key") {
      return exporter(this.bytes, password);
    } else {
      throw new CodeError(`export format '${format}' is not supported`, "ERR_INVALID_EXPORT_FORMAT");
    }
  }
}
function unmarshalSecp256k1PrivateKey(bytes2) {
  return new Secp256k1PrivateKey(bytes2);
}
function unmarshalSecp256k1PublicKey(bytes2) {
  return new Secp256k1PublicKey(bytes2);
}
async function generateKeyPair() {
  const privateKeyBytes = generateKey();
  return new Secp256k1PrivateKey(privateKeyBytes);
}
const Secp256k1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Secp256k1PrivateKey,
  Secp256k1PublicKey,
  generateKeyPair,
  unmarshalSecp256k1PrivateKey,
  unmarshalSecp256k1PublicKey
}, Symbol.toStringTag, { value: "Module" }));
const supportedKeys = {
  rsa: RSA,
  ed25519: Ed25519,
  secp256k1: Secp256k1
};
function unsupportedKey(type) {
  const supported = Object.keys(supportedKeys).join(" / ");
  return new CodeError(`invalid or unsupported key type ${type}. Must be ${supported}`, "ERR_UNSUPPORTED_KEY_TYPE");
}
function unmarshalPublicKey(buf2) {
  const decoded = PublicKey.decode(buf2);
  const data = decoded.Data ?? new Uint8Array();
  switch (decoded.Type) {
    case KeyType.RSA:
      return supportedKeys.rsa.unmarshalRsaPublicKey(data);
    case KeyType.Ed25519:
      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
    case KeyType.Secp256k1:
      return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
    default:
      throw unsupportedKey(decoded.Type ?? "unknown");
  }
}
function getTypes(types2) {
  const DEFAULT_TYPES = [
    RecordType.A
  ];
  if (types2 == null) {
    return DEFAULT_TYPES;
  }
  if (Array.isArray(types2)) {
    if (types2.length === 0) {
      return DEFAULT_TYPES;
    }
    return types2;
  }
  return [
    types2
  ];
}
const DEFAULT_TTL = 60;
function toDNSResponse(obj) {
  return {
    Status: obj.Status ?? 0,
    TC: obj.TC ?? obj.flag_tc ?? false,
    RD: obj.RD ?? obj.flag_rd ?? false,
    RA: obj.RA ?? obj.flag_ra ?? false,
    AD: obj.AD ?? obj.flag_ad ?? false,
    CD: obj.CD ?? obj.flag_cd ?? false,
    Question: (obj.Question ?? obj.questions ?? []).map((question) => {
      return {
        name: question.name,
        type: RecordType[question.type]
      };
    }),
    Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
      return {
        name: answer.name,
        type: RecordType[answer.type],
        TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
        data: answer.data instanceof Uint8Array ? toString$2(answer.data) : answer.data
      };
    })
  };
}
const DEFAULT_QUERY_CONCURRENCY = 4;
function dnsJsonOverHttps(url, init = {}) {
  const httpQueue = new PQueue({
    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
  });
  return async (fqdn, options2 = {}) => {
    var _a3;
    const searchParams = new URLSearchParams();
    searchParams.set("name", fqdn);
    getTypes(options2.types).forEach((type) => {
      searchParams.append("type", RecordType[type]);
    });
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("dns:query", { detail: fqdn }));
    const response = await httpQueue.add(async () => {
      var _a4;
      const res = await fetch(`${url}?${searchParams}`, {
        headers: {
          accept: "application/dns-json"
        },
        signal: options2 == null ? void 0 : options2.signal
      });
      if (res.status !== 200) {
        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
      }
      const response2 = toDNSResponse(await res.json());
      (_a4 = options2.onProgress) == null ? void 0 : _a4.call(options2, new CustomProgressEvent("dns:response", { detail: response2 }));
      return response2;
    }, {
      signal: options2.signal
    });
    if (response == null) {
      throw new Error("No DNS response received");
    }
    return response;
  };
}
function defaultResolver() {
  return [
    dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
    dnsJsonOverHttps("https://dns.google/resolve")
  ];
}
var hashlru = function(max) {
  if (!max) throw Error("hashlru must have a max value, of type number, greater than 0");
  var size = 0, cache2 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
  function update(key, value) {
    cache2[key] = value;
    size++;
    if (size >= max) {
      size = 0;
      _cache = cache2;
      cache2 = /* @__PURE__ */ Object.create(null);
    }
  }
  return {
    has: function(key) {
      return cache2[key] !== void 0 || _cache[key] !== void 0;
    },
    remove: function(key) {
      if (cache2[key] !== void 0)
        cache2[key] = void 0;
      if (_cache[key] !== void 0)
        _cache[key] = void 0;
    },
    get: function(key) {
      var v = cache2[key];
      if (v !== void 0) return v;
      if ((v = _cache[key]) !== void 0) {
        update(key, v);
        return v;
      }
    },
    set: function(key, value) {
      if (cache2[key] !== void 0) cache2[key] = value;
      else update(key, value);
    },
    clear: function() {
      cache2 = /* @__PURE__ */ Object.create(null);
      _cache = /* @__PURE__ */ Object.create(null);
    }
  };
};
const hashlru$1 = /* @__PURE__ */ getDefaultExportFromCjs(hashlru);
class CachedAnswers {
  constructor(maxSize) {
    __publicField(this, "lru");
    this.lru = hashlru$1(maxSize);
  }
  get(fqdn, types2) {
    let foundAllAnswers = true;
    const answers = [];
    for (const type of types2) {
      const cached = this.getAnswers(fqdn, type);
      if (cached.length === 0) {
        foundAllAnswers = false;
        break;
      }
      answers.push(...cached);
    }
    if (foundAllAnswers) {
      return toDNSResponse({ answers });
    }
  }
  getAnswers(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    const answers = this.lru.get(key);
    if (answers != null) {
      const cachedAnswers = answers.filter((entry) => {
        return entry.expires > Date.now();
      }).map(({ expires, value }) => ({
        ...value,
        TTL: Math.round((expires - Date.now()) / 1e3),
        type: RecordType[value.type]
      }));
      if (cachedAnswers.length === 0) {
        this.lru.remove(key);
      }
      return cachedAnswers;
    }
    return [];
  }
  add(domain, answer) {
    const key = `${domain.toLowerCase()}-${answer.type}`;
    const answers = this.lru.get(key) ?? [];
    answers.push({
      expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
      value: answer
    });
    this.lru.set(key, answers);
  }
  remove(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
}
function cache(size) {
  return new CachedAnswers(size);
}
const DEFAULT_ANSWER_CACHE_SIZE = 1e3;
let DNS$1 = class DNS {
  constructor(init) {
    __publicField(this, "resolvers");
    __publicField(this, "cache");
    this.resolvers = {};
    this.cache = cache(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
      if (!Array.isArray(resolver)) {
        resolver = [resolver];
      }
      if (!tld.endsWith(".")) {
        tld = `${tld}.`;
      }
      this.resolvers[tld] = resolver;
    });
    if (this.resolvers["."] == null) {
      this.resolvers["."] = defaultResolver();
    }
  }
  /**
   * Queries DNS resolvers for the passed record types for the passed domain.
   *
   * If cached records exist for all desired types they will be returned
   * instead.
   *
   * Any new responses will be added to the cache for subsequent requests.
   */
  async query(domain, options2 = {}) {
    var _a3, _b2, _c2;
    const types2 = getTypes(options2.types);
    const cached = options2.cached !== false ? this.cache.get(domain, types2) : void 0;
    if (cached != null) {
      (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("dns:cache", { detail: cached }));
      return cached;
    }
    const tld = `${domain.split(".").pop()}.`;
    const resolvers2 = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
      return Math.random() > 0.5 ? -1 : 1;
    });
    const errors2 = [];
    for (const resolver of resolvers2) {
      if (((_b2 = options2.signal) == null ? void 0 : _b2.aborted) === true) {
        break;
      }
      try {
        const result = await resolver(domain, {
          ...options2,
          types: types2
        });
        for (const answer of result.Answer) {
          this.cache.add(domain, answer);
        }
        return result;
      } catch (err) {
        errors2.push(err);
        (_c2 = options2.onProgress) == null ? void 0 : _c2.call(options2, new CustomProgressEvent("dns:error", { detail: err }));
      }
    }
    if (errors2.length === 1) {
      throw errors2[0];
    }
    throw new AggregateError(errors2, `DNS lookup of ${domain} ${types2} failed`);
  }
};
var RecordType;
(function(RecordType2) {
  RecordType2[RecordType2["A"] = 1] = "A";
  RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
  RecordType2[RecordType2["TXT"] = 16] = "TXT";
  RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
})(RecordType || (RecordType = {}));
function dns(init = {}) {
  return new DNS$1(init);
}
const DATASTORE_PIN_PREFIX = "/pin/";
const DATASTORE_BLOCK_PREFIX = "/pinned-block/";
const DATASTORE_ENCODING = base36;
const DAG_WALK_QUEUE_CONCURRENCY = 1;
function toDSKey(cid) {
  if (cid.version === 0) {
    cid = cid.toV1();
  }
  return new Key(`${DATASTORE_PIN_PREFIX}${cid.toString(DATASTORE_ENCODING)}`);
}
class PinsImpl {
  constructor(datastore, blockstore, dagWalkers) {
    __privateAdd(this, _PinsImpl_instances);
    __publicField(this, "datastore");
    __publicField(this, "blockstore");
    __publicField(this, "dagWalkers");
    this.datastore = datastore;
    this.blockstore = blockstore;
    this.dagWalkers = dagWalkers;
  }
  async *add(cid, options2 = {}) {
    const pinKey = toDSKey(cid);
    if (await this.datastore.has(pinKey)) {
      throw new Error("Already pinned");
    }
    const depth = Math.round(options2.depth ?? Infinity);
    if (depth < 0) {
      throw new Error("Depth must be greater than or equal to 0");
    }
    const queue = new Queue$1({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY
    });
    for await (const childCid of __privateMethod(this, _PinsImpl_instances, walkDag_fn2).call(this, cid, queue, {
      ...options2,
      depth
    })) {
      await __privateMethod(this, _PinsImpl_instances, updatePinnedBlock_fn).call(this, childCid, (pinnedBlock) => {
        if (pinnedBlock.pinnedBy.find((c) => equals(c, cid.bytes)) != null) {
          return false;
        }
        pinnedBlock.pinCount++;
        pinnedBlock.pinnedBy.push(cid.bytes);
        return true;
      }, options2);
      yield childCid;
    }
    const pin = {
      depth,
      metadata: options2.metadata ?? {}
    };
    await this.datastore.put(pinKey, encode$2(pin), options2);
  }
  async *rm(cid, options2 = {}) {
    const pinKey = toDSKey(cid);
    const buf2 = await this.datastore.get(pinKey, options2);
    const pin = decode$5(buf2);
    await this.datastore.delete(pinKey, options2);
    const queue = new Queue$1({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY
    });
    for await (const childCid of __privateMethod(this, _PinsImpl_instances, walkDag_fn2).call(this, cid, queue, {
      ...options2,
      depth: pin.depth
    })) {
      await __privateMethod(this, _PinsImpl_instances, updatePinnedBlock_fn).call(this, childCid, (pinnedBlock) => {
        pinnedBlock.pinCount--;
        pinnedBlock.pinnedBy = pinnedBlock.pinnedBy.filter((c) => equals(c, cid.bytes));
        return true;
      }, {
        ...options2,
        depth: pin.depth
      });
      yield childCid;
    }
  }
  async *ls(options2 = {}) {
    for await (const { key, value } of this.datastore.query({
      prefix: DATASTORE_PIN_PREFIX + (options2.cid != null ? `${options2.cid.toString(base36)}` : "")
    }, options2)) {
      const cid = CID.parse(key.toString().substring(5), base36);
      const pin = decode$5(value);
      yield {
        cid,
        ...pin
      };
    }
  }
  async isPinned(cid, options2 = {}) {
    const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
    return this.datastore.has(blockKey, options2);
  }
}
_PinsImpl_instances = new WeakSet();
walkDag_fn2 = async function* (cid, queue, options2) {
  if (options2.depth === -1) {
    return;
  }
  const dagWalker = this.dagWalkers[cid.code];
  if (dagWalker == null) {
    throw new Error(`No dag walker found for cid codec ${cid.code}`);
  }
  const block = await this.blockstore.get(cid, options2);
  yield cid;
  for await (const cid2 of dagWalker.walk(block)) {
    yield* await queue.add(async () => {
      return __privateMethod(this, _PinsImpl_instances, walkDag_fn2).call(this, cid2, queue, {
        ...options2,
        depth: options2.depth - 1
      });
    });
  }
};
updatePinnedBlock_fn = async function(cid, withPinnedBlock, options2) {
  var _a3;
  const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
  let pinnedBlock = {
    pinCount: 0,
    pinnedBy: []
  };
  try {
    pinnedBlock = decode$5(await this.datastore.get(blockKey, options2));
  } catch (err) {
    if (err.code !== "ERR_NOT_FOUND") {
      throw err;
    }
  }
  const shouldContinue = withPinnedBlock(pinnedBlock);
  if (!shouldContinue) {
    return;
  }
  if (pinnedBlock.pinCount === 0) {
    if (await this.datastore.has(blockKey)) {
      await this.datastore.delete(blockKey);
      return;
    }
  }
  await this.datastore.put(blockKey, encode$2(pinnedBlock), options2);
  (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("helia:pin:add", cid));
};
const DEFAULT_PROVIDER_LOOKUP_CONCURRENCY = 5;
class Routing {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "routers");
    __publicField(this, "providerLookupConcurrency");
    this.log = components.logger.forComponent("helia:routing");
    this.routers = init.routers ?? [];
    this.providerLookupConcurrency = init.providerLookupConcurrency ?? DEFAULT_PROVIDER_LOOKUP_CONCURRENCY;
  }
  async start() {
    await start(...this.routers);
  }
  async stop() {
    await stop(...this.routers);
  }
  /**
   * Iterates over all content routers in parallel to find providers of the
   * given key
   */
  async *findProviders(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No content routers available", "ERR_NO_ROUTERS_AVAILABLE");
    }
    const queue = new PeerQueue({
      concurrency: this.providerLookupConcurrency
    });
    queue.addEventListener("error", () => {
    });
    for await (const peer of merge$1(queue.toGenerator(), ...supports(this.routers, "findProviders").map((router) => router.findProviders(key, options2)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length === 0) {
        if (queue.find(peer.id) != null) {
          continue;
        }
        queue.add(async () => {
          try {
            const provider = await this.findPeer(peer.id, options2);
            if (provider.multiaddrs.length === 0) {
              return null;
            }
            return provider;
          } catch (err) {
            this.log.error("could not load multiaddrs for peer %p", peer.id, err);
            return null;
          }
        }, {
          peerId: peer.id,
          signal: options2.signal
        }).catch((err) => {
          this.log.error("could not load multiaddrs for peer %p", peer.id, err);
        });
      }
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No content routers available", "ERR_NO_ROUTERS_AVAILABLE");
    }
    await Promise.all(supports(this.routers, "provide").map(async (router) => {
      await router.provide(key, options2);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value, options2) {
    await Promise.all(supports(this.routers, "put").map(async (router) => {
      await router.put(key, value, options2);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options2) {
    return Promise.any(supports(this.routers, "get").map(async (router) => {
      return router.get(key, options2);
    }));
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id2, options2) {
    if (this.routers.length === 0) {
      throw new CodeError("No peer routers available", "ERR_NO_ROUTERS_AVAILABLE");
    }
    const self2 = this;
    const source = merge$1(...supports(this.routers, "findPeer").map((router) => async function* () {
      try {
        yield await router.findPeer(id2, options2);
      } catch (err) {
        self2.log.error(err);
      }
    }()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      return peer;
    }
    throw new CodeError("Could not find peer in routing", "ERR_NOT_FOUND");
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new CodeError("No peer routers available", "ERR_NO_ROUTERS_AVAILABLE");
    }
    for await (const peer of merge$1(...supports(this.routers, "getClosestPeers").map((router) => router.getClosestPeers(key, options2)))) {
      if (peer == null) {
        continue;
      }
      yield peer;
    }
  }
}
function supports(routers, key) {
  return routers.filter((router) => router[key] != null);
}
const events = {};
const observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
const WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
const WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
const MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
const WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
const WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
const MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
const nanoid = (size = 21) => {
  return Math.random().toString().substring(2);
};
const handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          await new Promise((resolve2) => {
            const releaseEventListener = (event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve2();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
const makeWorkerLockRequest = (name2, requestType, grantType, releaseType) => {
  return async () => {
    const id2 = nanoid();
    globalThis.postMessage({
      type: requestType,
      identifier: id2,
      name: name2
    });
    return new Promise((resolve2) => {
      const listener = (event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id2) {
          globalThis.removeEventListener("message", listener);
          resolve2(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id2,
              name: name2
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
const defaultOptions$1 = {
  singleProcess: false
};
const impl = (options2) => {
  options2 = Object.assign({}, defaultOptions$1, options2);
  const isPrimary = Boolean(globalThis.document) || options2.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    observable.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    observable.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};
const mutexes = {};
let implementation;
async function createReleaseable(queue, options2) {
  let res;
  const p = new Promise((resolve2) => {
    res = resolve2;
  });
  void queue.add(async () => pTimeout((async () => {
    await new Promise((resolve2) => {
      res(() => {
        resolve2();
      });
    });
  })(), {
    milliseconds: options2.timeout
  }));
  return p;
}
const createMutex = (name2, options2) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name2, options2),
      writeLock: implementation.writeLock(name2, options2)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return createReleaseable(readQueue, options2);
      }
      readQueue = new PQueue({
        concurrency: options2.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options2);
      void masterQueue.add(async () => {
        localReadQueue.start();
        await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return readPromise;
    },
    async writeLock() {
      readQueue = null;
      return createReleaseable(masterQueue, options2);
    }
  };
};
const defaultOptions = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options2) {
  const opts = Object.assign({}, defaultOptions, options2);
  if (implementation == null) {
    implementation = impl(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => event.data.handler().finally(() => {
          release();
        }));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => event.data.handler().finally(() => {
          release();
        }));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}
class BlockStorage {
  /**
   * Create a new BlockStorage
   */
  constructor(blockstore, pins, options2 = {}) {
    __publicField(this, "lock");
    __publicField(this, "child");
    __publicField(this, "pins");
    __publicField(this, "started");
    this.child = blockstore;
    this.pins = pins;
    this.lock = createMortice({
      singleProcess: options2.holdGcLock
    });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await start(this.child);
    this.started = true;
  }
  async stop() {
    await stop(this.child);
    this.started = false;
  }
  unwrap() {
    return this.child;
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    var _a3;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.put(cid, block, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    var _a3;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.putMany(blocks, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    var _a3;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.get(cid, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    var _a3;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.getMany(cids, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    var _a3;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    const releaseLock = await this.lock.writeLock();
    try {
      if (await this.pins.isPinned(cid)) {
        throw new Error("CID was pinned");
      }
      await this.child.delete(cid, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    var _a3;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    const releaseLock = await this.lock.writeLock();
    try {
      const storage2 = this;
      yield* this.child.deleteMany(async function* () {
        for await (const cid of cids) {
          if (await storage2.pins.isPinned(cid)) {
            throw new Error("CID was pinned");
          }
          yield cid;
        }
      }(), options2);
    } finally {
      releaseLock();
    }
  }
  async has(cid, options2 = {}) {
    var _a3;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.has(cid, options2);
    } finally {
      releaseLock();
    }
  }
  async *getAll(options2 = {}) {
    var _a3;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.getAll(options2);
    } finally {
      releaseLock();
    }
  }
  createSession(root2, options2) {
    var _a3;
    (_a3 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a3.throwIfAborted();
    return this.child.createSession(root2, options2);
  }
}
const dagPbWalker = {
  codec: code$5,
  *walk(block) {
    const node = decode$a(block);
    yield* node.Links.map((l) => l.Hash);
  }
};
const rawWalker = {
  codec: code$3,
  *walk() {
  }
};
const CID_TAG = 42;
const dagCborWalker = {
  codec: code$1,
  *walk(block) {
    const cids = [];
    const tags = [];
    tags[CID_TAG] = (bytes2) => {
      if (bytes2[0] !== 0) {
        throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
      }
      const cid = CID.decode(bytes2.subarray(1));
      cids.push(cid);
      return cid;
    };
    decode$5(block, {
      tags
    });
    yield* cids;
  }
};
class DagJsonTokenizer2 extends Tokenizer {
  constructor(data, options2) {
    super(data, options2);
    __publicField(this, "tokenBuffer");
    this.tokenBuffer = [];
  }
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   */
  next() {
    const token2 = this._next();
    if (token2.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token$1(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i = 0; i < 2; i++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes2 = base64.decode(`m${innerValueToken.value}`);
              return new Token$1(Type.bytes, bytes2, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token2;
  }
}
const dagJsonWalker = {
  codec: code,
  *walk(block) {
    const cids = [];
    const tags = [];
    tags[CID_TAG] = (string2) => {
      const cid = CID.parse(string2);
      cids.push(cid);
      return cid;
    };
    decode$3(block, {
      tags,
      tokenizer: new DagJsonTokenizer2(block, {
        tags,
        allowIndefinite: true,
        allowUndefined: true,
        allowNaN: true,
        allowInfinity: true,
        allowBigInt: true,
        strict: false,
        rejectDuplicateMapKeys: false
      })
    });
    yield* cids;
  }
};
const jsonWalker = {
  codec: code$4,
  *walk() {
  }
};
function defaultDagWalkers(walkers = []) {
  const output2 = {};
  [
    dagPbWalker,
    rawWalker,
    dagCborWalker,
    dagJsonWalker,
    jsonWalker,
    ...walkers
  ].forEach((dagWalker) => {
    output2[dagWalker.codec] = dagWalker;
  });
  return output2;
}
const DS_VERSION_KEY = new Key("/version");
const CURRENT_VERSION = 1;
async function assertDatastoreVersionIsCurrent(datastore) {
  if (!await datastore.has(DS_VERSION_KEY)) {
    await datastore.put(DS_VERSION_KEY, fromString$1(`${CURRENT_VERSION}`));
    return;
  }
  const buf2 = await datastore.get(DS_VERSION_KEY);
  const str = toString$2(buf2);
  const version2 = parseInt(str, 10);
  if (version2 !== CURRENT_VERSION) {
    throw new Error("Unknown datastore version, a datastore migration may be required");
  }
}
function defaultHashers(hashers = []) {
  const output2 = {};
  [
    sha256$1,
    sha512$1,
    identity,
    ...hashers
  ].forEach((hasher) => {
    output2[hasher.code] = hasher;
  });
  return output2;
}
class BaseBlockstore2 {
  has(key, options2) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  put(key, val, options2) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  async *putMany(source, options2) {
    for await (const { cid, block } of source) {
      await this.put(cid, block, options2);
      yield cid;
    }
  }
  get(key, options2) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  async *getMany(source, options2) {
    for await (const key of source) {
      yield {
        cid: key,
        block: await this.get(key, options2)
      };
    }
  }
  delete(key, options2) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *deleteMany(source, options2) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  async *getAll(options2) {
    throw new Error(".getAll is not implemented");
  }
}
function openFailedError(err) {
  err = err ?? new Error("Open failed");
  return errCode$1(err, "ERR_OPEN_FAILED");
}
function closeFailedError(err) {
  err = err ?? new Error("Close failed");
  return errCode$1(err, "ERR_CLOSE_FAILED");
}
function putFailedError(err) {
  err = err ?? new Error("Put failed");
  return errCode$1(err, "ERR_PUT_FAILED");
}
function getFailedError(err) {
  err = err ?? new Error("Get failed");
  return errCode$1(err, "ERR_GET_FAILED");
}
function deleteFailedError(err) {
  err = err ?? new Error("Delete failed");
  return errCode$1(err, "ERR_DELETE_FAILED");
}
function hasFailedError(err) {
  err = err ?? new Error("Has failed");
  return errCode$1(err, "ERR_HAS_FAILED");
}
function notFoundError$1(err) {
  err = err ?? new Error("Not Found");
  return errCode$1(err, "ERR_NOT_FOUND");
}
function abortedError(err) {
  err = err ?? new Error("Aborted");
  return errCode$1(err, "ERR_ABORTED");
}
const ErrorsImport = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  abortedError,
  closeFailedError,
  deleteFailedError,
  getFailedError,
  hasFailedError,
  notFoundError: notFoundError$1,
  openFailedError,
  putFailedError
}, Symbol.toStringTag, { value: "Module" }));
class MemoryBlockstore extends BaseBlockstore2 {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(base32$1.encode(key.multihash.bytes), val);
    return key;
  }
  get(key) {
    const buf2 = this.data.get(base32$1.encode(key.multihash.bytes));
    if (buf2 == null) {
      throw notFoundError$1();
    }
    return buf2;
  }
  has(key) {
    return this.data.has(base32$1.encode(key.multihash.bytes));
  }
  async delete(key) {
    this.data.delete(base32$1.encode(key.multihash.bytes));
  }
  async *getAll() {
    for (const [key, value] of this.data.entries()) {
      yield {
        cid: CID.createV1(code$3, decode$d(base32$1.decode(key))),
        block: value
      };
    }
  }
}
logger("blockstore:core:tiered");
const Errors = {
  ...ErrorsImport
};
const IDENTITY_CODEC = 0;
class IdentityBlockstore extends BaseBlockstore2 {
  constructor(child) {
    super();
    __publicField(this, "child");
    this.child = child;
  }
  put(key, block) {
    if (key.multihash.code === IDENTITY_CODEC) {
      return key;
    }
    if (this.child == null) {
      return key;
    }
    return this.child.put(key, block);
  }
  get(key) {
    if (key.multihash.code === IDENTITY_CODEC) {
      return key.multihash.digest;
    }
    if (this.child == null) {
      throw Errors.notFoundError();
    }
    return this.child.get(key);
  }
  has(key) {
    if (key.multihash.code === IDENTITY_CODEC) {
      return true;
    }
    if (this.child == null) {
      return false;
    }
    return this.child.has(key);
  }
  delete(key) {
    if (key.code === IDENTITY_CODEC) {
      return;
    }
    if (this.child != null) {
      return this.child.delete(key);
    }
  }
  getAll(options2) {
    if (this.child != null) {
      return this.child.getAll(options2);
    }
    return [];
  }
}
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function isPromise(thing) {
  return (thing == null ? void 0 : thing.then) != null;
}
function forEach(source, fn) {
  let index2 = 0;
  if (isAsyncIterable(source)) {
    return async function* () {
      for await (const val of source) {
        const res2 = fn(val, index2++);
        if (isPromise(res2)) {
          await res2;
        }
        yield val;
      }
    }();
  }
  const peekable$1 = peekable(source);
  const { value, done } = peekable$1.next();
  if (done === true) {
    return function* () {
    }();
  }
  const res = fn(value, index2++);
  if (typeof (res == null ? void 0 : res.then) === "function") {
    return async function* () {
      yield value;
      for await (const val of peekable$1) {
        const res2 = fn(val, index2++);
        if (isPromise(res2)) {
          await res2;
        }
        yield val;
      }
    }();
  }
  const func2 = fn;
  return function* () {
    yield value;
    for (const val of peekable$1) {
      func2(val, index2++);
      yield val;
    }
  }();
}
class Storage {
  /**
   * Create a new BlockStorage
   */
  constructor(components) {
    __publicField(this, "child");
    __publicField(this, "hashers");
    __publicField(this, "log");
    __publicField(this, "logger");
    __publicField(this, "components");
    this.log = components.logger.forComponent("helia:networked-storage");
    this.logger = components.logger;
    this.components = components;
    this.child = new IdentityBlockstore(components.blockstore);
    this.hashers = components.hashers ?? {};
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    var _a3, _b2, _c2;
    if (await this.child.has(cid, options2)) {
      (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("blocks:put:duplicate", cid));
      return cid;
    }
    (_b2 = options2.onProgress) == null ? void 0 : _b2.call(options2, new CustomProgressEvent("blocks:put:providers:notify", cid));
    await Promise.all(this.components.blockBrokers.map(async (broker) => {
      var _a4;
      return (_a4 = broker.announce) == null ? void 0 : _a4.call(broker, cid, block, options2);
    }));
    (_c2 = options2.onProgress) == null ? void 0 : _c2.call(options2, new CustomProgressEvent("blocks:put:blockstore:put", cid));
    return this.child.put(cid, block, options2);
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    var _a3;
    const missingBlocks = filter(blocks, async ({ cid }) => {
      var _a4;
      const has2 = await this.child.has(cid, options2);
      if (has2) {
        (_a4 = options2.onProgress) == null ? void 0 : _a4.call(options2, new CustomProgressEvent("blocks:put-many:duplicate", cid));
      }
      return !has2;
    });
    const notifyEach = forEach(missingBlocks, async ({ cid, block }) => {
      var _a4;
      (_a4 = options2.onProgress) == null ? void 0 : _a4.call(options2, new CustomProgressEvent("blocks:put-many:providers:notify", cid));
      await Promise.all(this.components.blockBrokers.map(async (broker) => {
        var _a5;
        return (_a5 = broker.announce) == null ? void 0 : _a5.call(broker, cid, block, options2);
      }));
    });
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("blocks:put-many:blockstore:put-many"));
    yield* this.child.putMany(notifyEach, options2);
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    var _a3, _b2, _c2, _d2;
    if (options2.offline !== true && !await this.child.has(cid, options2)) {
      (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("blocks:get:providers:get", cid));
      const block = await raceBlockRetrievers(cid, this.components.blockBrokers, this.hashers[cid.multihash.code], {
        ...options2,
        log: this.log
      });
      (_b2 = options2.onProgress) == null ? void 0 : _b2.call(options2, new CustomProgressEvent("blocks:get:blockstore:put", cid));
      await this.child.put(cid, block, options2);
      (_c2 = options2.onProgress) == null ? void 0 : _c2.call(options2, new CustomProgressEvent("blocks:get:providers:notify", cid));
      await Promise.all(this.components.blockBrokers.map(async (broker) => {
        var _a4;
        return (_a4 = broker.announce) == null ? void 0 : _a4.call(broker, cid, block, options2);
      }));
      return block;
    }
    (_d2 = options2.onProgress) == null ? void 0 : _d2.call(options2, new CustomProgressEvent("blocks:get:blockstore:get", cid));
    return this.child.get(cid, options2);
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    var _a3;
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("blocks:get-many:blockstore:get-many"));
    yield* this.child.getMany(forEach(cids, async (cid) => {
      var _a4, _b2, _c2;
      if (options2.offline !== true && !await this.child.has(cid, options2)) {
        (_a4 = options2.onProgress) == null ? void 0 : _a4.call(options2, new CustomProgressEvent("blocks:get-many:providers:get", cid));
        const block = await raceBlockRetrievers(cid, this.components.blockBrokers, this.hashers[cid.multihash.code], {
          ...options2,
          log: this.log
        });
        (_b2 = options2.onProgress) == null ? void 0 : _b2.call(options2, new CustomProgressEvent("blocks:get-many:blockstore:put", cid));
        await this.child.put(cid, block, options2);
        (_c2 = options2.onProgress) == null ? void 0 : _c2.call(options2, new CustomProgressEvent("blocks:get-many:providers:notify", cid));
        await Promise.all(this.components.blockBrokers.map(async (broker) => {
          var _a5;
          return (_a5 = broker.announce) == null ? void 0 : _a5.call(broker, cid, block, options2);
        }));
      }
    }));
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    var _a3;
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("blocks:delete:blockstore:delete", cid));
    await this.child.delete(cid, options2);
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    var _a3;
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("blocks:delete-many:blockstore:delete-many"));
    yield* this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cid;
      }
    }(), options2);
  }
  async has(cid, options2 = {}) {
    return this.child.has(cid, options2);
  }
  async *getAll(options2 = {}) {
    var _a3;
    (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("blocks:get-all:blockstore:get-many"));
    yield* this.child.getAll(options2);
  }
}
class NetworkedStorage extends Storage {
  /**
   * Create a new BlockStorage
   */
  constructor(components) {
    super(components);
    __publicField(this, "started");
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await start(this.child, ...this.components.blockBrokers);
    this.started = true;
  }
  async stop() {
    await stop(this.child, ...this.components.blockBrokers);
    this.started = false;
  }
  unwrap() {
    return this.child;
  }
  createSession(root2, options2) {
    const blockBrokers = this.components.blockBrokers.map((broker) => {
      if (broker.createSession == null) {
        return broker;
      }
      return broker.createSession(options2);
    });
    return new SessionStorage({
      blockstore: this.child,
      blockBrokers,
      hashers: this.hashers,
      logger: this.logger
    }, {
      root: root2
    });
  }
}
class SessionStorage extends Storage {
  constructor(components, init) {
    super(components);
    __publicField(this, "closeController");
    this.closeController = new AbortController();
    setMaxListeners(Infinity, this.closeController.signal);
    this.log = components.logger.forComponent(`helia:session-storage:${init.root}`);
  }
  close() {
    this.closeController.abort();
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      return await super.put(cid, block, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.putMany(blocks, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      return await super.get(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.getMany(cids, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      await super.delete(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.deleteMany(cids, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  async has(cid, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      return await super.has(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  async *getAll(options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.getAll({
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
}
function isRetrievingBlockBroker(broker) {
  return typeof broker.retrieve === "function";
}
const getCidBlockVerifierFunction = (cid, hasher) => {
  if (hasher == null) {
    throw new CodeError(`No hasher configured for multihash code 0x${cid.multihash.code.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`, "ERR_UNKNOWN_HASH_ALG");
  }
  return async (block) => {
    const hash2 = await hasher.digest(block);
    if (!equals(hash2.digest, cid.multihash.digest)) {
      throw new CodeError("Hash of downloaded block did not match multihash from passed CID", "ERR_HASH_MISMATCH");
    }
  };
};
async function raceBlockRetrievers(cid, blockBrokers, hasher, options2) {
  const validateFn = getCidBlockVerifierFunction(cid, hasher);
  const controller = new AbortController();
  const signal = anySignal([controller.signal, options2.signal]);
  setMaxListeners(Infinity, controller.signal, signal);
  const retrievers = [];
  for (const broker of blockBrokers) {
    if (isRetrievingBlockBroker(broker)) {
      retrievers.push(broker);
    }
  }
  try {
    return await Promise.any(retrievers.map(async (retriever) => {
      try {
        let blocksWereValidated = false;
        const block = await retriever.retrieve(cid, {
          ...options2,
          signal,
          validateFn: async (block2) => {
            await validateFn(block2);
            blocksWereValidated = true;
          }
        });
        if (!blocksWereValidated) {
          await validateFn(block);
        }
        return block;
      } catch (err) {
        options2.log.error("could not retrieve verified block for %c", cid, err);
        throw err;
      }
    }));
  } finally {
    controller.abort();
    signal.clear();
  }
}
const DEFAULT_SESSION_MIN_PROVIDERS = 1;
const DEFAULT_SESSION_MAX_PROVIDERS = 5;
const LN2_SQUARED = Math.LN2 * Math.LN2;
class BloomFilter {
  constructor(options2 = {}) {
    __publicField(this, "seeds");
    __publicField(this, "bits");
    __publicField(this, "buffer");
    if (options2.seeds != null) {
      this.seeds = options2.seeds;
    } else {
      this.seeds = generateSeeds(options2.hashes ?? 8);
    }
    this.bits = options2.bits ?? 1024;
    this.buffer = alloc$2(Math.ceil(this.bits / 8));
  }
  /**
   * Create a `BloomFilter` with the smallest `bits` and `hashes` value for the
   * specified item count and error rate.
   */
  static create(itemcount, errorRate = 5e-3) {
    const opts = optimize(itemcount, errorRate);
    return new BloomFilter(opts);
  }
  /**
   * Add an item to the filter
   */
  add(item) {
    if (typeof item === "string") {
      item = fromString$1(item);
    }
    for (let i = 0; i < this.seeds.length; i++) {
      const hash2 = mur.x86.hash32(item, this.seeds[i]);
      const bit = hash2 % this.bits;
      this.setbit(bit);
    }
  }
  /**
   * Test if the filter has an item. If it returns false it definitely does not
   * have the item. If it returns true, it probably has the item but there's
   * an `errorRate` chance it doesn't.
   */
  has(item) {
    if (typeof item === "string") {
      item = fromString$1(item);
    }
    for (let i = 0; i < this.seeds.length; i++) {
      const hash2 = mur.x86.hash32(item, this.seeds[i]);
      const bit = hash2 % this.bits;
      const isSet = this.getbit(bit);
      if (!isSet) {
        return false;
      }
    }
    return true;
  }
  /**
   * Reset the filter
   */
  clear() {
    this.buffer.fill(0);
  }
  setbit(bit) {
    let pos = 0;
    let shift = bit;
    while (shift > 7) {
      pos++;
      shift -= 8;
    }
    let bitfield = this.buffer[pos];
    bitfield |= 1 << shift;
    this.buffer[pos] = bitfield;
  }
  getbit(bit) {
    let pos = 0;
    let shift = bit;
    while (shift > 7) {
      pos++;
      shift -= 8;
    }
    const bitfield = this.buffer[pos];
    return (bitfield & 1 << shift) !== 0;
  }
}
function optimize(itemcount, errorRate = 5e-3) {
  const bits = Math.round(-1 * itemcount * Math.log(errorRate) / LN2_SQUARED);
  const hashes = Math.round(bits / itemcount * Math.LN2);
  return { bits, hashes };
}
function generateSeeds(count2) {
  let buf2;
  let j;
  const seeds = [];
  for (let i = 0; i < count2; i++) {
    buf2 = new Uint8ArrayList(randomBytes(4));
    seeds[i] = buf2.getUint32(0, true);
    for (j = 0; j < i; j++) {
      if (seeds[i] === seeds[j]) {
        i--;
        break;
      }
    }
  }
  return seeds;
}
class AbstractSession extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __publicField(this, "intialPeerSearchComplete");
    __publicField(this, "requests");
    __publicField(this, "name");
    __publicField(this, "log");
    __publicField(this, "logger");
    __publicField(this, "minProviders");
    __publicField(this, "maxProviders");
    __publicField(this, "providers");
    __publicField(this, "evictionFilter");
    setMaxListeners(Infinity, this);
    this.name = init.name;
    this.logger = components.logger;
    this.log = components.logger.forComponent(this.name);
    this.requests = /* @__PURE__ */ new Map();
    this.minProviders = init.minProviders ?? DEFAULT_SESSION_MIN_PROVIDERS;
    this.maxProviders = init.maxProviders ?? DEFAULT_SESSION_MAX_PROVIDERS;
    this.providers = [];
    this.evictionFilter = BloomFilter.create(this.maxProviders);
  }
  async retrieve(cid, options2 = {}) {
    const cidStr = base64.encode(cid.multihash.bytes);
    const existingJob = this.requests.get(cidStr);
    if (existingJob != null) {
      this.log("join existing request for %c", cid);
      return existingJob;
    }
    const deferred = pDefer();
    this.requests.set(cidStr, deferred.promise);
    if (this.providers.length === 0) {
      let first2 = false;
      if (this.intialPeerSearchComplete == null) {
        first2 = true;
        this.log = this.logger.forComponent(`${this.name}:${cid}`);
        this.intialPeerSearchComplete = this.findProviders(cid, this.minProviders, options2);
      }
      await this.intialPeerSearchComplete;
      if (first2) {
        this.log("found initial session peers for %c", cid);
      }
    }
    let foundBlock = false;
    const queue = new Queue$1({
      concurrency: this.maxProviders
    });
    queue.addEventListener("error", () => {
    });
    queue.addEventListener("failure", (evt) => {
      this.log.error("error querying provider %o, evicting from session", evt.detail.job.options.provider, evt.detail.error);
      this.evict(evt.detail.job.options.provider);
    });
    queue.addEventListener("success", (evt) => {
      foundBlock = true;
      deferred.resolve(evt.detail.result);
    });
    queue.addEventListener("idle", () => {
      var _a3;
      if (foundBlock || ((_a3 = options2.signal) == null ? void 0 : _a3.aborted) === true) {
        return;
      }
      Promise.resolve().then(async () => {
        this.log("no session peers had block for for %c, finding new providers", cid);
        for (let i = 0; i < this.minProviders; i++) {
          if (this.providers.length === 0) {
            break;
          }
          const provider = this.providers[Math.floor(Math.random() * this.providers.length)];
          this.evict(provider);
        }
        await this.findProviders(cid, this.minProviders, options2);
        this.log("found new providers re-retrieving %c", cid);
        this.requests.delete(cidStr);
        deferred.resolve(await this.retrieve(cid, options2));
      }).catch((err) => {
        this.log.error("could not find new providers for %c", cid, err);
        deferred.reject(err);
      });
    });
    const peerAddedToSessionListener = (event) => {
      queue.add(async () => {
        return this.queryProvider(cid, event.detail, options2);
      }, {
        provider: event.detail
      }).catch((err) => {
        var _a3;
        if (((_a3 = options2.signal) == null ? void 0 : _a3.aborted) === true) {
          return;
        }
        this.log.error("error retrieving session block for %c", cid, err);
      });
    };
    this.addEventListener("provider", peerAddedToSessionListener);
    Promise.all([...this.providers].map(async (provider) => {
      return queue.add(async () => {
        return this.queryProvider(cid, provider, options2);
      }, {
        provider
      });
    })).catch((err) => {
      var _a3;
      if (((_a3 = options2.signal) == null ? void 0 : _a3.aborted) === true) {
        return;
      }
      this.log.error("error retrieving session block for %c", cid, err);
    });
    try {
      return await deferred.promise;
    } finally {
      this.removeEventListener("provider", peerAddedToSessionListener);
      queue.clear();
      this.requests.delete(cidStr);
    }
  }
  evict(provider) {
    this.evictionFilter.add(this.toEvictionKey(provider));
    const index2 = this.providers.findIndex((prov) => this.equals(prov, provider));
    if (index2 === -1) {
      return;
    }
    this.providers.splice(index2, 1);
  }
  isEvicted(provider) {
    return this.evictionFilter.has(this.toEvictionKey(provider));
  }
  hasProvider(provider) {
    if (this.providers.find((prov) => this.equals(prov, provider)) != null) {
      return true;
    }
    if (this.isEvicted(provider)) {
      return true;
    }
    return false;
  }
  async findProviders(cid, count2, options2) {
    const deferred = pDefer();
    let found = 0;
    void Promise.resolve().then(async () => {
      var _a3;
      this.log("finding %d-%d new provider(s) for %c", count2, this.maxProviders, cid);
      for await (const provider of this.findNewProviders(cid, options2)) {
        if (found === this.maxProviders || ((_a3 = options2.signal) == null ? void 0 : _a3.aborted) === true) {
          break;
        }
        if (this.hasProvider(provider)) {
          continue;
        }
        this.log("found %d/%d new providers", found, this.maxProviders);
        this.providers.push(provider);
        this.safeDispatchEvent("provider", {
          detail: provider
        });
        found++;
        if (found === count2) {
          this.log("session is ready");
          deferred.resolve();
        }
        if (this.providers.length === this.maxProviders) {
          this.log("found max session peers", found);
          break;
        }
      }
      this.log("found %d/%d new session peers", found, this.maxProviders);
      if (found < count2) {
        throw new CodeError(`Found ${found} of ${count2} ${this.name} providers for ${cid}`, "ERR_INSUFFICIENT_PROVIDERS_FOUND");
      }
    }).catch((err) => {
      this.log.error("error searching routing for potential session peers for %c", cid, err.errors ?? err);
      deferred.reject(err);
    });
    return deferred.promise;
  }
}
class Helia {
  constructor(init) {
    __publicField(this, "blockstore");
    __publicField(this, "datastore");
    __publicField(this, "pins");
    __publicField(this, "logger");
    __publicField(this, "routing");
    __publicField(this, "dagWalkers");
    __publicField(this, "hashers");
    __publicField(this, "dns");
    __publicField(this, "metrics");
    __publicField(this, "log");
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("helia");
    this.hashers = defaultHashers(init.hashers);
    this.dagWalkers = defaultDagWalkers(init.dagWalkers);
    this.dns = init.dns ?? dns();
    this.metrics = init.metrics;
    const components = {
      blockstore: init.blockstore,
      datastore: init.datastore,
      hashers: this.hashers,
      dagWalkers: this.dagWalkers,
      logger: this.logger,
      blockBrokers: [],
      dns: this.dns,
      metrics: this.metrics,
      ...init.components ?? {}
    };
    this.routing = components.routing = new Routing(components, {
      routers: (init.routers ?? []).flatMap((router) => {
        const routers = [
          router
        ];
        if (router[contentRoutingSymbol] != null) {
          routers.push(router[contentRoutingSymbol]);
        }
        if (router[peerRoutingSymbol] != null) {
          routers.push(router[peerRoutingSymbol]);
        }
        return routers;
      }),
      providerLookupConcurrency: init.providerLookupConcurrency
    });
    const networkedStorage = new NetworkedStorage(components);
    this.pins = new PinsImpl(init.datastore, networkedStorage, this.dagWalkers);
    this.blockstore = new BlockStorage(networkedStorage, this.pins, {
      holdGcLock: init.holdGcLock ?? true
    });
    this.datastore = init.datastore;
    components.blockBrokers = init.blockBrokers.map((fn) => {
      return fn(components);
    });
  }
  async start() {
    await assertDatastoreVersionIsCurrent(this.datastore);
    await start(this.blockstore, this.datastore, this.routing);
  }
  async stop() {
    await stop(this.blockstore, this.datastore, this.routing);
  }
  async gc(options2 = {}) {
    const releaseLock = await this.blockstore.lock.writeLock();
    try {
      const helia = this;
      const blockstore = this.blockstore.unwrap();
      this.log("gc start");
      await drain(blockstore.deleteMany(async function* () {
        var _a3, _b2;
        for await (const { cid } of blockstore.getAll()) {
          try {
            if (await helia.pins.isPinned(cid, options2)) {
              continue;
            }
            yield cid;
            (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("helia:gc:deleted", cid));
          } catch (err) {
            helia.log.error("Error during gc", err);
            (_b2 = options2.onProgress) == null ? void 0 : _b2.call(options2, new CustomProgressEvent("helia:gc:error", err));
          }
        }
      }()));
    } finally {
      releaseLock();
    }
    this.log("gc finished");
  }
}
class Parser {
  constructor() {
    __publicField(this, "index", 0);
    __publicField(this, "input", "");
  }
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  /** Run a parser, and restore the pre-parse state if it fails. */
  readAtomically(fn) {
    const index2 = this.index;
    const result = fn();
    if (result === void 0) {
      this.index = index2;
    }
    return result;
  }
  /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
  parseWith(fn) {
    const result = fn();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  /** Peek the next character from the input */
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  /** Read the next character from the input */
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  /** Read the next character from the input if it matches the target. */
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  /**
   * Helper for reading separators in an indexed loop. Reads the separator
   * character iff index > 0, then runs the parser. When used in a loop,
   * the separator character will only be read on index > 0 (see
   * readIPv4Addr for an example)
   */
  readSeparator(sep, index2, inner) {
    return this.readAtomically(() => {
      if (index2 > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  /**
   * Read a number off the front of the input in the given radix, stopping
   * at the first non-digit character or eof. Fails if the number has more
   * digits than max_digits or if there is no number.
   */
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num = Number.parseInt(char, radix);
          if (Number.isNaN(num)) {
            return void 0;
          }
          return num;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  /** Read an IPv4 address. */
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i = 0; i < out.length; i++) {
        const ix = this.readSeparator(".", i, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i] = ix;
      }
      return out;
    });
  }
  /** Read an IPv6 Address. */
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i = 0; i < groups.length / 2; i++) {
        const ix = i * 2;
        if (i < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  /** Read an IP Address, either IPv4 or IPv6. */
  readIPAddr() {
    return this.readIPv4Addr() ?? this.readIPv6Addr();
  }
}
const MAX_IPV6_LENGTH = 45;
const MAX_IPV4_LENGTH = 15;
const parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input) {
  if (input.includes("%")) {
    input = input.split("%")[0];
  }
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPAddr());
}
function isIPv4$1(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6$1(input) {
  return Boolean(parseIPv6(input));
}
function isIP(input) {
  return Boolean(parseIP(input));
}
var Netmask_1;
(function() {
  var Netmask, atob2, chr, chr0, chrA, chra, ip2long, long2ip;
  long2ip = function(long) {
    var a, b, c, d2;
    a = (long & 255 << 24) >>> 24;
    b = (long & 255 << 16) >>> 16;
    c = (long & 255 << 8) >>> 8;
    d2 = long & 255;
    return [a, b, c, d2].join(".");
  };
  ip2long = function(ip) {
    var b, c, i, j, n, ref;
    b = [];
    for (i = j = 0; j <= 3; i = ++j) {
      if (ip.length === 0) {
        break;
      }
      if (i > 0) {
        if (ip[0] !== ".") {
          throw new Error("Invalid IP");
        }
        ip = ip.substring(1);
      }
      ref = atob2(ip), n = ref[0], c = ref[1];
      ip = ip.substring(c);
      b.push(n);
    }
    if (ip.length !== 0) {
      throw new Error("Invalid IP");
    }
    switch (b.length) {
      case 1:
        if (b[0] > 4294967295) {
          throw new Error("Invalid IP");
        }
        return b[0] >>> 0;
      case 2:
        if (b[0] > 255 || b[1] > 16777215) {
          throw new Error("Invalid IP");
        }
        return (b[0] << 24 | b[1]) >>> 0;
      case 3:
        if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
          throw new Error("Invalid IP");
        }
        return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
      case 4:
        if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
          throw new Error("Invalid IP");
        }
        return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
      default:
        throw new Error("Invalid IP");
    }
  };
  chr = function(b) {
    return b.charCodeAt(0);
  };
  chr0 = chr("0");
  chra = chr("a");
  chrA = chr("A");
  atob2 = function(s2) {
    var base, dmax, i, n, start2;
    n = 0;
    base = 10;
    dmax = "9";
    i = 0;
    if (s2.length > 1 && s2[i] === "0") {
      if (s2[i + 1] === "x" || s2[i + 1] === "X") {
        i += 2;
        base = 16;
      } else if ("0" <= s2[i + 1] && s2[i + 1] <= "9") {
        i++;
        base = 8;
        dmax = "7";
      }
    }
    start2 = i;
    while (i < s2.length) {
      if ("0" <= s2[i] && s2[i] <= dmax) {
        n = n * base + (chr(s2[i]) - chr0) >>> 0;
      } else if (base === 16) {
        if ("a" <= s2[i] && s2[i] <= "f") {
          n = n * base + (10 + chr(s2[i]) - chra) >>> 0;
        } else if ("A" <= s2[i] && s2[i] <= "F") {
          n = n * base + (10 + chr(s2[i]) - chrA) >>> 0;
        } else {
          break;
        }
      } else {
        break;
      }
      if (n > 4294967295) {
        throw new Error("too large");
      }
      i++;
    }
    if (i === start2) {
      throw new Error("empty octet");
    }
    return [n, i];
  };
  Netmask = function() {
    function Netmask2(net, mask) {
      var i, j, ref;
      if (typeof net !== "string") {
        throw new Error("Missing `net' parameter");
      }
      if (!mask) {
        ref = net.split("/", 2), net = ref[0], mask = ref[1];
      }
      if (!mask) {
        mask = 32;
      }
      if (typeof mask === "string" && mask.indexOf(".") > -1) {
        try {
          this.maskLong = ip2long(mask);
        } catch (error1) {
          throw new Error("Invalid mask: " + mask);
        }
        for (i = j = 32; j >= 0; i = --j) {
          if (this.maskLong === 4294967295 << 32 - i >>> 0) {
            this.bitmask = i;
            break;
          }
        }
      } else if (mask || mask === 0) {
        this.bitmask = parseInt(mask, 10);
        this.maskLong = 0;
        if (this.bitmask > 0) {
          this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
        }
      } else {
        throw new Error("Invalid mask: empty");
      }
      try {
        this.netLong = (ip2long(net) & this.maskLong) >>> 0;
      } catch (error1) {
        throw new Error("Invalid net address: " + net);
      }
      if (!(this.bitmask <= 32)) {
        throw new Error("Invalid mask for ip4: " + mask);
      }
      this.size = Math.pow(2, 32 - this.bitmask);
      this.base = long2ip(this.netLong);
      this.mask = long2ip(this.maskLong);
      this.hostmask = long2ip(~this.maskLong);
      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
    }
    Netmask2.prototype.contains = function(ip) {
      if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
        ip = new Netmask2(ip);
      }
      if (ip instanceof Netmask2) {
        return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
      } else {
        return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
      }
    };
    Netmask2.prototype.next = function(count2) {
      if (count2 == null) {
        count2 = 1;
      }
      return new Netmask2(long2ip(this.netLong + this.size * count2), this.mask);
    };
    Netmask2.prototype.forEach = function(fn) {
      var index2, lastLong, long;
      long = ip2long(this.first);
      lastLong = ip2long(this.last);
      index2 = 0;
      while (long <= lastLong) {
        fn(long2ip(long), long, index2);
        index2++;
        long++;
      }
    };
    Netmask2.prototype.toString = function() {
      return this.base + "/" + this.bitmask;
    };
    return Netmask2;
  }();
  Netmask_1 = Netmask;
}).call(commonjsGlobal);
const PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
const NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new Netmask_1(ipRange));
function ipv4Check(ipAddr) {
  for (const r of NETMASK_RANGES) {
    if (r.contains(ipAddr))
      return true;
  }
  return false;
}
function isIpv4MappedIpv6(ipAddr) {
  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
}
function ipv4MappedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  if (parts.length < 2) {
    return false;
  }
  const octet34 = parts[parts.length - 1].padStart(4, "0");
  const octet12 = parts[parts.length - 2].padStart(4, "0");
  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
  return ipv4Check(ip4);
}
function isIpv4EmbeddedIpv6(ipAddr) {
  return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
}
function ipv4EmbeddedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  const ip4 = parts[parts.length - 1];
  return ipv4Check(ip4);
}
function ipv6Check(ipAddr) {
  return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
}
function isPrivateIp(ip) {
  if (isIPv4$1(ip))
    return ipv4Check(ip);
  else if (isIpv4MappedIpv6(ip))
    return ipv4MappedIpv6Check(ip);
  else if (isIpv4EmbeddedIpv6(ip))
    return ipv4EmbeddedIpv6Check(ip);
  else if (isIPv6$1(ip))
    return ipv6Check(ip);
  else
    return void 0;
}
const isV4 = isIPv4$1;
const isV6 = isIPv6$1;
const toBytes = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  if (isV4(ip)) {
    const bytes2 = new Uint8Array(offset + 4);
    ip.split(/\./g).forEach((byte) => {
      bytes2[offset++] = parseInt(byte, 10) & 255;
    });
    return bytes2;
  }
  if (isV6(ip)) {
    const sections = ip.split(":", 8);
    let i;
    for (i = 0; i < sections.length; i++) {
      const isv4 = isV4(sections[i]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes(sections[i]);
        sections[i] = toString$2(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i < 8) {
        sections.splice(i, 0, toString$2(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ""; i++)
        ;
      const argv = [i, 1];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes2 = new Uint8Array(offset + 16);
    for (i = 0; i < sections.length; i++) {
      const word2 = parseInt(sections[i], 16);
      bytes2[offset++] = word2 >> 8 & 255;
      bytes2[offset++] = word2 & 255;
    }
    return bytes2;
  }
  throw new Error("invalid ip address");
};
const toString$1 = function(buf2, offset = 0, length2) {
  offset = ~~offset;
  length2 = length2 ?? buf2.length - offset;
  const view = new DataView(buf2.buffer);
  if (length2 === 4) {
    const result = [];
    for (let i = 0; i < length2; i++) {
      result.push(buf2[offset + i]);
    }
    return result.join(".");
  }
  if (length2 === 16) {
    const result = [];
    for (let i = 0; i < length2; i += 2) {
      result.push(view.getUint16(offset + i).toString(16));
    }
    return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
};
const V = -1;
const names = {};
const codes = {};
const table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [43, 8, "ipcidr"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc-direct"],
  [281, 0, "webrtc"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  // `ipfs` is added before `p2p` for legacy support.
  // All text representations will default to `p2p`, but `ipfs` will
  // still be supported
  [421, V, "ipfs"],
  // `p2p` is the preferred name for 421, and is now the default
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [448, 0, "tls"],
  [449, V, "sni"],
  [460, 0, "quic"],
  [461, 0, "quic-v1"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [481, V, "http-path"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes[proto.code] = proto;
  names[proto.name] = proto;
});
function createProtocol(code2, size, name2, resolvable, path) {
  return {
    code: code2,
    size,
    name: name2,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes[proto] != null) {
      return codes[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names[proto] != null) {
      return names[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}
getProtocol("ip4");
getProtocol("ip6");
getProtocol("ipcidr");
function convertToString(proto, buf2) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
    case 41:
      return bytes2ip(buf2);
    case 42:
      return bytes2str(buf2);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(buf2).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 449:
    case 777:
      return bytes2str(buf2);
    case 421:
      return bytes2mh(buf2);
    case 444:
      return bytes2onion(buf2);
    case 445:
      return bytes2onion(buf2);
    case 466:
      return bytes2mb(buf2);
    case 481:
      return globalThis.encodeURIComponent(bytes2str(buf2));
    default:
      return toString$2(buf2, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 42:
      return str2bytes(str);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 449:
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    case 481:
      return str2bytes(globalThis.decodeURIComponent(str));
    default:
      return fromString$1(str, "base16");
  }
}
const decoders = Object.values(bases).map((c) => c.decoder);
const anybaseDecoder = function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d2) => acc = acc.or(d2));
  return acc;
}();
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString$1(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
function port2bytes(port2) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, port2);
  return new Uint8Array(buf2);
}
function bytes2port(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset);
}
function str2bytes(str) {
  const buf2 = fromString$1(str);
  const size = Uint8Array.from(encode$6(buf2.length));
  return concat$2([size, buf2], size.length + buf2.length);
}
function bytes2str(buf2) {
  const size = decode$9(buf2);
  buf2 = buf2.slice(encodingLength(size));
  if (buf2.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString$2(buf2);
}
function mh2bytes(hash2) {
  let mh;
  if (hash2[0] === "Q" || hash2[0] === "1") {
    mh = decode$d(base58btc.decode(`z${hash2}`)).bytes;
  } else {
    mh = CID.parse(hash2).multihash.bytes;
  }
  const size = Uint8Array.from(encode$6(mh.length));
  return concat$2([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size = Uint8Array.from(encode$6(mb.length));
  return concat$2([size, mb], size.length + mb.length);
}
function bytes2mb(buf2) {
  const size = decode$9(buf2);
  const hash2 = buf2.slice(encodingLength(size));
  if (hash2.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString$2(hash2, "base64url");
}
function bytes2mh(buf2) {
  const size = decode$9(buf2);
  const address = buf2.slice(encodingLength(size));
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString$2(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = base32$1.decode("b" + addr[0]);
  const port2 = parseInt(addr[1], 10);
  if (port2 < 1 || port2 > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port2);
  return concat$2([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base32$1.decode(`b${addr[0]}`);
  const port2 = parseInt(addr[1], 10);
  if (port2 < 1 || port2 > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port2);
  return concat$2([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion(buf2) {
  const addrBytes = buf2.slice(0, buf2.length - 2);
  const portBytes = buf2.slice(buf2.length - 2);
  const addr = toString$2(addrBytes, "base32");
  const port2 = bytes2port(portBytes);
  return `${addr}:${port2}`;
}
function stringToMultiaddrParts(str) {
  str = cleanPath(str);
  const tuples = [];
  const stringTuples = [];
  let path = null;
  const parts = str.split("/").slice(1);
  if (parts.length === 1 && parts[0] === "") {
    return {
      bytes: new Uint8Array(),
      string: "/",
      tuples: [],
      stringTuples: [],
      path: null
    };
  }
  for (let p = 0; p < parts.length; p++) {
    const part = parts[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([proto.code]);
      stringTuples.push([proto.code]);
      continue;
    }
    p++;
    if (p >= parts.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      path = cleanPath(parts.slice(p).join("/"));
      tuples.push([proto.code, convertToBytes(proto.code, path)]);
      stringTuples.push([proto.code, path]);
      break;
    }
    const bytes2 = convertToBytes(proto.code, parts[p]);
    tuples.push([proto.code, bytes2]);
    stringTuples.push([proto.code, convertToString(proto.code, bytes2)]);
  }
  return {
    string: stringTuplesToString(stringTuples),
    bytes: tuplesToBytes(tuples),
    tuples,
    stringTuples,
    path
  };
}
function bytesToMultiaddrParts(bytes2) {
  const tuples = [];
  const stringTuples = [];
  let path = null;
  let i = 0;
  while (i < bytes2.length) {
    const code2 = decode$9(bytes2, i);
    const n = encodingLength(code2);
    const p = getProtocol(code2);
    const size = sizeForAddr(p, bytes2.slice(i + n));
    if (size === 0) {
      tuples.push([code2]);
      stringTuples.push([code2]);
      i += n;
      continue;
    }
    const addr = bytes2.slice(i + n, i + n + size);
    i += size + n;
    if (i > bytes2.length) {
      throw ParseError("Invalid address Uint8Array: " + toString$2(bytes2, "base16"));
    }
    tuples.push([code2, addr]);
    const stringAddr = convertToString(code2, addr);
    stringTuples.push([code2, stringAddr]);
    if (p.path === true) {
      path = stringAddr;
      break;
    }
  }
  return {
    bytes: Uint8Array.from(bytes2),
    string: stringTuplesToString(stringTuples),
    tuples,
    stringTuples,
    path
  };
}
function stringTuplesToString(tuples) {
  const parts = [];
  tuples.map((tup) => {
    const proto = getProtocol(tup[0]);
    parts.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts.join("/"));
}
function tuplesToBytes(tuples) {
  return concat$2(tuples.map((tup) => {
    const proto = getProtocol(tup[0]);
    let buf2 = Uint8Array.from(encode$6(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf2 = concat$2([buf2, tup[1]]);
    }
    return buf2;
  }));
}
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size = decode$9(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));
    return size + encodingLength(size);
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
const inspect$1 = Symbol.for("nodejs.util.inspect.custom");
const symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
const DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
const _Multiaddr = class _Multiaddr {
  constructor(addr) {
    __publicField(this, "bytes");
    __privateAdd(this, _string);
    __privateAdd(this, _tuples);
    __privateAdd(this, _stringTuples);
    __privateAdd(this, _path);
    __publicField(this, _f, true);
    if (addr == null) {
      addr = "";
    }
    let parts;
    if (addr instanceof Uint8Array) {
      parts = bytesToMultiaddrParts(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      parts = stringToMultiaddrParts(addr);
    } else if (isMultiaddr(addr)) {
      parts = bytesToMultiaddrParts(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
    this.bytes = parts.bytes;
    __privateSet(this, _string, parts.string);
    __privateSet(this, _tuples, parts.tuples);
    __privateSet(this, _stringTuples, parts.stringTuples);
    __privateSet(this, _path, parts.path);
  }
  toString() {
    return __privateGet(this, _string);
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    let family;
    let transport;
    let host;
    let port2;
    let zone = "";
    const tcp = getProtocol("tcp");
    const udp = getProtocol("udp");
    const ip4 = getProtocol("ip4");
    const ip6 = getProtocol("ip6");
    const dns6 = getProtocol("dns6");
    const ip6zone = getProtocol("ip6zone");
    for (const [code2, value] of this.stringTuples()) {
      if (code2 === ip6zone.code) {
        zone = `%${value ?? ""}`;
      }
      if (DNS_CODES.includes(code2)) {
        transport = tcp.name;
        port2 = 443;
        host = `${value ?? ""}${zone}`;
        family = code2 === dns6.code ? 6 : 4;
      }
      if (code2 === tcp.code || code2 === udp.code) {
        transport = getProtocol(code2).name;
        port2 = parseInt(value ?? "");
      }
      if (code2 === ip4.code || code2 === ip6.code) {
        transport = getProtocol(code2).name;
        host = `${value ?? ""}${zone}`;
        family = code2 === ip6.code ? 6 : 4;
      }
    }
    if (family == null || transport == null || host == null || port2 == null) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family,
      host,
      transport,
      port: port2
    };
    return opts;
  }
  protos() {
    return __privateGet(this, _tuples).map(([code2]) => Object.assign({}, getProtocol(code2)));
  }
  protoCodes() {
    return __privateGet(this, _tuples).map(([code2]) => code2);
  }
  protoNames() {
    return __privateGet(this, _tuples).map(([code2]) => getProtocol(code2).name);
  }
  tuples() {
    return __privateGet(this, _tuples);
  }
  stringTuples() {
    return __privateGet(this, _stringTuples);
  }
  encapsulate(addr) {
    addr = new _Multiaddr(addr);
    return new _Multiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s2 = this.toString();
    const i = s2.lastIndexOf(addrString);
    if (i < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new _Multiaddr(s2.slice(0, i));
  }
  decapsulateCode(code2) {
    const tuples = this.tuples();
    for (let i = tuples.length - 1; i >= 0; i--) {
      if (tuples[i][0] === code2) {
        return new _Multiaddr(tuplesToBytes(tuples.slice(0, i)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      let tuples = [];
      this.stringTuples().forEach(([code2, name2]) => {
        if (code2 === names.p2p.code) {
          tuples.push([code2, name2]);
        }
        if (code2 === names["p2p-circuit"].code) {
          tuples = [];
        }
      });
      const tuple = tuples.pop();
      if ((tuple == null ? void 0 : tuple[1]) != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString$2(base58btc.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString$2(CID.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    return __privateGet(this, _path);
  }
  equals(addr) {
    return equals(this.bytes, addr.bytes);
  }
  async resolve(options2) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw new CodeError(`no available resolver for ${resolvableProto.name}`, "ERR_NO_AVAILABLE_RESOLVER");
    }
    const result = await resolver(this, options2);
    return result.map((str) => multiaddr(str));
  }
  nodeAddress() {
    const options2 = this.toOptions();
    if (options2.transport !== "tcp" && options2.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options2.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options2.family,
      address: options2.host,
      port: options2.port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr ?? this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  /**
   * Returns Multiaddr as a human-readable string
   * https://nodejs.org/api/util.html#utilinspectcustom
   *
   * @example
   * ```js
   * import { multiaddr } from '@multiformats/multiaddr'
   *
   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
   * ```
   */
  [(_f = symbol, inspect$1)]() {
    return `Multiaddr(${__privateGet(this, _string)})`;
  }
};
_string = new WeakMap();
_tuples = new WeakMap();
_stringTuples = new WeakMap();
_path = new WeakMap();
let Multiaddr = _Multiaddr;
const resolvers = /* @__PURE__ */ new Map();
function isMultiaddr(value) {
  return Boolean(value == null ? void 0 : value[symbol]);
}
function multiaddr(addr) {
  return new Multiaddr(addr);
}
const toParts = (ma) => {
  return ma.toString().split("/").slice(1);
};
const func = (fn) => {
  return {
    match: (vals) => {
      if (vals.length < 1) {
        return false;
      }
      if (fn(vals[0])) {
        return vals.slice(1);
      }
      return false;
    },
    pattern: "fn"
  };
};
const literal = (str) => {
  return {
    match: (vals) => func((val) => val === str).match(vals),
    pattern: str
  };
};
const string = () => {
  return {
    match: (vals) => func((val) => typeof val === "string").match(vals),
    pattern: "{string}"
  };
};
const number = () => {
  return {
    match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),
    pattern: "{number}"
  };
};
const peerId = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "p2p" && vals[0] !== "ipfs") {
        return false;
      }
      if (vals[1].startsWith("Q") || vals[1].startsWith("1")) {
        try {
          base58btc.decode(`z${vals[1]}`);
        } catch (err) {
          return false;
        }
      } else {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/p2p/{peerid}"
  };
};
const certhash = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "certhash") {
        return false;
      }
      try {
        base64url.decode(vals[1]);
      } catch {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/certhash/{certhash}"
  };
};
const optional = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    },
    pattern: `optional(${matcher.pattern})`
  };
};
const or = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    },
    pattern: `or(${matchers.map((m2) => m2.pattern).join(", ")})`
  };
};
const and = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    },
    pattern: `and(${matchers.map((m2) => m2.pattern).join(", ")})`
  };
};
function fmt(...matchers) {
  function match(ma) {
    let parts = toParts(ma);
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matches,
    exactMatch
  };
}
const _DNS4 = and(literal("dns4"), string());
const _DNS6 = and(literal("dns6"), string());
const _DNSADDR = and(literal("dnsaddr"), string());
const _DNS = and(literal("dns"), string());
const DNS2 = fmt(or(_DNS, _DNSADDR, _DNS4, _DNS6));
const _IP4 = and(literal("ip4"), func(isIPv4$1));
const _IP6 = and(literal("ip6"), func(isIPv6$1));
const _IP = or(_IP4, _IP6);
const _IP_OR_DOMAIN = or(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
const _TCP = and(_IP_OR_DOMAIN, literal("tcp"), number());
const _UDP = and(_IP_OR_DOMAIN, literal("udp"), number());
const _QUIC = and(_UDP, literal("quic"));
const _QUICV1 = and(_UDP, literal("quic-v1"));
const QUIC_V0_OR_V1 = or(_QUIC, _QUICV1);
const _WEB = or(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);
const _WebSockets = or(and(_WEB, literal("ws"), optional(peerId())));
const _WebSocketsSecure = or(and(_WEB, literal("wss"), optional(peerId())), and(_WEB, literal("tls"), literal("ws"), optional(peerId())));
const _WebRTCDirect = and(_UDP, literal("webrtc-direct"), optional(certhash()), optional(certhash()), optional(peerId()));
const _WebTransport = and(_QUICV1, literal("webtransport"), optional(certhash()), optional(certhash()), optional(peerId()));
const _P2P = or(_WebSockets, _WebSocketsSecure, and(_TCP, optional(peerId())), and(QUIC_V0_OR_V1, optional(peerId())), and(_IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect, _WebTransport, peerId());
and(_P2P, literal("p2p-circuit"), peerId());
or(and(_P2P, literal("p2p-circuit"), literal("webrtc"), optional(peerId())), and(_P2P, literal("webrtc"), optional(peerId())), literal("webrtc"));
const _HTTP = or(and(_IP_OR_DOMAIN, literal("tcp"), number(), literal("http"), optional(peerId())), and(_IP_OR_DOMAIN, literal("http"), optional(peerId())));
const HTTP = fmt(_HTTP);
const _HTTPS = or(and(_IP_OR_DOMAIN, literal("tcp"), or(and(literal("443"), literal("http")), and(number(), literal("https"))), optional(peerId())), and(_IP_OR_DOMAIN, literal("tls"), literal("http"), optional(peerId())), and(_IP_OR_DOMAIN, literal("https"), optional(peerId())));
const HTTPS = fmt(_HTTPS);
const ASSUME_HTTP_CODES = [
  getProtocol("tcp").code,
  getProtocol("dns").code,
  getProtocol("dnsaddr").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code
];
function extractSNI(ma) {
  let sniProtoCode;
  try {
    sniProtoCode = getProtocol("sni").code;
  } catch (e) {
    return null;
  }
  for (const [proto, value] of ma) {
    if (proto === sniProtoCode && value !== void 0) {
      return value;
    }
  }
  return null;
}
function hasTLS(ma) {
  return ma.some(([proto, _]) => proto === getProtocol("tls").code);
}
function interpretNext(headProtoCode, headProtoVal, restMa) {
  const interpreter = interpreters[getProtocol(headProtoCode).name];
  if (interpreter === void 0) {
    throw new Error(`Can't interpret protocol ${getProtocol(headProtoCode).name}`);
  }
  const restVal = interpreter(headProtoVal, restMa);
  if (headProtoCode === getProtocol("ip6").code) {
    return `[${restVal}]`;
  }
  return restVal;
}
const interpreters = {
  ip4: (value, restMa) => value,
  ip6: (value, restMa) => {
    if (restMa.length === 0) {
      return value;
    }
    return `[${value}]`;
  },
  tcp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  udp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  dnsaddr: (value, restMa) => value,
  dns4: (value, restMa) => value,
  dns6: (value, restMa) => value,
  dns: (value, restMa) => value,
  ipfs: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/ipfs/${value}`;
  },
  p2p: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p/${value}`;
  },
  http: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `https://${sni}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  "http-path": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    const baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    const decodedValue = decodeURIComponent(value);
    return `${baseVal}/${decodedValue}`;
  },
  tls: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  sni: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  https: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    if (maHasTLS && sni !== null) {
      return `wss://${sni}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `wss://${baseVal}`;
  },
  "p2p-websocket-star": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-websocket-star`;
  },
  "p2p-webrtc-star": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-star`;
  },
  "p2p-webrtc-direct": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto === void 0) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}/p2p-webrtc-direct`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const parts = ma.stringTuples();
  const head = parts.pop();
  if (head === void 0) {
    throw new Error("Unexpected end of multiaddr");
  }
  const protocol = getProtocol(head[0]);
  const interpreter = interpreters[protocol.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${protocol.name}`);
  }
  let uri = interpreter(head[1] ?? "", parts);
  if (ASSUME_HTTP_CODES.includes(head[0])) {
    uri = uri.replace(/^.*:\/\//, "");
    if (head[1] === "443") {
      uri = `https://${uri}`;
    } else {
      uri = `http://${uri}`;
    }
  }
  if (uri.startsWith("http://") || uri.startsWith("https://")) {
    uri = new URL(uri).toString();
    if (uri.endsWith("/")) {
      uri = uri.substring(0, uri.length - 1);
    }
  }
  return uri;
}
class TrustlessGateway {
  constructor(url, headers, logger2) {
    __privateAdd(this, _TrustlessGateway_instances);
    __publicField(this, "url");
    /**
     * The number of times this gateway has been attempted to be used to fetch a
     * block. This includes successful, errored, and aborted attempts. By counting
     * even aborted attempts, slow gateways that are out-raced by others will be
     * considered less reliable.
     */
    __privateAdd(this, _attempts, 0);
    /**
     * The number of times this gateway has errored while attempting to fetch a
     * block. This includes `response.ok === false` and any other errors that
     * throw while attempting to fetch a block. This does not include aborted
     * attempts.
     */
    __privateAdd(this, _errors, 0);
    /**
     * The number of times this gateway has returned an invalid block. A gateway
     * that returns the wrong blocks for a CID should be considered for removal
     * from the list of gateways to fetch blocks from.
     */
    __privateAdd(this, _invalidBlocks, 0);
    /**
     * The number of times this gateway has successfully fetched a block.
     */
    __privateAdd(this, _successes, 0);
    /**
     * A map of pending responses for this gateway. This is used to ensure that
     * only one request per CID is made to a given gateway at a time, and that we
     * don't make multiple in-flight requests for the same CID to the same gateway.
     */
    __privateAdd(this, _pendingResponses, /* @__PURE__ */ new Map());
    __publicField(this, "log");
    __publicField(this, "headers");
    this.url = url instanceof URL ? url : new URL(url);
    this.headers = headers;
    this.log = logger2.forComponent(`helia:trustless-gateway-block-broker:${this.url.hostname}`);
  }
  /**
   * Fetch a raw block from `this.url` following the specification defined at
   * https://specs.ipfs.tech/http-gateways/trustless-gateway/
   */
  async getRawBlock(cid, signal) {
    const gwUrl = new URL(this.url.toString());
    gwUrl.pathname = `/ipfs/${cid.toString()}`;
    gwUrl.search = "?format=raw";
    if ((signal == null ? void 0 : signal.aborted) === true) {
      throw new Error(`Signal to fetch raw block for CID ${cid} from gateway ${this.url} was aborted prior to fetch`);
    }
    const blockId = __privateMethod(this, _TrustlessGateway_instances, uniqueBlockId_fn).call(this, cid);
    const innerController = new AbortController();
    const abortInnerSignal = () => {
      innerController.abort();
    };
    signal == null ? void 0 : signal.addEventListener("abort", abortInnerSignal);
    try {
      let pendingResponse = __privateGet(this, _pendingResponses).get(blockId);
      if (pendingResponse == null) {
        __privateWrapper(this, _attempts)._++;
        pendingResponse = fetch(gwUrl.toString(), {
          signal: innerController.signal,
          headers: {
            Accept: "application/vnd.ipld.raw",
            ...this.headers
          },
          cache: "force-cache"
        }).then(async (res) => {
          this.log("GET %s %d", gwUrl, res.status);
          if (!res.ok) {
            __privateWrapper(this, _errors)._++;
            throw new Error(`unable to fetch raw block for CID ${cid} from gateway ${this.url}`);
          }
          __privateWrapper(this, _successes)._++;
          return new Uint8Array(await res.arrayBuffer());
        });
        __privateGet(this, _pendingResponses).set(blockId, pendingResponse);
      }
      return await pendingResponse;
    } catch (cause) {
      if ((signal == null ? void 0 : signal.aborted) === true) {
        throw new Error(`fetching raw block for CID ${cid} from gateway ${this.url} was aborted`);
      }
      __privateWrapper(this, _errors)._++;
      throw new Error(`unable to fetch raw block for CID ${cid}`);
    } finally {
      signal == null ? void 0 : signal.removeEventListener("abort", abortInnerSignal);
      __privateGet(this, _pendingResponses).delete(blockId);
    }
  }
  /**
   * Encapsulate the logic for determining whether a gateway is considered
   * reliable, for prioritization. This is based on the number of successful attempts made
   * and the number of errors encountered.
   *
   * Unused gateways have 100% reliability; They will be prioritized over
   * gateways with a 100% success rate to ensure that we attempt all gateways.
   */
  reliability() {
    if (__privateGet(this, _attempts) === 0) {
      return 1;
    }
    if (__privateGet(this, _invalidBlocks) > 0) {
      return -Infinity;
    }
    return __privateGet(this, _successes) / (__privateGet(this, _attempts) + __privateGet(this, _errors) * 3);
  }
  /**
   * Increment the number of invalid blocks returned by this gateway.
   */
  incrementInvalidBlocks() {
    __privateWrapper(this, _invalidBlocks)._++;
  }
  getStats() {
    return {
      attempts: __privateGet(this, _attempts),
      errors: __privateGet(this, _errors),
      invalidBlocks: __privateGet(this, _invalidBlocks),
      successes: __privateGet(this, _successes),
      pendingResponses: __privateGet(this, _pendingResponses).size
    };
  }
}
_attempts = new WeakMap();
_errors = new WeakMap();
_invalidBlocks = new WeakMap();
_successes = new WeakMap();
_pendingResponses = new WeakMap();
_TrustlessGateway_instances = new WeakSet();
/**
 * This function returns a unique string for the multihash.bytes of the CID.
 *
 * Some useful resources for why this is needed can be found using the links below:
 *
 * - https://github.com/ipfs/helia/pull/503#discussion_r1572451331
 * - https://github.com/ipfs/kubo/issues/6815
 * - https://www.notion.so/pl-strflt/Handling-ambiguity-around-CIDs-9d5e14f6516f438980b01ef188efe15d#d9d45cd1ed8b4d349b96285de4aed5ab
 */
uniqueBlockId_fn = function(cid) {
  const multihashBytes = cid.multihash.bytes;
  return base64.encode(multihashBytes);
};
function filterNonHTTPMultiaddrs(multiaddrs, allowInsecure, allowLocal) {
  return multiaddrs.filter((ma) => {
    if (HTTPS.matches(ma) || allowInsecure && HTTP.matches(ma)) {
      if (allowLocal) {
        return true;
      }
      if (DNS2.matches(ma)) {
        return true;
      }
      return isPrivateIp(ma.toOptions().host) === false;
    }
    if (!allowInsecure && allowLocal) {
      const { host } = ma.toOptions();
      if (host === "127.0.0.1" || host === "localhost" || host.endsWith(".localhost")) {
        return true;
      }
    }
    return false;
  });
}
async function* findHttpGatewayProviders(cid, routing, logger2, allowInsecure, allowLocal, headers = {}, options2 = {}) {
  for await (const provider of routing.findProviders(cid, options2)) {
    const httpAddresses = filterNonHTTPMultiaddrs(provider.multiaddrs, allowInsecure, allowLocal);
    if (httpAddresses.length === 0) {
      continue;
    }
    const uri = multiaddrToUri(httpAddresses[0]);
    yield new TrustlessGateway(uri, headers, logger2);
  }
}
class TrustlessGatewaySession extends AbstractSession {
  constructor(components, init) {
    super(components, {
      ...init,
      name: "helia:trustless-gateway:session"
    });
    __publicField(this, "routing");
    __publicField(this, "allowInsecure");
    __publicField(this, "allowLocal");
    __publicField(this, "headers");
    this.routing = components.routing;
    this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
    this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
    this.headers = init.headers ?? {};
  }
  async queryProvider(cid, provider, options2) {
    var _a3;
    this.log("fetching BLOCK for %c from %s", cid, provider.url);
    const block = await provider.getRawBlock(cid, options2.signal);
    this.log.trace("got block for %c from %s", cid, provider.url);
    await ((_a3 = options2.validateFn) == null ? void 0 : _a3.call(options2, block));
    return block;
  }
  async *findNewProviders(cid, options2 = {}, headers = {}) {
    yield* findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, this.headers, options2);
  }
  toEvictionKey(provider) {
    return provider.url.toString();
  }
  equals(providerA, providerB) {
    return providerA.url.toString() === providerB.url.toString();
  }
}
function createTrustlessGatewaySession(components, init) {
  return new TrustlessGatewaySession(components, init);
}
class TrustlessGatewayBlockBroker {
  constructor(components, init = {}) {
    __publicField(this, "allowInsecure");
    __publicField(this, "allowLocal");
    __publicField(this, "headers");
    __publicField(this, "routing");
    __publicField(this, "log");
    __publicField(this, "logger");
    this.log = components.logger.forComponent("helia:trustless-gateway-block-broker");
    this.logger = components.logger;
    this.routing = components.routing;
    this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
    this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
    this.headers = init.headers ?? {};
  }
  async retrieve(cid, options2 = {}) {
    var _a3, _b2;
    const aggregateErrors = [];
    for await (const gateway of findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, this.headers, options2)) {
      this.log("getting block for %c from %s", cid, gateway.url);
      try {
        const block = await gateway.getRawBlock(cid, options2.signal);
        this.log.trace("got block for %c from %s", cid, gateway.url);
        try {
          await ((_a3 = options2.validateFn) == null ? void 0 : _a3.call(options2, block));
        } catch (err) {
          this.log.error("failed to validate block for %c from %s", cid, gateway.url, err);
          continue;
        }
        return block;
      } catch (err) {
        this.log.error("failed to get block for %c from %s", cid, gateway.url, err);
        if (err instanceof Error) {
          aggregateErrors.push(err);
        } else {
          aggregateErrors.push(new Error(`Unable to fetch raw block for CID ${cid} from gateway ${gateway.url}`));
        }
        if (((_b2 = options2.signal) == null ? void 0 : _b2.aborted) === true) {
          this.log.trace("request aborted while fetching raw block for CID %c from gateway %s", cid, gateway.url);
          break;
        }
      }
    }
    if (aggregateErrors.length > 0) {
      throw new AggregateError(aggregateErrors, `Unable to fetch raw block for CID ${cid} from any gateway`);
    } else {
      throw new Error(`Unable to fetch raw block for CID ${cid} from any gateway`);
    }
  }
  createSession(options2 = {}) {
    return createTrustlessGatewaySession({
      logger: this.logger,
      routing: this.routing
    }, {
      ...options2,
      allowLocal: this.allowLocal,
      allowInsecure: this.allowInsecure,
      headers: {
        ...this.headers,
        ...options2.headers
      }
    });
  }
}
const DEFAULT_ALLOW_INSECURE = false;
const DEFAULT_ALLOW_LOCAL = false;
function trustlessGateway(init = {}) {
  return (components) => new TrustlessGatewayBlockBroker(components, init);
}
async function* browserReadableStreamToIt(stream, options2 = {}) {
  const reader = stream.getReader();
  try {
    while (true) {
      const result = await reader.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options2.preventCancel !== true) {
      await reader.cancel();
    }
    reader.releaseLock();
  }
}
var timestamp_min = { exports: {} };
(function(module2) {
  (function() {
    module2.exports = d2;
    var l = 86400, s2 = 3200, T = 146097 * s2 / 400, e = l * T, f2 = 1e3 * e, c = 864e13, g2 = 4294967296, h2 = 1e6, u = "000000000", m2 = Math.trunc || function(n2) {
      var t2 = n2 - n2 % 1;
      return 0 == t2 && (n2 < 0 || 0 === n2 && 1 / n2 != 1 / 0) ? -0 : t2;
    }, n = d2.prototype, o = (d2.fromDate = function(n2) {
      return new d2(+n2);
    }, d2.fromInt64BE = r(0, 1, 2, 3, 0, 4), d2.fromInt64LE = r(3, 2, 1, 0, 4, 0), d2.fromString = function(n2) {
      var e2, r2 = new d2(), n2 = (n2 += "").replace(/^\s*[+\-]?\d+/, function(n3) {
        var n3 = +n3, t2 = 1970 + (n3 - 1970) % 400;
        return r2.year = n3 - t2, t2;
      }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(n3, t2, r3) {
        return t2 < 0 && (r3 *= -1), e2 = 6e4 * (60 * +t2 + +r3), "";
      }).replace(/\.\d+$/, function(n3) {
        return r2.nano = +(n3 + u).substr(1, 9), "";
      }).split(/\D+/);
      1 < n2.length ? n2[1]-- : n2[1] = 0;
      if (r2.time = e2 = Date.UTC.apply(Date, n2) - (e2 || 0), isNaN(e2)) throw new TypeError("Invalid Date");
      return p(r2);
    }, d2.fromTimeT = function(n2) {
      return y2(n2, 0);
    }, n.year = 0, n.time = 0, n.nano = 0, n.addNano = function(n2) {
      return this.nano += +n2 || 0, this;
    }, n.getNano = function() {
      var n2 = p(this);
      return (n2.time % 1e3 * h2 + +n2.nano + 1e9) % 1e9;
    }, n.getTimeT = function() {
      var n2 = p(this), t2 = Math.floor(n2.time / 1e3), n2 = n2.year;
      n2 && (t2 += n2 * T * l / s2);
      return t2;
    }, n.getYear = function() {
      return this.toDate().getUTCFullYear() + this.year;
    }, n.toDate = function() {
      return M2(p(this).time);
    }, n.toJSON = function() {
      return this.toString().replace(/0{1,6}Z$/, "Z");
    }, n.toString = function(n2) {
      var t2 = this, r2 = t2.toDate(), u2 = { H: function() {
        return C(r2.getUTCHours());
      }, L: function() {
        return D(r2.getUTCMilliseconds(), 3);
      }, M: function() {
        return C(r2.getUTCMinutes());
      }, N: function() {
        return D(t2.getNano(), 9);
      }, S: function() {
        return C(r2.getUTCSeconds());
      }, Y: function() {
        var n3 = t2.getYear();
        return 999999 < n3 ? "+" + n3 : 9999 < n3 ? "+" + D(n3, 6) : 0 <= n3 ? D(n3, 4) : -999999 <= n3 ? "-" + D(-n3, 6) : n3;
      }, a: function() {
        return a[r2.getUTCDay()];
      }, b: function() {
        return i[r2.getUTCMonth()];
      }, d: function() {
        return C(r2.getUTCDate());
      }, e: function() {
        return function(n3) {
          return (9 < n3 ? "" : " ") + (0 | n3);
        }(r2.getUTCDate());
      }, m: function() {
        return C(r2.getUTCMonth() + 1);
      } };
      return function e2(n3) {
        return n3.replace(/%./g, function(n4) {
          var t3 = n4[1], r3 = v[t3], t3 = u2[t3];
          return r3 ? e2(r3) : t3 ? t3() : n4;
        });
      }(n2 || o);
    }, n.writeInt64BE = t(0, 1, 2, 3, 0, 4), n.writeInt64LE = t(3, 2, 1, 0, 4, 0), "%Y-%m-%dT%H:%M:%S.%NZ"), i = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], a = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], v = { "%": "%", F: "%Y-%m-%d", n: "\n", R: "%H:%M", T: "%H:%M:%S", t: "	", X: "%T", Z: "GMT", z: "+0000" };
    return d2;
    function d2(n2, t2, r2) {
      var e2 = this;
      if (!(e2 instanceof d2)) return new d2(n2, t2, r2);
      e2.time = +n2 || 0, e2.nano = +t2 || 0, e2.year = +r2 || 0, p(e2);
    }
    function p(n2) {
      var t2, r2, e2, u2 = n2.year, o2 = n2.time, i2 = n2.nano, a2 = ((i2 < 0 || h2 <= i2) && (i2 -= (r2 = Math.floor(i2 / h2)) * h2, o2 += r2, r2 = 1), u2 % s2);
      return (o2 < -c || c < o2 || a2) && ((t2 = m2(o2 / f2)) && (u2 += t2 * s2, o2 -= t2 * f2), (e2 = M2(o2)).setUTCFullYear(a2 + e2.getUTCFullYear()), e2 = (o2 = +e2) + (t2 = m2((u2 -= a2) / s2)) * f2, t2 && -c <= e2 && e2 <= c && (u2 -= t2 * s2, o2 = e2), r2 = 1), r2 && (n2.year = u2, n2.time = o2, n2.nano = i2), n2;
    }
    function M2(n2) {
      var t2 = /* @__PURE__ */ new Date(0);
      return t2.setTime(n2), t2;
    }
    function y2(n2, t2) {
      n2 = +n2 || 0;
      var r2 = m2((t2 = (t2 | 0) * g2) / e) + m2(n2 / e), t2 = t2 % e + n2 % e, n2 = m2(t2 / e);
      return n2 && (r2 += n2, t2 -= n2 * e), new d2(1e3 * t2, 0, r2 * s2);
    }
    function t(e2, u2, o2, i2, a2, f3) {
      return function(n2, t2) {
        var r2 = p(this);
        n2 = n2 || new Array(8);
        w2(n2, t2 |= 0);
        var e3 = Math.floor(r2.time / 1e3), r2 = r2.year * (T * l / s2), u3 = m2(r2 / g2) + m2(e3 / g2), r2 = r2 % g2 + e3 % g2, e3 = Math.floor(r2 / g2);
        e3 && (u3 += e3, r2 -= e3 * g2);
        return c2(n2, t2 + a2, u3), c2(n2, t2 + f3, r2), n2;
      };
      function c2(n2, t2, r2) {
        n2[t2 + e2] = r2 >> 24 & 255, n2[t2 + u2] = r2 >> 16 & 255, n2[t2 + o2] = r2 >> 8 & 255, n2[t2 + i2] = 255 & r2;
      }
    }
    function r(r2, e2, u2, o2, i2, a2) {
      return function(n2, t2) {
        w2(n2, t2 |= 0);
        var r3 = f3(n2, t2 + i2);
        return y2(f3(n2, t2 + a2), r3);
      };
      function f3(n2, t2) {
        return 16777216 * n2[t2 + r2] + (n2[t2 + e2] << 16 | n2[t2 + u2] << 8 | n2[t2 + o2]);
      }
    }
    function w2(n2, t2) {
      n2 = n2 && n2.length;
      if (null == n2) throw new TypeError("Invalid Buffer");
      if (n2 < t2 + 8) throw new RangeError("Out of range");
    }
    function C(n2) {
      return (9 < n2 ? "" : "0") + (0 | n2);
    }
    function D(n2, t2) {
      return (u + (0 | n2)).substr(-t2);
    }
  })();
})(timestamp_min);
var timestamp_minExports = timestamp_min.exports;
const NanoDate = /* @__PURE__ */ getDefaultExportFromCjs(timestamp_minExports);
const ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
const ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
const ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
const ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
const ERR_INVALID_RECORD_DATA = "ERR_INVALID_RECORD_DATA";
const ERR_INVALID_VALUE = "ERR_INVALID_VALUE";
const ERR_INVALID_EMBEDDED_KEY = "ERR_INVALID_EMBEDDED_KEY";
const ERR_RECORD_TOO_LARGE = "ERR_RECORD_TOO_LARGE";
var IpnsEntry;
(function(IpnsEntry2) {
  (function(ValidityType) {
    ValidityType["EOL"] = "EOL";
  })(IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let __ValidityTypeValues;
  (function(__ValidityTypeValues2) {
    __ValidityTypeValues2[__ValidityTypeValues2["EOL"] = 0] = "EOL";
  })(__ValidityTypeValues || (__ValidityTypeValues = {}));
  (function(ValidityType) {
    ValidityType.codec = () => {
      return enumeration(__ValidityTypeValues);
    };
  })(IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let _codec;
  IpnsEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w2, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w2.fork();
        }
        if (obj.value != null) {
          w2.uint32(10);
          w2.bytes(obj.value);
        }
        if (obj.signatureV1 != null) {
          w2.uint32(18);
          w2.bytes(obj.signatureV1);
        }
        if (obj.validityType != null) {
          w2.uint32(24);
          IpnsEntry2.ValidityType.codec().encode(obj.validityType, w2);
        }
        if (obj.validity != null) {
          w2.uint32(34);
          w2.bytes(obj.validity);
        }
        if (obj.sequence != null) {
          w2.uint32(40);
          w2.uint64(obj.sequence);
        }
        if (obj.ttl != null) {
          w2.uint32(48);
          w2.uint64(obj.ttl);
        }
        if (obj.pubKey != null) {
          w2.uint32(58);
          w2.bytes(obj.pubKey);
        }
        if (obj.signatureV2 != null) {
          w2.uint32(66);
          w2.bytes(obj.signatureV2);
        }
        if (obj.data != null) {
          w2.uint32(74);
          w2.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w2.ldelim();
        }
      }, (reader, length2) => {
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.value = reader.bytes();
              break;
            case 2:
              obj.signatureV1 = reader.bytes();
              break;
            case 3:
              obj.validityType = IpnsEntry2.ValidityType.codec().decode(reader);
              break;
            case 4:
              obj.validity = reader.bytes();
              break;
            case 5:
              obj.sequence = reader.uint64();
              break;
            case 6:
              obj.ttl = reader.uint64();
              break;
            case 7:
              obj.pubKey = reader.bytes();
              break;
            case 8:
              obj.signatureV2 = reader.bytes();
              break;
            case 9:
              obj.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  IpnsEntry2.encode = (obj) => {
    return encodeMessage(obj, IpnsEntry2.codec());
  };
  IpnsEntry2.decode = (buf2) => {
    return decodeMessage(buf2, IpnsEntry2.codec());
  };
})(IpnsEntry || (IpnsEntry = {}));
const log$3 = logger("ipns:utils");
const IPNS_PREFIX$2 = fromString$1("/ipns/");
const LIBP2P_CID_CODEC = 114;
const extractPublicKey = async (peerId2, record) => {
  if (record == null || peerId2 == null) {
    const error = new Error("one or more of the provided parameters are not defined");
    log$3.error(error);
    throw errCode$1(error, ERR_UNDEFINED_PARAMETER);
  }
  let pubKey;
  if (record.pubKey != null) {
    try {
      pubKey = unmarshalPublicKey(record.pubKey);
    } catch (err) {
      log$3.error(err);
      throw err;
    }
    const otherId = await peerIdFromKeys(record.pubKey);
    if (!otherId.equals(peerId2)) {
      throw errCode$1(new Error("Embedded public key did not match PeerID"), ERR_INVALID_EMBEDDED_KEY);
    }
  } else if (peerId2.publicKey != null) {
    pubKey = unmarshalPublicKey(peerId2.publicKey);
  }
  if (pubKey != null) {
    return pubKey;
  }
  throw errCode$1(new Error("no public key is available"), ERR_UNDEFINED_PARAMETER);
};
const ipnsRecordDataForV2Sig = (data) => {
  const entryData = fromString$1("ipns-signature:");
  return concat$2([entryData, data]);
};
const marshal = (obj) => {
  if ("signatureV1" in obj) {
    return IpnsEntry.encode({
      value: fromString$1(obj.value),
      signatureV1: obj.signatureV1,
      validityType: obj.validityType,
      validity: fromString$1(obj.validity),
      sequence: obj.sequence,
      ttl: obj.ttl,
      pubKey: obj.pubKey,
      signatureV2: obj.signatureV2,
      data: obj.data
    });
  } else {
    return IpnsEntry.encode({
      pubKey: obj.pubKey,
      signatureV2: obj.signatureV2,
      data: obj.data
    });
  }
};
function unmarshal(buf2) {
  const message2 = IpnsEntry.decode(buf2);
  if (message2.sequence != null) {
    message2.sequence = BigInt(message2.sequence);
  }
  if (message2.ttl != null) {
    message2.ttl = BigInt(message2.ttl);
  }
  if (message2.signatureV2 == null || message2.data == null) {
    throw errCode$1(new Error("missing data or signatureV2"), ERR_SIGNATURE_VERIFICATION);
  }
  const data = parseCborData(message2.data);
  const value = normalizeValue(data.Value);
  const validity = toString$2(data.Validity);
  if (message2.value != null && message2.signatureV1 != null) {
    validateCborDataMatchesPbData(message2);
    return {
      value,
      validityType: IpnsEntry.ValidityType.EOL,
      validity,
      sequence: data.Sequence,
      ttl: data.TTL,
      pubKey: message2.pubKey,
      signatureV1: message2.signatureV1,
      signatureV2: message2.signatureV2,
      data: message2.data
    };
  } else if (message2.signatureV2 != null) {
    return {
      value,
      validityType: IpnsEntry.ValidityType.EOL,
      validity,
      sequence: data.Sequence,
      ttl: data.TTL,
      pubKey: message2.pubKey,
      signatureV2: message2.signatureV2,
      data: message2.data
    };
  } else {
    throw new Error("invalid record: does not include signatureV1 or signatureV2");
  }
}
const peerIdToRoutingKey = (peerId2) => {
  return concat$2([
    IPNS_PREFIX$2,
    peerId2.toBytes()
  ]);
};
const peerIdFromRoutingKey$1 = (key) => {
  return peerIdFromBytes(key.slice(IPNS_PREFIX$2.length));
};
const parseCborData = (buf2) => {
  const data = decode$5(buf2);
  if (data.ValidityType === 0) {
    data.ValidityType = IpnsEntry.ValidityType.EOL;
  } else {
    throw errCode$1(new Error("Unknown validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  return data;
};
const normalizeValue = (value) => {
  if (value != null) {
    if (isPeerId(value)) {
      return `/ipns/${value.toCID().toString(base36)}`;
    }
    if (value instanceof Uint8Array) {
      const string3 = toString$2(value);
      if (string3.startsWith("/")) {
        value = string3;
      }
    }
    const string2 = value.toString().trim();
    if (string2.startsWith("/") && string2.length > 1) {
      return string2;
    }
    const cid = CID.asCID(value);
    if (cid != null) {
      if (cid.code === LIBP2P_CID_CODEC) {
        return `/ipns/${cid.toString(base36)}`;
      }
      return `/ipfs/${cid.toV1().toString()}`;
    }
    try {
      if (value instanceof Uint8Array) {
        return `/ipfs/${CID.decode(value).toV1().toString()}`;
      }
      return `/ipfs/${CID.parse(string2).toV1().toString()}`;
    } catch {
    }
  }
  throw errCode$1(new Error("Value must be a valid content path starting with /"), ERR_INVALID_VALUE);
};
const validateCborDataMatchesPbData = (entry) => {
  if (entry.data == null) {
    throw errCode$1(new Error("Record data is missing"), ERR_INVALID_RECORD_DATA);
  }
  const data = parseCborData(entry.data);
  if (!equals(data.Value, entry.value ?? new Uint8Array(0))) {
    throw errCode$1(new Error('Field "value" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (!equals(data.Validity, entry.validity ?? new Uint8Array(0))) {
    throw errCode$1(new Error('Field "validity" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.ValidityType !== entry.validityType) {
    throw errCode$1(new Error('Field "validityType" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.Sequence !== entry.sequence) {
    throw errCode$1(new Error('Field "sequence" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
  if (data.TTL !== entry.ttl) {
    throw errCode$1(new Error('Field "ttl" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
  }
};
const log$2 = logger("ipns:validator");
const MAX_RECORD_SIZE = 1024 * 10;
const validate = async (publicKey, buf2) => {
  const record = unmarshal(buf2);
  let isValid2;
  try {
    const dataForSignature = ipnsRecordDataForV2Sig(record.data);
    isValid2 = await publicKey.verify(dataForSignature, record.signatureV2);
  } catch (err) {
    isValid2 = false;
  }
  if (!isValid2) {
    log$2.error("record signature verification failed");
    throw errCode$1(new Error("record signature verification failed"), ERR_SIGNATURE_VERIFICATION);
  }
  if (record.validityType === IpnsEntry.ValidityType.EOL) {
    if (NanoDate.fromString(record.validity).toDate().getTime() < Date.now()) {
      log$2.error("record has expired");
      throw errCode$1(new Error("record has expired"), ERR_IPNS_EXPIRED_RECORD);
    }
  } else if (record.validityType != null) {
    log$2.error("unrecognized validity type");
    throw errCode$1(new Error("unrecognized validity type"), ERR_UNRECOGNIZED_VALIDITY);
  }
  log$2("ipns record for %s is valid", record.value);
};
async function ipnsValidator(key, marshalledData) {
  if (marshalledData.byteLength > MAX_RECORD_SIZE) {
    throw errCode$1(new Error("record too large"), ERR_RECORD_TOO_LARGE);
  }
  const peerId2 = peerIdFromRoutingKey$1(key);
  const receivedRecord = unmarshal(marshalledData);
  const pubKey = await extractPublicKey(peerId2, receivedRecord);
  await validate(pubKey, marshalledData);
}
async function* parse(source) {
  const matcher = /\r?\n/;
  const decoder = new TextDecoder("utf8");
  let buffer2 = "";
  for await (let chunk of source) {
    if (typeof chunk === "string") {
      chunk = new TextEncoder().encode(chunk);
    }
    buffer2 += decoder.decode(chunk, { stream: true });
    const parts = buffer2.split(matcher);
    buffer2 = parts.pop() ?? "";
    for (let i = 0; i < parts.length; i++) {
      yield JSON.parse(parts[i]);
    }
  }
  buffer2 += decoder.decode();
  if (buffer2 !== "") {
    yield JSON.parse(buffer2);
  }
}
const IPNS_PREFIX$1 = fromString$1("/ipns/");
function isIPNSKey$1(key) {
  return equals(key.subarray(0, IPNS_PREFIX$1.byteLength), IPNS_PREFIX$1);
}
const peerIdFromRoutingKey = (key) => {
  return peerIdFromBytes(key.slice(IPNS_PREFIX$1.length));
};
class DelegatedRoutingV1HttpApiClientContentRouting {
  constructor(client) {
    __publicField(this, "client");
    this.client = client;
  }
  async *findProviders(cid, options2 = {}) {
    yield* map(this.client.getProviders(cid, options2), (record) => {
      return {
        id: record.ID,
        multiaddrs: record.Addrs ?? []
      };
    });
  }
  async provide() {
  }
  async put(key, value, options2) {
    if (!isIPNSKey$1(key)) {
      return;
    }
    const peerId2 = peerIdFromRoutingKey(key);
    const record = unmarshal(value);
    await this.client.putIPNS(peerId2, record, options2);
  }
  async get(key, options2) {
    if (!isIPNSKey$1(key)) {
      throw new CodeError("Not found", "ERR_NOT_FOUND");
    }
    const peerId2 = peerIdFromRoutingKey(key);
    try {
      const record = await this.client.getIPNS(peerId2, options2);
      return marshal(record);
    } catch (err) {
      if (err.code === "ERR_BAD_RESPONSE") {
        throw new CodeError("Not found", "ERR_NOT_FOUND");
      }
      throw err;
    }
  }
}
class DelegatedRoutingV1HttpApiClientPeerRouting {
  constructor(client) {
    __publicField(this, "client");
    this.client = client;
  }
  async findPeer(peerId2, options2 = {}) {
    const peer = await first(this.client.getPeers(peerId2, options2));
    if (peer != null) {
      return {
        id: peer.ID,
        multiaddrs: peer.Addrs ?? []
      };
    }
    throw new CodeError("Not found", "ERR_NOT_FOUND");
  }
  async *getClosestPeers(key, options2 = {}) {
  }
}
const log$1 = logger("delegated-routing-v1-http-api-client");
const defaultValues = {
  concurrentRequests: 4,
  timeout: 3e4
};
class DefaultDelegatedRoutingV1HttpApiClient {
  /**
   * Create a new DelegatedContentRouting instance
   */
  constructor(url, init = {}) {
    __privateAdd(this, _DefaultDelegatedRoutingV1HttpApiClient_instances);
    __publicField(this, "started");
    __publicField(this, "httpQueue");
    __publicField(this, "shutDownController");
    __publicField(this, "clientUrl");
    __publicField(this, "timeout");
    __publicField(this, "contentRouting");
    __publicField(this, "peerRouting");
    this.started = false;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.httpQueue = new PQueue({
      concurrency: init.concurrentRequests ?? defaultValues.concurrentRequests
    });
    this.clientUrl = url instanceof URL ? url : new URL(url);
    this.timeout = init.timeout ?? defaultValues.timeout;
    this.contentRouting = new DelegatedRoutingV1HttpApiClientContentRouting(this);
    this.peerRouting = new DelegatedRoutingV1HttpApiClientPeerRouting(this);
  }
  get [contentRoutingSymbol]() {
    return this.contentRouting;
  }
  get [peerRoutingSymbol]() {
    return this.peerRouting;
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.httpQueue.clear();
    this.shutDownController.abort();
    this.started = false;
  }
  async *getProviders(cid, options2 = {}) {
    log$1("getProviders starts: %c", cid);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    try {
      await onStart.promise;
      const resource = `${this.clientUrl}routing/v1/providers/${cid.toString()}`;
      const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
      const res = await fetch(resource, getOptions);
      if (res.status === 404) {
        throw new CodeError("No matching records found.", "ERR_NOT_FOUND");
      }
      if (res.status === 422) {
        throw new CodeError("Request does not conform to schema or semantic constraints.", "ERR_INVALID_REQUEST");
      }
      if (res.body == null) {
        throw new CodeError("Routing response had no body", "ERR_BAD_RESPONSE");
      }
      const contentType = res.headers.get("Content-Type");
      if (contentType === "application/json") {
        const body = await res.json();
        for (const provider of body.Providers) {
          const record = __privateMethod(this, _DefaultDelegatedRoutingV1HttpApiClient_instances, conformToPeerSchema_fn).call(this, provider);
          if (record != null) {
            yield record;
          }
        }
      } else {
        for await (const provider of parse(browserReadableStreamToIt(res.body))) {
          const record = __privateMethod(this, _DefaultDelegatedRoutingV1HttpApiClient_instances, conformToPeerSchema_fn).call(this, provider);
          if (record != null) {
            yield record;
          }
        }
      }
    } catch (err) {
      log$1.error("getProviders errored:", err);
    } finally {
      signal.clear();
      onFinish.resolve();
      log$1("getProviders finished: %c", cid);
    }
  }
  async *getPeers(peerId2, options2 = {}) {
    log$1("getPeers starts: %c", peerId2);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    try {
      await onStart.promise;
      const resource = `${this.clientUrl}routing/v1/peers/${peerId2.toCID().toString()}`;
      const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
      const res = await fetch(resource, getOptions);
      if (res.status === 404) {
        throw new CodeError("No matching records found.", "ERR_NOT_FOUND");
      }
      if (res.status === 422) {
        throw new CodeError("Request does not conform to schema or semantic constraints.", "ERR_INVALID_REQUEST");
      }
      if (res.body == null) {
        throw new CodeError("Routing response had no body", "ERR_BAD_RESPONSE");
      }
      const contentType = res.headers.get("Content-Type");
      if (contentType === "application/json") {
        const body = await res.json();
        for (const peer of body.Peers) {
          const record = __privateMethod(this, _DefaultDelegatedRoutingV1HttpApiClient_instances, conformToPeerSchema_fn).call(this, peer);
          if (record != null) {
            yield record;
          }
        }
      } else {
        for await (const peer of parse(browserReadableStreamToIt(res.body))) {
          const record = __privateMethod(this, _DefaultDelegatedRoutingV1HttpApiClient_instances, conformToPeerSchema_fn).call(this, peer);
          if (record != null) {
            yield record;
          }
        }
      }
    } catch (err) {
      log$1.error("getPeers errored:", err);
    } finally {
      signal.clear();
      onFinish.resolve();
      log$1("getPeers finished: %c", peerId2);
    }
  }
  async getIPNS(peerId2, options2 = {}) {
    log$1("getIPNS starts: %c", peerId2);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    const resource = `${this.clientUrl}routing/v1/ipns/${peerId2.toCID().toString()}`;
    try {
      await onStart.promise;
      const getOptions = { headers: { Accept: "application/vnd.ipfs.ipns-record" }, signal };
      const res = await fetch(resource, getOptions);
      log$1("getIPNS GET %s %d", resource, res.status);
      if (res.status === 404) {
        throw new CodeError("No matching records found.", "ERR_NOT_FOUND");
      }
      if (res.status === 422) {
        throw new CodeError("Request does not conform to schema or semantic constraints.", "ERR_INVALID_REQUEST");
      }
      if (res.body == null) {
        throw new CodeError("GET ipns response had no body", "ERR_BAD_RESPONSE");
      }
      const buf2 = await res.arrayBuffer();
      const body = new Uint8Array(buf2, 0, buf2.byteLength);
      if (options2.validate !== false) {
        await ipnsValidator(peerIdToRoutingKey(peerId2), body);
      }
      return unmarshal(body);
    } catch (err) {
      log$1.error("getIPNS GET %s error:", resource, err);
      throw err;
    } finally {
      signal.clear();
      onFinish.resolve();
      log$1("getIPNS finished: %c", peerId2);
    }
  }
  async putIPNS(peerId2, record, options2 = {}) {
    log$1("putIPNS starts: %c", peerId2);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    const resource = `${this.clientUrl}routing/v1/ipns/${peerId2.toCID().toString()}`;
    try {
      await onStart.promise;
      const body = marshal(record);
      const getOptions = { method: "PUT", headers: { "Content-Type": "application/vnd.ipfs.ipns-record" }, body, signal };
      const res = await fetch(resource, getOptions);
      log$1("putIPNS PUT %s %d", resource, res.status);
      if (res.status !== 200) {
        throw new CodeError("PUT ipns response had status other than 200", "ERR_BAD_RESPONSE");
      }
    } catch (err) {
      log$1.error("putIPNS PUT %s error:", resource, err.stack);
      throw err;
    } finally {
      signal.clear();
      onFinish.resolve();
      log$1("putIPNS finished: %c", peerId2);
    }
  }
}
_DefaultDelegatedRoutingV1HttpApiClient_instances = new WeakSet();
conformToPeerSchema_fn = function(record) {
  var _a3;
  const protocols = [];
  const multiaddrs = ((_a3 = record.Addrs) == null ? void 0 : _a3.map(multiaddr)) ?? [];
  if (record.Protocols != null) {
    protocols.push(...record.Protocols);
  }
  if (record.Protocol != null) {
    protocols.push(record.Protocol);
    delete record.Protocol;
  }
  return {
    ...record,
    Schema: "peer",
    ID: peerIdFromString(record.ID),
    Addrs: multiaddrs,
    Protocols: protocols
  };
};
function createDelegatedRoutingV1HttpApiClient(url, init = {}) {
  return new DefaultDelegatedRoutingV1HttpApiClient(new URL(url), init);
}
const IPNS_PREFIX = fromString$1("/ipns/");
function isIPNSKey(key) {
  return equals(key.subarray(0, IPNS_PREFIX.byteLength), IPNS_PREFIX);
}
class DelegatedHTTPRouter {
  constructor(url) {
    __publicField(this, "client");
    this.client = createDelegatedRoutingV1HttpApiClient(url);
  }
  async provide(cid, options2) {
  }
  async *findProviders(cid, options2) {
    yield* map(this.client.getProviders(cid, options2), (record) => {
      return {
        id: record.ID,
        multiaddrs: record.Addrs,
        protocols: record.Protocols
      };
    });
  }
  async put(key, value, options2) {
    if (!isIPNSKey(key)) {
      return;
    }
    const peerId2 = peerIdFromRoutingKey$1(key);
    const record = unmarshal(value);
    await this.client.putIPNS(peerId2, record, options2);
  }
  async get(key, options2) {
    if (!isIPNSKey(key)) {
      throw new CodeError("Not found", "ERR_NOT_FOUND");
    }
    const peerId2 = peerIdFromRoutingKey$1(key);
    try {
      const record = await this.client.getIPNS(peerId2, options2);
      return marshal(record);
    } catch (err) {
      if (err.code === "ERR_BAD_RESPONSE") {
        throw new CodeError("Not found", "ERR_NOT_FOUND");
      }
      throw err;
    }
  }
  async findPeer(peerId2, options2) {
    const peer = await first(this.client.getPeers(peerId2, options2));
    if (peer != null) {
      return {
        id: peer.ID,
        multiaddrs: peer.Addrs ?? []
      };
    }
    throw new CodeError("Not found", "ERR_NOT_FOUND");
  }
  async *getClosestPeers(key, options2) {
  }
}
function delegatedHTTPRouting(url) {
  return new DelegatedHTTPRouter(new URL(url));
}
const word = "[a-fA-F\\d:]";
const boundry = (options2) => options2 && options2.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
const v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
const v6segment = "[a-fA-F\\d]{1,4}";
const v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
const v4exact = new RegExp(`^${v4}$`);
const v6exact = new RegExp(`^${v6}$`);
const ipRegex = (options2) => options2 && options2.exact ? v46Exact : new RegExp(`(?:${boundry(options2)}${v4}${boundry(options2)})|(?:${boundry(options2)}${v6}${boundry(options2)})`, "g");
ipRegex.v4 = (options2) => options2 && options2.exact ? v4exact : new RegExp(`${boundry(options2)}${v4}${boundry(options2)}`, "g");
ipRegex.v6 = (options2) => options2 && options2.exact ? v6exact : new RegExp(`${boundry(options2)}${v6}${boundry(options2)}`, "g");
function functionTimeout(function_) {
  const wrappedFunction = (...arguments_) => function_(...arguments_);
  Object.defineProperty(wrappedFunction, "name", {
    value: `functionTimeout(${function_.name || "<anonymous>"})`,
    configurable: true
  });
  return wrappedFunction;
}
const { toString } = Object.prototype;
function isRegexp(value) {
  return toString.call(value) === "[object RegExp]";
}
const flagMap = {
  global: "g",
  ignoreCase: "i",
  multiline: "m",
  dotAll: "s",
  sticky: "y",
  unicode: "u"
};
function clonedRegexp(regexp, options2 = {}) {
  if (!isRegexp(regexp)) {
    throw new TypeError("Expected a RegExp instance");
  }
  const flags = Object.keys(flagMap).map((flag) => (typeof options2[flag] === "boolean" ? options2[flag] : regexp[flag]) ? flagMap[flag] : "").join("");
  const clonedRegexp2 = new RegExp(options2.source || regexp.source, flags);
  clonedRegexp2.lastIndex = typeof options2.lastIndex === "number" ? options2.lastIndex : regexp.lastIndex;
  return clonedRegexp2;
}
function isMatch(regex, string2, { timeout } = {}) {
  try {
    return functionTimeout(() => clonedRegexp(regex).test(string2), { timeout })();
  } catch (error) {
    throw error;
  }
}
const maxIPv4Length = 15;
const maxIPv6Length = 45;
const options = {
  timeout: 400
};
function isIPv6(string2) {
  if (string2.length > maxIPv6Length) {
    return false;
  }
  return isMatch(ipRegex.v6({ exact: true }), string2, options);
}
function isIPv4(string2) {
  if (string2.length > maxIPv4Length) {
    return false;
  }
  return isMatch(ipRegex.v4({ exact: true }), string2, options);
}
const portFor = {
  http: "80",
  https: "443",
  ws: "80",
  wss: "443"
};
const BROWSER_SCHEMES = ["http", "https", "ws", "wss"];
function uriToMultiaddr(uriStr, opts) {
  opts = opts ?? {};
  const defaultDnsType = opts.defaultDnsType ?? "dns4";
  const { scheme, hostname, port: port2 } = parseUri(uriStr);
  const parts = [
    tupleForHostname(hostname, defaultDnsType),
    tupleForPort(port2, scheme),
    tupleForScheme(scheme)
  ];
  const multiaddrStr = "/" + parts.filter((x2) => Boolean(x2)).reduce((a, b) => a.concat(b), []).join("/");
  return multiaddr(multiaddrStr);
}
function parseUri(uriStr) {
  const [scheme] = uriStr.split(":");
  if (!BROWSER_SCHEMES.includes(scheme)) {
    uriStr = "http" + uriStr.substring(scheme.length);
  }
  let { protocol, hostname, port: port2 } = new URL(uriStr);
  if (port2 == null || port2 === "") {
    const protocolPort = portForProtocol(scheme);
    if (protocolPort != null) {
      port2 = protocolPort;
    }
    if (protocolPort == null && protocol === "http:") {
      port2 = "80";
    }
  }
  return { scheme, hostname, port: port2 };
}
function tupleForHostname(hostname, defaultDnsType) {
  if (hostname == null || hostname === "") {
    return void 0;
  }
  if (isIPv4(hostname)) {
    return ["ip4", hostname];
  }
  if (isIPv6(hostname)) {
    return ["ip6", hostname];
  }
  if (hostname[0] === "[") {
    const trimmed = hostname.substring(1, hostname.length - 1);
    if (isIPv6(trimmed)) {
      return ["ip6", trimmed];
    }
  }
  return [defaultDnsType, hostname];
}
function tupleForPort(port2, scheme) {
  if (port2 == null || port2 === "") {
    return void 0;
  }
  if (scheme === "udp") {
    return ["udp", port2];
  }
  return ["tcp", port2];
}
function tupleForScheme(scheme) {
  if (scheme.match(/^tcp$|^udp$/) != null) {
    return void 0;
  }
  return [scheme];
}
function portForProtocol(protocol) {
  if (protocol == null || protocol === "" || portFor[protocol] == null) {
    return void 0;
  }
  return portFor[protocol];
}
const DEFAULT_TRUSTLESS_GATEWAYS = [
  // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/
  "https://trustless-gateway.link",
  // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/
  "https://4everland.io"
];
const TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
const inspect = Symbol.for("nodejs.util.inspect.custom");
class URLPeerId {
  constructor(url) {
    __publicField(this, "type", "url");
    __publicField(this, "multihash");
    __publicField(this, "privateKey");
    __publicField(this, "publicKey");
    __publicField(this, "url");
    __publicField(this, _g, true);
    this.url = url.toString();
    this.multihash = identity.digest(fromString$1(this.url));
  }
  [(_h = inspect, _g = peerIdSymbol, _h)]() {
    return `PeerId(${this.url})`;
  }
  toString() {
    return this.toCID().toString();
  }
  toCID() {
    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.multihash);
  }
  toBytes() {
    return this.toCID().bytes;
  }
  equals(other) {
    if (other == null) {
      return false;
    }
    if (other instanceof Uint8Array) {
      other = toString$2(other);
    }
    return other.toString() === this.toString();
  }
}
function toPeerInfo(url) {
  url = url.toString();
  return {
    id: new URLPeerId(new URL(url)),
    multiaddrs: [
      uriToMultiaddr(url)
    ]
  };
}
class HTTPGatwayRouter {
  constructor(init = {}) {
    __publicField(this, "gateways");
    this.gateways = (init.gateways ?? DEFAULT_TRUSTLESS_GATEWAYS).map((url) => toPeerInfo(url));
  }
  async *findProviders(cid, options2) {
    yield* this.gateways.toSorted(() => Math.random() > 0.5 ? 1 : -1).map((info) => ({
      ...info,
      protocols: ["transport-ipfs-gateway-http"]
    }));
  }
}
function httpGatewayRouting(init = {}) {
  return new HTTPGatwayRouter(init);
}
function notFoundError(err) {
  err = err ?? new Error("Not Found");
  return errCode$1(err, "ERR_NOT_FOUND");
}
const SHARDING_FN = "SHARDING";
class BaseDatastore2 {
  put(key, val, options2) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options2) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options2) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options2) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options2 = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options2);
      yield key;
    }
  }
  async *getMany(source, options2 = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options2)
      };
    }
  }
  async *deleteMany(source, options2 = {}) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options2) => {
        await drain(this.putMany(puts, options2));
        puts = [];
        await drain(this.deleteMany(dels, options2));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q2, options2) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q2, options2) {
    throw new Error("._allKeys is not implemented");
  }
  query(q2, options2) {
    let it = this._all(q2, options2);
    if (q2.prefix != null) {
      const prefix = q2.prefix;
      it = filter(it, (e) => e.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q2.filters)) {
      it = q2.filters.reduce((it2, f2) => filter(it2, f2), it);
    }
    if (Array.isArray(q2.orders)) {
      it = q2.orders.reduce((it2, f2) => sort(it2, f2), it);
    }
    if (q2.offset != null) {
      let i = 0;
      const offset = q2.offset;
      it = filter(it, () => i++ >= offset);
    }
    if (q2.limit != null) {
      it = take(it, q2.limit);
    }
    return it;
  }
  queryKeys(q2, options2) {
    let it = this._allKeys(q2, options2);
    if (q2.prefix != null) {
      const prefix = q2.prefix;
      it = filter(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q2.filters)) {
      it = q2.filters.reduce((it2, f2) => filter(it2, f2), it);
    }
    if (Array.isArray(q2.orders)) {
      it = q2.orders.reduce((it2, f2) => sort(it2, f2), it);
    }
    if (q2.offset != null) {
      const offset = q2.offset;
      let i = 0;
      it = filter(it, () => i++ >= offset);
    }
    if (q2.limit != null) {
      it = take(it, q2.limit);
    }
    return it;
  }
}
class MemoryDatastore extends BaseDatastore2 {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(key.toString(), val);
    return key;
  }
  get(key) {
    const result = this.data.get(key.toString());
    if (result == null) {
      throw notFoundError();
    }
    return result;
  }
  has(key) {
    return this.data.has(key.toString());
  }
  delete(key) {
    this.data.delete(key.toString());
  }
  *_all() {
    for (const [key, value] of this.data.entries()) {
      yield { key: new Key(key), value };
    }
  }
  *_allKeys() {
    for (const key of this.data.keys()) {
      yield new Key(key);
    }
  }
}
new Key(SHARDING_FN);
logger("datastore:core:tiered");
async function createHeliaHTTP(init = {}) {
  const datastore = init.datastore ?? new MemoryDatastore();
  const blockstore = init.blockstore ?? new MemoryBlockstore();
  const helia = new Helia({
    ...init,
    datastore,
    blockstore,
    blockBrokers: init.blockBrokers ?? [
      trustlessGateway()
    ],
    routers: init.routers ?? [
      delegatedHTTPRouting("https://delegated-ipfs.dev"),
      httpGatewayRouting()
    ]
  });
  if (init.start !== false) {
    await helia.start();
  }
  return helia;
}
const BASE_PATH = "https://pinning-service.example.com".replace(/\/+$/, "");
const isBlob = (value) => typeof Blob !== "undefined" && value instanceof Blob;
class BaseAPI {
  constructor(configuration = new Configuration$1()) {
    this.configuration = configuration;
    this.fetchApi = async (url, init) => {
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = await middleware.pre({
            fetch: this.fetchApi,
            ...fetchParams
          }) || fetchParams;
        }
      }
      let response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = await middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          }) || response;
        }
      }
      return response;
    };
    this.middleware = configuration.middleware;
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  async request(context, initOverrides) {
    const { url, init } = this.createFetchParams(context, initOverrides);
    const response = await this.fetchApi(url, init);
    if (response.status >= 200 && response.status < 300) {
      return response;
    }
    throw response;
  }
  createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const body = typeof FormData !== "undefined" && context.body instanceof FormData || context.body instanceof URLSearchParams || isBlob(context.body) ? context.body : JSON.stringify(context.body);
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    const init = {
      method: context.method,
      headers,
      body,
      credentials: this.configuration.credentials,
      ...initOverrides
    };
    return { url, init };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
}
class RequiredError extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
}
const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "	",
  pipes: "|"
};
let Configuration$1 = class Configuration {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : async () => accessToken;
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
function exists(json, key) {
  const value = json[key];
  return value !== null && value !== void 0;
}
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => {
    const fullKey = prefix + (prefix.length ? `[${key}]` : key);
    const value = params[key];
    if (value instanceof Array) {
      const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
      return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Date) {
      return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
      return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
  }).filter((part) => part.length > 0).join("&");
}
class JSONApiResponse {
  constructor(raw2, transformer = (jsonValue) => jsonValue) {
    this.raw = raw2;
    this.transformer = transformer;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
}
class VoidApiResponse {
  constructor(raw2) {
    this.raw = raw2;
  }
  async value() {
    return void 0;
  }
}
function PinFromJSON(json) {
  return PinFromJSONTyped(json);
}
function PinFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "cid": json["cid"],
    "name": !exists(json, "name") ? void 0 : json["name"],
    "origins": !exists(json, "origins") ? void 0 : json["origins"],
    "meta": !exists(json, "meta") ? void 0 : json["meta"]
  };
}
function PinToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "cid": value.cid,
    "name": value.name,
    "origins": value.origins,
    "meta": value.meta
  };
}
var Status;
(function(Status2) {
  Status2["Queued"] = "queued";
  Status2["Pinning"] = "pinning";
  Status2["Pinned"] = "pinned";
  Status2["Failed"] = "failed";
})(Status || (Status = {}));
function StatusFromJSON(json) {
  return StatusFromJSONTyped(json);
}
function StatusFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PinStatusFromJSON(json) {
  return PinStatusFromJSONTyped(json);
}
function PinStatusFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "requestid": json["requestid"],
    "status": StatusFromJSON(json["status"]),
    "created": new Date(json["created"]),
    "pin": PinFromJSON(json["pin"]),
    "delegates": json["delegates"],
    "info": !exists(json, "info") ? void 0 : json["info"]
  };
}
function PinResultsFromJSON(json) {
  return PinResultsFromJSONTyped(json);
}
function PinResultsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "count": json["count"],
    "results": new Set(json["results"].map(PinStatusFromJSON))
  };
}
var TextMatchingStrategy;
(function(TextMatchingStrategy2) {
  TextMatchingStrategy2["Exact"] = "exact";
  TextMatchingStrategy2["Iexact"] = "iexact";
  TextMatchingStrategy2["Partial"] = "partial";
  TextMatchingStrategy2["Ipartial"] = "ipartial";
})(TextMatchingStrategy || (TextMatchingStrategy = {}));
class PinsApi extends BaseAPI {
  /**
   * List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
   * List pin objects
   */
  async pinsGetRaw(requestParameters, initOverrides) {
    const queryParameters = {};
    if (requestParameters.cid) {
      queryParameters["cid"] = Array.from(requestParameters.cid).join(COLLECTION_FORMATS["csv"]);
    }
    if (requestParameters.name !== void 0) {
      queryParameters["name"] = requestParameters.name;
    }
    if (requestParameters.match !== void 0) {
      queryParameters["match"] = requestParameters.match;
    }
    if (requestParameters.status) {
      queryParameters["status"] = Array.from(requestParameters.status).join(COLLECTION_FORMATS["csv"]);
    }
    if (requestParameters.before !== void 0) {
      queryParameters["before"] = requestParameters.before.toISOString();
    }
    if (requestParameters.after !== void 0) {
      queryParameters["after"] = requestParameters.after.toISOString();
    }
    if (requestParameters.limit !== void 0) {
      queryParameters["limit"] = requestParameters.limit;
    }
    if (requestParameters.meta !== void 0) {
      queryParameters["meta"] = requestParameters.meta;
    }
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token2 = this.configuration.accessToken;
      const tokenString = await token2("accessToken", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/pins`,
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PinResultsFromJSON(jsonValue));
  }
  /**
   * List all the pin objects, matching optional filters; when no filter is provided, only successful pins are returned
   * List pin objects
   */
  async pinsGet(requestParameters = {}, initOverrides) {
    const response = await this.pinsGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Add a new pin object for the current access token
   * Add pin object
   */
  async pinsPostRaw(requestParameters, initOverrides) {
    if (requestParameters.pin === null || requestParameters.pin === void 0) {
      throw new RequiredError("pin", "Required parameter requestParameters.pin was null or undefined when calling pinsPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token2 = this.configuration.accessToken;
      const tokenString = await token2("accessToken", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/pins`,
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PinToJSON(requestParameters.pin)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PinStatusFromJSON(jsonValue));
  }
  /**
   * Add a new pin object for the current access token
   * Add pin object
   */
  async pinsPost(requestParameters, initOverrides) {
    const response = await this.pinsPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Remove a pin object
   * Remove pin object
   */
  async pinsRequestidDeleteRaw(requestParameters, initOverrides) {
    if (requestParameters.requestid === null || requestParameters.requestid === void 0) {
      throw new RequiredError("requestid", "Required parameter requestParameters.requestid was null or undefined when calling pinsRequestidDelete.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token2 = this.configuration.accessToken;
      const tokenString = await token2("accessToken", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/pins/{requestid}`.replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
      method: "DELETE",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new VoidApiResponse(response);
  }
  /**
   * Remove a pin object
   * Remove pin object
   */
  async pinsRequestidDelete(requestParameters, initOverrides) {
    await this.pinsRequestidDeleteRaw(requestParameters, initOverrides);
  }
  /**
   * Get a pin object and its status
   * Get pin object
   */
  async pinsRequestidGetRaw(requestParameters, initOverrides) {
    if (requestParameters.requestid === null || requestParameters.requestid === void 0) {
      throw new RequiredError("requestid", "Required parameter requestParameters.requestid was null or undefined when calling pinsRequestidGet.");
    }
    const queryParameters = {};
    const headerParameters = {};
    if (this.configuration && this.configuration.accessToken) {
      const token2 = this.configuration.accessToken;
      const tokenString = await token2("accessToken", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/pins/{requestid}`.replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
      method: "GET",
      headers: headerParameters,
      query: queryParameters
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PinStatusFromJSON(jsonValue));
  }
  /**
   * Get a pin object and its status
   * Get pin object
   */
  async pinsRequestidGet(requestParameters, initOverrides) {
    const response = await this.pinsRequestidGetRaw(requestParameters, initOverrides);
    return await response.value();
  }
  /**
   * Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
   * Replace pin object
   */
  async pinsRequestidPostRaw(requestParameters, initOverrides) {
    if (requestParameters.requestid === null || requestParameters.requestid === void 0) {
      throw new RequiredError("requestid", "Required parameter requestParameters.requestid was null or undefined when calling pinsRequestidPost.");
    }
    if (requestParameters.pin === null || requestParameters.pin === void 0) {
      throw new RequiredError("pin", "Required parameter requestParameters.pin was null or undefined when calling pinsRequestidPost.");
    }
    const queryParameters = {};
    const headerParameters = {};
    headerParameters["Content-Type"] = "application/json";
    if (this.configuration && this.configuration.accessToken) {
      const token2 = this.configuration.accessToken;
      const tokenString = await token2("accessToken", []);
      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request({
      path: `/pins/{requestid}`.replace(`{${"requestid"}}`, encodeURIComponent(String(requestParameters.requestid))),
      method: "POST",
      headers: headerParameters,
      query: queryParameters,
      body: PinToJSON(requestParameters.pin)
    }, initOverrides);
    return new JSONApiResponse(response, (jsonValue) => PinStatusFromJSON(jsonValue));
  }
  /**
   * Replace an existing pin object (shortcut for executing remove and add operations in one step to avoid unnecessary garbage collection of blocks present in both recursive pins)
   * Replace pin object
   */
  async pinsRequestidPost(requestParameters, initOverrides) {
    const response = await this.pinsRequestidPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
}
class Configuration2 extends Configuration$1 {
  constructor(options2) {
    const finalOptions = { ...options2 };
    if (options2.fetchApi == null) {
      finalOptions.fetchApi = fetch;
    }
    if (options2.endpointUrl != null) {
      finalOptions.basePath = options2.endpointUrl;
    }
    super(finalOptions);
  }
}
var retry$2 = {};
function RetryOperation(timeouts, options2) {
  if (typeof options2 === "boolean") {
    options2 = { forever: options2 };
  }
  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options2 || {};
  this._maxRetryTime = options2 && options2.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;
  this._timer = null;
  if (this._options.forever) {
    this._cachedTimeouts = this._timeouts.slice(0);
  }
}
var retry_operation = RetryOperation;
RetryOperation.prototype.reset = function() {
  this._attempts = 1;
  this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (this._timer) {
    clearTimeout(this._timer);
  }
  this._timeouts = [];
  this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(err) {
  if (this._timeout) {
    clearTimeout(this._timeout);
  }
  if (!err) {
    return false;
  }
  var currentTime = (/* @__PURE__ */ new Date()).getTime();
  if (err && currentTime - this._operationStart >= this._maxRetryTime) {
    this._errors.push(err);
    this._errors.unshift(new Error("RetryOperation timeout occurred"));
    return false;
  }
  this._errors.push(err);
  var timeout = this._timeouts.shift();
  if (timeout === void 0) {
    if (this._cachedTimeouts) {
      this._errors.splice(0, this._errors.length - 1);
      timeout = this._cachedTimeouts.slice(-1);
    } else {
      return false;
    }
  }
  var self2 = this;
  this._timer = setTimeout(function() {
    self2._attempts++;
    if (self2._operationTimeoutCb) {
      self2._timeout = setTimeout(function() {
        self2._operationTimeoutCb(self2._attempts);
      }, self2._operationTimeout);
      if (self2._options.unref) {
        self2._timeout.unref();
      }
    }
    self2._fn(self2._attempts);
  }, timeout);
  if (this._options.unref) {
    this._timer.unref();
  }
  return true;
};
RetryOperation.prototype.attempt = function(fn, timeoutOps) {
  this._fn = fn;
  if (timeoutOps) {
    if (timeoutOps.timeout) {
      this._operationTimeout = timeoutOps.timeout;
    }
    if (timeoutOps.cb) {
      this._operationTimeoutCb = timeoutOps.cb;
    }
  }
  var self2 = this;
  if (this._operationTimeoutCb) {
    this._timeout = setTimeout(function() {
      self2._operationTimeoutCb();
    }, self2._operationTimeout);
  }
  this._operationStart = (/* @__PURE__ */ new Date()).getTime();
  this._fn(this._attempts);
};
RetryOperation.prototype.try = function(fn) {
  console.log("Using RetryOperation.try() is deprecated");
  this.attempt(fn);
};
RetryOperation.prototype.start = function(fn) {
  console.log("Using RetryOperation.start() is deprecated");
  this.attempt(fn);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
  return this._errors;
};
RetryOperation.prototype.attempts = function() {
  return this._attempts;
};
RetryOperation.prototype.mainError = function() {
  if (this._errors.length === 0) {
    return null;
  }
  var counts = {};
  var mainError = null;
  var mainErrorCount = 0;
  for (var i = 0; i < this._errors.length; i++) {
    var error = this._errors[i];
    var message2 = error.message;
    var count2 = (counts[message2] || 0) + 1;
    counts[message2] = count2;
    if (count2 >= mainErrorCount) {
      mainError = error;
      mainErrorCount = count2;
    }
  }
  return mainError;
};
(function(exports) {
  var RetryOperation2 = retry_operation;
  exports.operation = function(options2) {
    var timeouts = exports.timeouts(options2);
    return new RetryOperation2(timeouts, {
      forever: options2 && (options2.forever || options2.retries === Infinity),
      unref: options2 && options2.unref,
      maxRetryTime: options2 && options2.maxRetryTime
    });
  };
  exports.timeouts = function(options2) {
    if (options2 instanceof Array) {
      return [].concat(options2);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options2) {
      opts[key] = options2[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i = 0; i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }
    if (options2 && options2.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }
    timeouts.sort(function(a, b) {
      return a - b;
    });
    return timeouts;
  };
  exports.createTimeout = function(attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports.wrap = function(obj, options2, methods) {
    if (options2 instanceof Array) {
      methods = options2;
      options2 = null;
    }
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          methods.push(key);
        }
      }
    }
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      var original = obj[method];
      obj[method] = (function retryWrapper(original2) {
        var op = exports.operation(options2);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args);
        });
      }).bind(obj, original);
      obj[method].options = options2;
    }
  };
})(retry$2);
var retry = retry$2;
const retry$1 = /* @__PURE__ */ getDefaultExportFromCjs(retry);
const objectToString = Object.prototype.toString;
const isError = (value) => objectToString.call(value) === "[object Error]";
const errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Load failed",
  // Safari 17+
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated"
  // Undici (Node.js)
]);
function isNetworkError(error) {
  const isValid2 = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid2) {
    return false;
  }
  if (error.message === "Load failed") {
    return error.stack === void 0;
  }
  return errorMessages.has(error.message);
}
class AbortError5 extends Error {
  constructor(message2) {
    super();
    if (message2 instanceof Error) {
      this.originalError = message2;
      ({ message: message2 } = message2);
    } else {
      this.originalError = new Error(message2);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message2;
  }
}
const decorateErrorWithCounts = (error, attemptNumber, options2) => {
  const retriesLeft = options2.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
async function pRetry(input, options2) {
  return new Promise((resolve2, reject) => {
    options2 = {
      onFailedAttempt() {
      },
      retries: 10,
      shouldRetry: () => true,
      ...options2
    };
    const operation = retry$1.operation(options2);
    const abortHandler = () => {
      var _a3;
      operation.stop();
      reject((_a3 = options2.signal) == null ? void 0 : _a3.reason);
    };
    if (options2.signal && !options2.signal.aborted) {
      options2.signal.addEventListener("abort", abortHandler, { once: true });
    }
    const cleanUp = () => {
      var _a3;
      (_a3 = options2.signal) == null ? void 0 : _a3.removeEventListener("abort", abortHandler);
      operation.stop();
    };
    operation.attempt(async (attemptNumber) => {
      try {
        const result = await input(attemptNumber);
        cleanUp();
        resolve2(result);
      } catch (error) {
        try {
          if (!(error instanceof Error)) {
            throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
          }
          if (error instanceof AbortError5) {
            throw error.originalError;
          }
          if (error instanceof TypeError && !isNetworkError(error)) {
            throw error;
          }
          decorateErrorWithCounts(error, attemptNumber, options2);
          if (!await options2.shouldRetry(error)) {
            operation.stop();
            reject(error);
          }
          await options2.onFailedAttempt(error);
          if (!operation.retry(error)) {
            throw operation.mainError();
          }
        } catch (finalError) {
          decorateErrorWithCounts(finalError, attemptNumber, options2);
          cleanUp();
          reject(finalError);
        }
      }
    });
  });
}
const log = logger("helia:remote-pinning");
class HeliaRemotePinner {
  constructor(heliaInstance, remotePinningClient, config2) {
    __privateAdd(this, _HeliaRemotePinner_instances);
    __publicField(this, "heliaInstance");
    __publicField(this, "remotePinningClient");
    __publicField(this, "config");
    this.heliaInstance = heliaInstance;
    this.remotePinningClient = remotePinningClient;
    this.config = {
      ...config2,
      mergeOrigins: (config2 == null ? void 0 : config2.mergeOrigins) ?? false,
      retryOptions: {
        retries: 10,
        ...config2 == null ? void 0 : config2.retryOptions
      }
    };
  }
  /**
   * This method is used to get the origins that the pinning provider can use to retrieve the content.
   * If passed origins, it will use those origins. Otherwise, it will use the libp2p multiaddrs.
   * If mergeOrigins is true, it will merge the origins from the libp2p node with the provided origins.
   *
   * @param providedOrigins - provided origins
   * @returns
   */
  getOrigins(providedOrigins = []) {
    if (providedOrigins.length > 0 && !this.config.mergeOrigins) {
      return providedOrigins;
    }
    const multiaddrs = this.heliaInstance.libp2p.getMultiaddrs();
    const origins = /* @__PURE__ */ new Set([...providedOrigins, ...multiaddrs]);
    return [...origins];
  }
  async connectToDelegates(delegates, signal) {
    var _a3, _b2;
    try {
      const filteredDelegates = ((_b2 = (_a3 = this.config).filterDelegates) == null ? void 0 : _b2.call(_a3, [...delegates])) ?? [...delegates];
      await Promise.any(filteredDelegates.map(async (delegate) => {
        try {
          await this.heliaInstance.libp2p.dial(multiaddr(delegate), { signal });
        } catch (e) {
          log.error("Failed to connect to delegate %s", delegate, e);
          throw e;
        }
      }));
    } catch (e) {
      log.error("Failed to connect to any delegates", e);
    }
  }
  /**
   * The code that runs after we get a pinStatus from the remote pinning service.
   * This method is the orchestrator for waiting for the pin to complete/fail as well as connecting to the delegates.
   */
  async handlePinStatus(pinStatus, signal) {
    var _a3;
    await this.connectToDelegates(pinStatus.delegates, signal);
    let updatedPinStatus = pinStatus;
    try {
      await pRetry(async (attemptNum) => {
        updatedPinStatus = await this.remotePinningClient.pinsRequestidGet({ requestid: pinStatus.requestid });
        log.trace("attempt #%d pinStatus: %s", attemptNum, updatedPinStatus.status);
        if ([Status.Pinned, Status.Failed].includes(pinStatus.status)) {
          return updatedPinStatus;
        }
        throw new Error(`Pin status is ${pinStatus.status}`);
      }, {
        signal,
        ...(_a3 = this.config) == null ? void 0 : _a3.retryOptions
      });
    } catch (e) {
      log.error(e);
    }
    log.trace("final pinStatus: %s", updatedPinStatus.status);
    return updatedPinStatus;
  }
  async addPin({ cid, signal, ...otherArgs }) {
    signal == null ? void 0 : signal.throwIfAborted();
    const pinStatus = await this.remotePinningClient.pinsPost({
      pin: __privateMethod(this, _HeliaRemotePinner_instances, getPinArg_fn).call(this, { cid, ...otherArgs })
    }, {
      signal
    });
    log.trace("Initial pinsPost made, status: %s", pinStatus.status);
    return this.handlePinStatus(pinStatus, signal);
  }
  async replacePin({ cid, requestid, signal, ...otherArgs }) {
    signal == null ? void 0 : signal.throwIfAborted();
    const pinStatus = await this.remotePinningClient.pinsRequestidPost({
      requestid,
      pin: __privateMethod(this, _HeliaRemotePinner_instances, getPinArg_fn).call(this, { cid, ...otherArgs })
    }, {
      signal
    });
    log.trace("Initial pinReplace made, status: %s", pinStatus.status);
    return this.handlePinStatus(pinStatus, signal);
  }
}
_HeliaRemotePinner_instances = new WeakSet();
getPinArg_fn = function({ cid, ...otherArgs }) {
  var _a3, _b2;
  const origins = this.getOrigins(otherArgs.origins);
  const filteredOrigins = ((_b2 = (_a3 = this.config).filterOrigins) == null ? void 0 : _b2.call(_a3, origins)) ?? origins;
  return {
    ...otherArgs,
    cid: cid.toString(),
    // @ts-expect-error - broken types: origins needs to be an array of strings
    origins: filteredOrigins.length > 0 ? filteredOrigins.map((ma) => ma.toString()) : void 0
  };
};
function createRemotePinner(heliaInstance, remotePinningClient, config2) {
  return new HeliaRemotePinner(heliaInstance, remotePinningClient, config2);
}
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Download = createLucideIcon("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const EllipsisVertical = createLucideIcon("EllipsisVertical", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
  ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Folder = createLucideIcon("Folder", [
  [
    "path",
    {
      d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z",
      key: "1kt360"
    }
  ]
]);
/**
 * @license lucide-react v0.396.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Trash = createLucideIcon("Trash", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }]
]);
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value);
  } else {
    return new Date(value);
  }
}
function addDays(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}
function addMonths(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}
function addYears(date, amount) {
  return addMonths(date, amount * 12);
}
function subDays(date, amount) {
  return addDays(date, -amount);
}
function subMonths(date, amount) {
  return addMonths(date, -amount);
}
function subYears(date, amount) {
  return addYears(date, -amount);
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e = new Event("vite:preloadError", {
      cancelable: true
    });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
var browserPolyfill = {};
var hasRequiredBrowserPolyfill;
function requireBrowserPolyfill() {
  if (hasRequiredBrowserPolyfill) return browserPolyfill;
  hasRequiredBrowserPolyfill = 1;
  (function() {
    (function(self2) {
      (function(exports) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name2.toLowerCase();
        }
        function normalizeValue2(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue2(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue2(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve2, reject) {
            reader.onload = function() {
              resolve2(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf2) {
          var view = new Uint8Array(buf2);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf2) {
          if (buf2.slice) {
            return buf2.slice(0);
          } else {
            var view = new Uint8Array(buf2.byteLength);
            view.set(new Uint8Array(buf2));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request2(input, options2) {
          options2 = options2 || {};
          var body = options2.body;
          if (input instanceof Request2) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options2.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options2.credentials || this.credentials || "same-origin";
          if (options2.headers || !this.headers) {
            this.headers = new Headers(options2.headers);
          }
          this.method = normalizeMethod(options2.method || this.method || "GET");
          this.mode = options2.mode || this.mode || null;
          this.signal = options2.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request2.prototype.clone = function() {
          return new Request2(this, { body: this._bodyInit });
        };
        function decode2(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes2) {
            if (bytes2) {
              var split2 = bytes2.split("=");
              var name2 = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request2.prototype);
        function Response2(bodyInit, options2) {
          if (!options2) {
            options2 = {};
          }
          this.type = "default";
          this.status = options2.status === void 0 ? 200 : options2.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options2 ? options2.statusText : "OK";
          this.headers = new Headers(options2.headers);
          this.url = options2.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url } });
        };
        exports.DOMException = self2.DOMException;
        try {
          new exports.DOMException();
        } catch (err) {
          exports.DOMException = function(message2, name2) {
            this.message = message2;
            this.name = name2;
            var error = Error(message2);
            this.stack = error.stack;
          };
          exports.DOMException.prototype = Object.create(Error.prototype);
          exports.DOMException.prototype.constructor = exports.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve2, reject) {
            var request = new Request2(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options2 = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options2.url = "responseURL" in xhr ? xhr.responseURL : options2.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve2(new Response2(body, options2));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name2) {
              xhr.setRequestHeader(name2, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request2;
          self2.Response = Response2;
        }
        exports.Headers = Headers;
        exports.Request = Request2;
        exports.Response = Response2;
        exports.fetch = fetch2;
        Object.defineProperty(exports, "__esModule", { value: true });
        return exports;
      })({});
    })(typeof self !== "undefined" ? self : commonjsGlobal);
  })();
  return browserPolyfill;
}
const TaskStatus = {
  TASK_SUCCEEDED: "succeeded",
  TASK_PROCESSING: "processing",
  TASK_FAILED: "failed",
  TASK_ENQUEUED: "enqueued",
  TASK_CANCELED: "canceled"
};
const ErrorStatusCode = {
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_creation_failed */
  INDEX_CREATION_FAILED: "index_creation_failed",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_index_uid */
  MISSING_INDEX_UID: "missing_index_uid",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_already_exists */
  INDEX_ALREADY_EXISTS: "index_already_exists",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_not_found */
  INDEX_NOT_FOUND: "index_not_found",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_uid */
  INVALID_INDEX_UID: "invalid_index_uid",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_not_accessible */
  INDEX_NOT_ACCESSIBLE: "index_not_accessible",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_offset */
  INVALID_INDEX_OFFSET: "invalid_index_offset",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_limit */
  INVALID_INDEX_LIMIT: "invalid_index_limit",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_state */
  INVALID_STATE: "invalid_state",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#primary_key_inference_failed */
  PRIMARY_KEY_INFERENCE_FAILED: "primary_key_inference_failed",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#index_primary_key_already_exists */
  INDEX_PRIMARY_KEY_ALREADY_EXISTS: "index_primary_key_already_exists",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_index_primary_key */
  INVALID_INDEX_PRIMARY_KEY: "invalid_index_primary_key",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#max_fields_limit_exceeded */
  DOCUMENTS_FIELDS_LIMIT_REACHED: "document_fields_limit_reached",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_id */
  MISSING_DOCUMENT_ID: "missing_document_id",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_id */
  INVALID_DOCUMENT_ID: "invalid_document_id",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_content_type */
  INVALID_CONTENT_TYPE: "invalid_content_type",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_content_type */
  MISSING_CONTENT_TYPE: "missing_content_type",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_fields */
  INVALID_DOCUMENT_FIELDS: "invalid_document_fields",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_limit */
  INVALID_DOCUMENT_LIMIT: "invalid_document_limit",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_offset */
  INVALID_DOCUMENT_OFFSET: "invalid_document_offset",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_filter */
  INVALID_DOCUMENT_FILTER: "invalid_document_filter",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_document_filter */
  MISSING_DOCUMENT_FILTER: "missing_document_filter",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_vectors_field */
  INVALID_DOCUMENT_VECTORS_FIELD: "invalid_document_vectors_field",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#payload_too_large */
  PAYLOAD_TOO_LARGE: "payload_too_large",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_payload */
  MISSING_PAYLOAD: "missing_payload",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#malformed_payload */
  MALFORMED_PAYLOAD: "malformed_payload",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#no_space_left_on_device */
  NO_SPACE_LEFT_ON_DEVICE: "no_space_left_on_device",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_store_file */
  INVALID_STORE_FILE: "invalid_store_file",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_ranking_rules */
  INVALID_RANKING_RULES: "missing_document_id",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_request */
  INVALID_REQUEST: "invalid_request",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_document_geo_field */
  INVALID_DOCUMENT_GEO_FIELD: "invalid_document_geo_field",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_q */
  INVALID_SEARCH_Q: "invalid_search_q",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_offset */
  INVALID_SEARCH_OFFSET: "invalid_search_offset",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_limit */
  INVALID_SEARCH_LIMIT: "invalid_search_limit",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_page */
  INVALID_SEARCH_PAGE: "invalid_search_page",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_hits_per_page */
  INVALID_SEARCH_HITS_PER_PAGE: "invalid_search_hits_per_page",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_retrieve */
  INVALID_SEARCH_ATTRIBUTES_TO_RETRIEVE: "invalid_search_attributes_to_retrieve",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_crop */
  INVALID_SEARCH_ATTRIBUTES_TO_CROP: "invalid_search_attributes_to_crop",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_crop_length */
  INVALID_SEARCH_CROP_LENGTH: "invalid_search_crop_length",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_highlight */
  INVALID_SEARCH_ATTRIBUTES_TO_HIGHLIGHT: "invalid_search_attributes_to_highlight",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_show_matches_position */
  INVALID_SEARCH_SHOW_MATCHES_POSITION: "invalid_search_show_matches_position",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_filter */
  INVALID_SEARCH_FILTER: "invalid_search_filter",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_sort */
  INVALID_SEARCH_SORT: "invalid_search_sort",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_facets */
  INVALID_SEARCH_FACETS: "invalid_search_facets",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_highlight_pre_tag */
  INVALID_SEARCH_HIGHLIGHT_PRE_TAG: "invalid_search_highlight_pre_tag",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_highlight_post_tag */
  INVALID_SEARCH_HIGHLIGHT_POST_TAG: "invalid_search_highlight_post_tag",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_crop_marker */
  INVALID_SEARCH_CROP_MARKER: "invalid_search_crop_marker",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_matching_strategy */
  INVALID_SEARCH_MATCHING_STRATEGY: "invalid_search_matching_strategy",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_vector */
  INVALID_SEARCH_VECTOR: "invalid_search_vector",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_attributes_to_search_on */
  INVALID_SEARCH_ATTRIBUTES_TO_SEARCH_ON: "invalid_search_attributes_to_search_on",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#bad_request */
  BAD_REQUEST: "bad_request",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#document_not_found */
  DOCUMENT_NOT_FOUND: "document_not_found",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#internal */
  INTERNAL: "internal",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key */
  INVALID_API_KEY: "invalid_api_key",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_description */
  INVALID_API_KEY_DESCRIPTION: "invalid_api_key_description",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_actions */
  INVALID_API_KEY_ACTIONS: "invalid_api_key_actions",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_indexes */
  INVALID_API_KEY_INDEXES: "invalid_api_key_indexes",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_expires_at */
  INVALID_API_KEY_EXPIRES_AT: "invalid_api_key_expires_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#api_key_not_found */
  API_KEY_NOT_FOUND: "api_key_not_found",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_uid */
  IMMUTABLE_API_KEY_UID: "immutable_api_key_uid",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_actions */
  IMMUTABLE_API_KEY_ACTIONS: "immutable_api_key_actions",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_indexes */
  IMMUTABLE_API_KEY_INDEXES: "immutable_api_key_indexes",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_expires_at */
  IMMUTABLE_API_KEY_EXPIRES_AT: "immutable_api_key_expires_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_created_at */
  IMMUTABLE_API_KEY_CREATED_AT: "immutable_api_key_created_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_api_key_updated_at */
  IMMUTABLE_API_KEY_UPDATED_AT: "immutable_api_key_updated_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_authorization_header */
  MISSING_AUTHORIZATION_HEADER: "missing_authorization_header",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#unretrievable_document */
  UNRETRIEVABLE_DOCUMENT: "unretrievable_document",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#database_size_limit_reached */
  MAX_DATABASE_SIZE_LIMIT_REACHED: "database_size_limit_reached",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#task_not_found */
  TASK_NOT_FOUND: "task_not_found",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#dump_process_failed */
  DUMP_PROCESS_FAILED: "dump_process_failed",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#dump_not_found */
  DUMP_NOT_FOUND: "dump_not_found",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_swap_duplicate_index_found */
  INVALID_SWAP_DUPLICATE_INDEX_FOUND: "invalid_swap_duplicate_index_found",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_swap_indexes */
  INVALID_SWAP_INDEXES: "invalid_swap_indexes",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_swap_indexes */
  MISSING_SWAP_INDEXES: "missing_swap_indexes",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_master_key */
  MISSING_MASTER_KEY: "missing_master_key",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_types */
  INVALID_TASK_TYPES: "invalid_task_types",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_uids */
  INVALID_TASK_UIDS: "invalid_task_uids",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_statuses */
  INVALID_TASK_STATUSES: "invalid_task_statuses",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_limit */
  INVALID_TASK_LIMIT: "invalid_task_limit",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_from */
  INVALID_TASK_FROM: "invalid_task_from",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_canceled_by */
  INVALID_TASK_CANCELED_BY: "invalid_task_canceled_by",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_task_filters */
  MISSING_TASK_FILTERS: "missing_task_filters",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#too_many_open_files */
  TOO_MANY_OPEN_FILES: "too_many_open_files",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#io_error */
  IO_ERROR: "io_error",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_index_uids */
  INVALID_TASK_INDEX_UIDS: "invalid_task_index_uids",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_uid */
  IMMUTABLE_INDEX_UID: "immutable_index_uid",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_created_at */
  IMMUTABLE_INDEX_CREATED_AT: "immutable_index_created_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#immutable_index_updated_at */
  IMMUTABLE_INDEX_UPDATED_AT: "immutable_index_updated_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_displayed_attributes */
  INVALID_SETTINGS_DISPLAYED_ATTRIBUTES: "invalid_settings_displayed_attributes",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_searchable_attributes */
  INVALID_SETTINGS_SEARCHABLE_ATTRIBUTES: "invalid_settings_searchable_attributes",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_filterable_attributes */
  INVALID_SETTINGS_FILTERABLE_ATTRIBUTES: "invalid_settings_filterable_attributes",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_sortable_attributes */
  INVALID_SETTINGS_SORTABLE_ATTRIBUTES: "invalid_settings_sortable_attributes",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_ranking_rules */
  INVALID_SETTINGS_RANKING_RULES: "invalid_settings_ranking_rules",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_stop_words */
  INVALID_SETTINGS_STOP_WORDS: "invalid_settings_stop_words",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_synonyms */
  INVALID_SETTINGS_SYNONYMS: "invalid_settings_synonyms",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_distinct_attribute */
  INVALID_SETTINGS_DISTINCT_ATTRIBUTE: "invalid_settings_distinct_attribute",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_typo_tolerance */
  INVALID_SETTINGS_TYPO_TOLERANCE: "invalid_settings_typo_tolerance",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_faceting */
  INVALID_SETTINGS_FACETING: "invalid_settings_faceting",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_pagination */
  INVALID_SETTINGS_PAGINATION: "invalid_settings_pagination",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_settings_search_cutoff_ms */
  INVALID_SETTINGS_SEARCH_CUTOFF_MS: "invalid_settings_search_cutoff_ms",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_enqueued_at */
  INVALID_TASK_BEFORE_ENQUEUED_AT: "invalid_task_before_enqueued_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_enqueued_at */
  INVALID_TASK_AFTER_ENQUEUED_AT: "invalid_task_after_enqueued_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_started_at */
  INVALID_TASK_BEFORE_STARTED_AT: "invalid_task_before_started_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_started_at */
  INVALID_TASK_AFTER_STARTED_AT: "invalid_task_after_started_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_before_finished_at */
  INVALID_TASK_BEFORE_FINISHED_AT: "invalid_task_before_finished_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_task_after_finished_at */
  INVALID_TASK_AFTER_FINISHED_AT: "invalid_task_after_finished_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_actions */
  MISSING_API_KEY_ACTIONS: "missing_api_key_actions",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_indexes */
  MISSING_API_KEY_INDEXES: "missing_api_key_indexes",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_api_key_expires_at */
  MISSING_API_KEY_EXPIRES_AT: "missing_api_key_expires_at",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_limit */
  INVALID_API_KEY_LIMIT: "invalid_api_key_limit",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_api_key_offset */
  INVALID_API_KEY_OFFSET: "invalid_api_key_offset",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_facet_search_facet_name */
  INVALID_FACET_SEARCH_FACET_NAME: "invalid_facet_search_facet_name",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#missing_facet_search_facet_name */
  MISSING_FACET_SEARCH_FACET_NAME: "missing_facet_search_facet_name",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_facet_search_facet_query */
  INVALID_FACET_SEARCH_FACET_QUERY: "invalid_facet_search_facet_query",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_search_ranking_score_threshold */
  INVALID_SEARCH_RANKING_SCORE_THRESHOLD: "invalid_search_ranking_score_threshold",
  /** @see https://www.meilisearch.com/docs/reference/errors/error_codes#invalid_similar_ranking_score_threshold */
  INVALID_SIMILAR_RANKING_SCORE_THRESHOLD: "invalid_similar_ranking_score_threshold"
};
class MeiliSearchError extends Error {
  constructor(message2) {
    super(message2);
    Object.setPrototypeOf(this, MeiliSearchError.prototype);
    this.name = "MeiliSearchError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, MeiliSearchError);
    }
  }
}
class MeiliSearchCommunicationError extends MeiliSearchError {
  constructor(message2, body, url, stack) {
    var _a3, _b2, _c2;
    super(message2);
    __publicField(this, "statusCode");
    __publicField(this, "errno");
    __publicField(this, "code");
    __publicField(this, "stack");
    Object.setPrototypeOf(this, MeiliSearchCommunicationError.prototype);
    this.name = "MeiliSearchCommunicationError";
    if (body instanceof Response) {
      this.message = body.statusText;
      this.statusCode = body.status;
    }
    if (body instanceof Error) {
      this.errno = body.errno;
      this.code = body.code;
    }
    if (stack) {
      this.stack = stack;
      this.stack = (_a3 = this.stack) == null ? void 0 : _a3.replace(/(TypeError|FetchError)/, this.name);
      this.stack = (_b2 = this.stack) == null ? void 0 : _b2.replace("Failed to fetch", `request to ${url} failed, reason: connect ECONNREFUSED`);
      this.stack = (_c2 = this.stack) == null ? void 0 : _c2.replace("Not Found", `Not Found: ${url}`);
    } else {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, MeiliSearchCommunicationError);
      }
    }
  }
}
const MeiliSearchApiError = class extends MeiliSearchError {
  constructor(error, status) {
    super(error.message);
    __publicField(this, "httpStatus");
    __publicField(this, "code");
    __publicField(this, "link");
    __publicField(this, "type");
    __publicField(this, "stack");
    Object.setPrototypeOf(this, MeiliSearchApiError.prototype);
    this.name = "MeiliSearchApiError";
    this.code = error.code;
    this.type = error.type;
    this.link = error.link;
    this.message = error.message;
    this.httpStatus = status;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, MeiliSearchApiError);
    }
  }
};
async function httpResponseErrorHandler(response) {
  if (!response.ok) {
    let responseBody;
    try {
      responseBody = await response.json();
    } catch (e) {
      throw new MeiliSearchCommunicationError(response.statusText, response, response.url);
    }
    throw new MeiliSearchApiError(responseBody, response.status);
  }
  return response;
}
function httpErrorHandler(response, stack, url) {
  if (response.name !== "MeiliSearchApiError") {
    throw new MeiliSearchCommunicationError(response.message, response, url, stack);
  }
  throw response;
}
class MeiliSearchTimeOutError extends MeiliSearchError {
  constructor(message2) {
    super(message2);
    Object.setPrototypeOf(this, MeiliSearchTimeOutError.prototype);
    this.name = "MeiliSearchTimeOutError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, MeiliSearchTimeOutError);
    }
  }
}
function versionErrorHintMessage(message2, method) {
  return `${message2}
Hint: It might not be working because maybe you're not up to date with the Meilisearch version that ${method} call requires.`;
}
function removeUndefinedFromObject(obj) {
  return Object.entries(obj).reduce((acc, curEntry) => {
    const [key, val] = curEntry;
    if (val !== void 0)
      acc[key] = val;
    return acc;
  }, {});
}
async function sleep(ms2) {
  return await new Promise((resolve2) => setTimeout(resolve2, ms2));
}
function addProtocolIfNotPresent(host) {
  if (!(host.startsWith("https://") || host.startsWith("http://"))) {
    return `http://${host}`;
  }
  return host;
}
function addTrailingSlash(url) {
  if (!url.endsWith("/")) {
    url += "/";
  }
  return url;
}
function validateUuid4(uuid2) {
  const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
  return regexExp.test(uuid2);
}
const PACKAGE_VERSION = "0.41.0";
function toQueryParams(parameters) {
  const params = Object.keys(parameters);
  const queryParams = params.reduce((acc, key) => {
    const value = parameters[key];
    if (value === void 0) {
      return acc;
    } else if (Array.isArray(value)) {
      return { ...acc, [key]: value.join(",") };
    } else if (value instanceof Date) {
      return { ...acc, [key]: value.toISOString() };
    }
    return { ...acc, [key]: value };
  }, {});
  return queryParams;
}
function constructHostURL(host) {
  try {
    host = addProtocolIfNotPresent(host);
    host = addTrailingSlash(host);
    return host;
  } catch (e) {
    throw new MeiliSearchError("The provided host is not valid.");
  }
}
function cloneAndParseHeaders(headers) {
  if (Array.isArray(headers)) {
    return headers.reduce((acc, headerPair) => {
      acc[headerPair[0]] = headerPair[1];
      return acc;
    }, {});
  } else if ("has" in headers) {
    const clonedHeaders = {};
    headers.forEach((value, key) => clonedHeaders[key] = value);
    return clonedHeaders;
  } else {
    return Object.assign({}, headers);
  }
}
function createHeaders(config2) {
  var _a3;
  const agentHeader = "X-Meilisearch-Client";
  const packageAgent = `Meilisearch JavaScript (v${PACKAGE_VERSION})`;
  const contentType = "Content-Type";
  const authorization = "Authorization";
  const headers = cloneAndParseHeaders(((_a3 = config2.requestConfig) == null ? void 0 : _a3.headers) ?? {});
  if (config2.apiKey && !headers[authorization]) {
    headers[authorization] = `Bearer ${config2.apiKey}`;
  }
  if (!headers[contentType]) {
    headers["Content-Type"] = "application/json";
  }
  if (config2.clientAgents && Array.isArray(config2.clientAgents)) {
    const clients = config2.clientAgents.concat(packageAgent);
    headers[agentHeader] = clients.join(" ; ");
  } else if (config2.clientAgents && !Array.isArray(config2.clientAgents)) {
    throw new MeiliSearchError(`Meilisearch: The header "${agentHeader}" should be an array of string(s).
`);
  } else {
    headers[agentHeader] = packageAgent;
  }
  return headers;
}
class HttpRequests {
  constructor(config2) {
    __publicField(this, "headers");
    __publicField(this, "url");
    __publicField(this, "requestConfig");
    __publicField(this, "httpClient");
    __publicField(this, "requestTimeout");
    this.headers = createHeaders(config2);
    this.requestConfig = config2.requestConfig;
    this.httpClient = config2.httpClient;
    this.requestTimeout = config2.timeout;
    try {
      const host = constructHostURL(config2.host);
      this.url = new URL(host);
    } catch (e) {
      throw new MeiliSearchError("The provided host is not valid.");
    }
  }
  async request({ method, url, params, body, config: config2 = {} }) {
    var _a3;
    if (typeof fetch === "undefined") {
      requireBrowserPolyfill();
    }
    const constructURL = new URL(url, this.url);
    if (params) {
      const queryParams = new URLSearchParams();
      Object.keys(params).filter((x2) => params[x2] !== null).map((x2) => queryParams.set(x2, params[x2]));
      constructURL.search = queryParams.toString();
    }
    if (!((_a3 = config2.headers) == null ? void 0 : _a3["Content-Type"])) {
      body = JSON.stringify(body);
    }
    const headers = { ...this.headers, ...config2.headers };
    try {
      const result = this.fetchWithTimeout(constructURL.toString(), {
        ...config2,
        ...this.requestConfig,
        method,
        body,
        headers
      }, this.requestTimeout);
      if (this.httpClient) {
        return await result;
      }
      const response = await result.then((res) => httpResponseErrorHandler(res));
      const parsedBody = await response.json().catch(() => void 0);
      return parsedBody;
    } catch (e) {
      const stack = e.stack;
      httpErrorHandler(e, stack, constructURL.toString());
    }
  }
  async fetchWithTimeout(url, options2, timeout) {
    return new Promise((resolve2, reject) => {
      const fetchFn = this.httpClient ? this.httpClient : fetch;
      const fetchPromise = fetchFn(url, options2);
      const promises = [fetchPromise];
      let timeoutId;
      if (timeout) {
        const timeoutPromise = new Promise((_, reject2) => {
          timeoutId = setTimeout(() => {
            reject2(new Error("Error: Request Timed Out"));
          }, timeout);
        });
        promises.push(timeoutPromise);
      }
      Promise.race(promises).then(resolve2).catch(reject).finally(() => {
        clearTimeout(timeoutId);
      });
    });
  }
  async get(url, params, config2) {
    return await this.request({
      method: "GET",
      url,
      params,
      config: config2
    });
  }
  async post(url, data, params, config2) {
    return await this.request({
      method: "POST",
      url,
      body: data,
      params,
      config: config2
    });
  }
  async put(url, data, params, config2) {
    return await this.request({
      method: "PUT",
      url,
      body: data,
      params,
      config: config2
    });
  }
  async patch(url, data, params, config2) {
    return await this.request({
      method: "PATCH",
      url,
      body: data,
      params,
      config: config2
    });
  }
  async delete(url, data, params, config2) {
    return await this.request({
      method: "DELETE",
      url,
      body: data,
      params,
      config: config2
    });
  }
}
class EnqueuedTask {
  constructor(task) {
    __publicField(this, "taskUid");
    __publicField(this, "indexUid");
    __publicField(this, "status");
    __publicField(this, "type");
    __publicField(this, "enqueuedAt");
    this.taskUid = task.taskUid;
    this.indexUid = task.indexUid;
    this.status = task.status;
    this.type = task.type;
    this.enqueuedAt = new Date(task.enqueuedAt);
  }
}
class Task {
  constructor(task) {
    __publicField(this, "indexUid");
    __publicField(this, "status");
    __publicField(this, "type");
    __publicField(this, "uid");
    __publicField(this, "canceledBy");
    __publicField(this, "details");
    __publicField(this, "error");
    __publicField(this, "duration");
    __publicField(this, "startedAt");
    __publicField(this, "enqueuedAt");
    __publicField(this, "finishedAt");
    this.indexUid = task.indexUid;
    this.status = task.status;
    this.type = task.type;
    this.uid = task.uid;
    this.details = task.details;
    this.canceledBy = task.canceledBy;
    this.error = task.error;
    this.duration = task.duration;
    this.startedAt = new Date(task.startedAt);
    this.enqueuedAt = new Date(task.enqueuedAt);
    this.finishedAt = new Date(task.finishedAt);
  }
}
class TaskClient {
  constructor(config2) {
    __publicField(this, "httpRequest");
    this.httpRequest = new HttpRequests(config2);
  }
  /**
   * Get one task
   *
   * @param uid - Unique identifier of the task
   * @returns
   */
  async getTask(uid) {
    const url = `tasks/${uid}`;
    const taskItem = await this.httpRequest.get(url);
    return new Task(taskItem);
  }
  /**
   * Get tasks
   *
   * @param parameters - Parameters to browse the tasks
   * @returns Promise containing all tasks
   */
  async getTasks(parameters = {}) {
    const url = `tasks`;
    const tasks = await this.httpRequest.get(url, toQueryParams(parameters));
    return {
      ...tasks,
      results: tasks.results.map((task) => new Task(task))
    };
  }
  /**
   * Wait for a task to be processed.
   *
   * @param taskUid - Task identifier
   * @param options - Additional configuration options
   * @returns Promise returning a task after it has been processed
   */
  async waitForTask(taskUid, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    const startingTime = Date.now();
    while (Date.now() - startingTime < timeOutMs) {
      const response = await this.getTask(taskUid);
      if (![
        TaskStatus.TASK_ENQUEUED,
        TaskStatus.TASK_PROCESSING
      ].includes(response.status))
        return response;
      await sleep(intervalMs);
    }
    throw new MeiliSearchTimeOutError(`timeout of ${timeOutMs}ms has exceeded on process ${taskUid} when waiting a task to be resolved.`);
  }
  /**
   * Waits for multiple tasks to be processed
   *
   * @param taskUids - Tasks identifier list
   * @param options - Wait options
   * @returns Promise returning a list of tasks after they have been processed
   */
  async waitForTasks(taskUids, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    const tasks = [];
    for (const taskUid of taskUids) {
      const task = await this.waitForTask(taskUid, {
        timeOutMs,
        intervalMs
      });
      tasks.push(task);
    }
    return tasks;
  }
  /**
   * Cancel a list of enqueued or processing tasks.
   *
   * @param parameters - Parameters to filter the tasks.
   * @returns Promise containing an EnqueuedTask
   */
  async cancelTasks(parameters = {}) {
    const url = `tasks/cancel`;
    const task = await this.httpRequest.post(url, {}, toQueryParams(parameters));
    return new EnqueuedTask(task);
  }
  /**
   * Delete a list tasks.
   *
   * @param parameters - Parameters to filter the tasks.
   * @returns Promise containing an EnqueuedTask
   */
  async deleteTasks(parameters = {}) {
    const url = `tasks`;
    const task = await this.httpRequest.delete(url, {}, toQueryParams(parameters));
    return new EnqueuedTask(task);
  }
}
class Index {
  /**
   * @param config - Request configuration options
   * @param uid - UID of the index
   * @param primaryKey - Primary Key of the index
   */
  constructor(config2, uid, primaryKey) {
    __publicField(this, "uid");
    __publicField(this, "primaryKey");
    __publicField(this, "createdAt");
    __publicField(this, "updatedAt");
    __publicField(this, "httpRequest");
    __publicField(this, "tasks");
    this.uid = uid;
    this.primaryKey = primaryKey;
    this.httpRequest = new HttpRequests(config2);
    this.tasks = new TaskClient(config2);
  }
  ///
  /// SEARCH
  ///
  /**
   * Search for documents into an index
   *
   * @param query - Query string
   * @param options - Search options
   * @param config - Additional request configuration options
   * @returns Promise containing the search response
   */
  async search(query, options2, config2) {
    const url = `indexes/${this.uid}/search`;
    return await this.httpRequest.post(url, removeUndefinedFromObject({ q: query, ...options2 }), void 0, config2);
  }
  /**
   * Search for documents into an index using the GET method
   *
   * @param query - Query string
   * @param options - Search options
   * @param config - Additional request configuration options
   * @returns Promise containing the search response
   */
  async searchGet(query, options2, config2) {
    var _a3, _b2, _c2, _d2, _e2, _f2, _g2;
    const url = `indexes/${this.uid}/search`;
    const parseFilter = (filter2) => {
      if (typeof filter2 === "string")
        return filter2;
      else if (Array.isArray(filter2))
        throw new MeiliSearchError("The filter query parameter should be in string format when using searchGet");
      else
        return void 0;
    };
    const getParams = {
      q: query,
      ...options2,
      filter: parseFilter(options2 == null ? void 0 : options2.filter),
      sort: (_a3 = options2 == null ? void 0 : options2.sort) == null ? void 0 : _a3.join(","),
      facets: (_b2 = options2 == null ? void 0 : options2.facets) == null ? void 0 : _b2.join(","),
      attributesToRetrieve: (_c2 = options2 == null ? void 0 : options2.attributesToRetrieve) == null ? void 0 : _c2.join(","),
      attributesToCrop: (_d2 = options2 == null ? void 0 : options2.attributesToCrop) == null ? void 0 : _d2.join(","),
      attributesToHighlight: (_e2 = options2 == null ? void 0 : options2.attributesToHighlight) == null ? void 0 : _e2.join(","),
      vector: (_f2 = options2 == null ? void 0 : options2.vector) == null ? void 0 : _f2.join(","),
      attributesToSearchOn: (_g2 = options2 == null ? void 0 : options2.attributesToSearchOn) == null ? void 0 : _g2.join(",")
    };
    return await this.httpRequest.get(url, removeUndefinedFromObject(getParams), config2);
  }
  /**
   * Search for facet values
   *
   * @param params - Parameters used to search on the facets
   * @param config - Additional request configuration options
   * @returns Promise containing the search response
   */
  async searchForFacetValues(params, config2) {
    const url = `indexes/${this.uid}/facet-search`;
    return await this.httpRequest.post(url, removeUndefinedFromObject(params), void 0, config2);
  }
  /**
   * Search for similar documents
   *
   * @param params - Parameters used to search for similar documents
   * @returns Promise containing the search response
   */
  async searchSimilarDocuments(params) {
    const url = `indexes/${this.uid}/similar`;
    return await this.httpRequest.post(url, removeUndefinedFromObject(params), void 0);
  }
  ///
  /// INDEX
  ///
  /**
   * Get index information.
   *
   * @returns Promise containing index information
   */
  async getRawInfo() {
    const url = `indexes/${this.uid}`;
    const res = await this.httpRequest.get(url);
    this.primaryKey = res.primaryKey;
    this.updatedAt = new Date(res.updatedAt);
    this.createdAt = new Date(res.createdAt);
    return res;
  }
  /**
   * Fetch and update Index information.
   *
   * @returns Promise to the current Index object with updated information
   */
  async fetchInfo() {
    await this.getRawInfo();
    return this;
  }
  /**
   * Get Primary Key.
   *
   * @returns Promise containing the Primary Key of the index
   */
  async fetchPrimaryKey() {
    this.primaryKey = (await this.getRawInfo()).primaryKey;
    return this.primaryKey;
  }
  /**
   * Create an index.
   *
   * @param uid - Unique identifier of the Index
   * @param options - Index options
   * @param config - Request configuration options
   * @returns Newly created Index object
   */
  static async create(uid, options2 = {}, config2) {
    const url = `indexes`;
    const req = new HttpRequests(config2);
    const task = await req.post(url, { ...options2, uid });
    return new EnqueuedTask(task);
  }
  /**
   * Update an index.
   *
   * @param data - Data to update
   * @returns Promise to the current Index object with updated information
   */
  async update(data) {
    const url = `indexes/${this.uid}`;
    const task = await this.httpRequest.patch(url, data);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  /**
   * Delete an index.
   *
   * @returns Promise which resolves when index is deleted successfully
   */
  async delete() {
    const url = `indexes/${this.uid}`;
    const task = await this.httpRequest.delete(url);
    return new EnqueuedTask(task);
  }
  ///
  /// TASKS
  ///
  /**
   * Get the list of all the tasks of the index.
   *
   * @param parameters - Parameters to browse the tasks
   * @returns Promise containing all tasks
   */
  async getTasks(parameters = {}) {
    return await this.tasks.getTasks({ ...parameters, indexUids: [this.uid] });
  }
  /**
   * Get one task of the index.
   *
   * @param taskUid - Task identifier
   * @returns Promise containing a task
   */
  async getTask(taskUid) {
    return await this.tasks.getTask(taskUid);
  }
  /**
   * Wait for multiple tasks to be processed.
   *
   * @param taskUids - Tasks identifier
   * @param waitOptions - Options on timeout and interval
   * @returns Promise containing an array of tasks
   */
  async waitForTasks(taskUids, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    return await this.tasks.waitForTasks(taskUids, {
      timeOutMs,
      intervalMs
    });
  }
  /**
   * Wait for a task to be processed.
   *
   * @param taskUid - Task identifier
   * @param waitOptions - Options on timeout and interval
   * @returns Promise containing an array of tasks
   */
  async waitForTask(taskUid, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    return await this.tasks.waitForTask(taskUid, {
      timeOutMs,
      intervalMs
    });
  }
  ///
  /// STATS
  ///
  /**
   * Get stats of an index
   *
   * @returns Promise containing object with stats of the index
   */
  async getStats() {
    const url = `indexes/${this.uid}/stats`;
    return await this.httpRequest.get(url);
  }
  ///
  /// DOCUMENTS
  ///
  /**
   * Get documents of an index.
   *
   * @param parameters - Parameters to browse the documents. Parameters can
   *   contain the `filter` field only available in Meilisearch v1.2 and newer
   * @returns Promise containing the returned documents
   */
  async getDocuments(parameters = {}) {
    var _a3;
    parameters = removeUndefinedFromObject(parameters);
    if (parameters.filter !== void 0) {
      try {
        const url = `indexes/${this.uid}/documents/fetch`;
        return await this.httpRequest.post(url, parameters);
      } catch (e) {
        if (e instanceof MeiliSearchCommunicationError) {
          e.message = versionErrorHintMessage(e.message, "getDocuments");
        } else if (e instanceof MeiliSearchApiError) {
          e.message = versionErrorHintMessage(e.message, "getDocuments");
        }
        throw e;
      }
    } else {
      const url = `indexes/${this.uid}/documents`;
      const fields = Array.isArray(parameters == null ? void 0 : parameters.fields) ? { fields: (_a3 = parameters == null ? void 0 : parameters.fields) == null ? void 0 : _a3.join(",") } : {};
      return await this.httpRequest.get(url, {
        ...parameters,
        ...fields
      });
    }
  }
  /**
   * Get one document
   *
   * @param documentId - Document ID
   * @param parameters - Parameters applied on a document
   * @returns Promise containing Document response
   */
  async getDocument(documentId, parameters) {
    const url = `indexes/${this.uid}/documents/${documentId}`;
    const fields = (() => {
      var _a3;
      if (Array.isArray(parameters == null ? void 0 : parameters.fields)) {
        return (_a3 = parameters == null ? void 0 : parameters.fields) == null ? void 0 : _a3.join(",");
      }
      return void 0;
    })();
    return await this.httpRequest.get(url, removeUndefinedFromObject({
      ...parameters,
      fields
    }));
  }
  /**
   * Add or replace multiples documents to an index
   *
   * @param documents - Array of Document objects to add/replace
   * @param options - Options on document addition
   * @returns Promise containing an EnqueuedTask
   */
  async addDocuments(documents, options2) {
    const url = `indexes/${this.uid}/documents`;
    const task = await this.httpRequest.post(url, documents, options2);
    return new EnqueuedTask(task);
  }
  /**
   * Add or replace multiples documents in a string format to an index. It only
   * supports csv, ndjson and json formats.
   *
   * @param documents - Documents provided in a string to add/replace
   * @param contentType - Content type of your document:
   *   'text/csv'|'application/x-ndjson'|'application/json'
   * @param options - Options on document addition
   * @returns Promise containing an EnqueuedTask
   */
  async addDocumentsFromString(documents, contentType, queryParams) {
    const url = `indexes/${this.uid}/documents`;
    const task = await this.httpRequest.post(url, documents, queryParams, {
      headers: {
        "Content-Type": contentType
      }
    });
    return new EnqueuedTask(task);
  }
  /**
   * Add or replace multiples documents to an index in batches
   *
   * @param documents - Array of Document objects to add/replace
   * @param batchSize - Size of the batch
   * @param options - Options on document addition
   * @returns Promise containing array of enqueued task objects for each batch
   */
  async addDocumentsInBatches(documents, batchSize = 1e3, options2) {
    const updates = [];
    for (let i = 0; i < documents.length; i += batchSize) {
      updates.push(await this.addDocuments(documents.slice(i, i + batchSize), options2));
    }
    return updates;
  }
  /**
   * Add or update multiples documents to an index
   *
   * @param documents - Array of Document objects to add/update
   * @param options - Options on document update
   * @returns Promise containing an EnqueuedTask
   */
  async updateDocuments(documents, options2) {
    const url = `indexes/${this.uid}/documents`;
    const task = await this.httpRequest.put(url, documents, options2);
    return new EnqueuedTask(task);
  }
  /**
   * Add or update multiples documents to an index in batches
   *
   * @param documents - Array of Document objects to add/update
   * @param batchSize - Size of the batch
   * @param options - Options on document update
   * @returns Promise containing array of enqueued task objects for each batch
   */
  async updateDocumentsInBatches(documents, batchSize = 1e3, options2) {
    const updates = [];
    for (let i = 0; i < documents.length; i += batchSize) {
      updates.push(await this.updateDocuments(documents.slice(i, i + batchSize), options2));
    }
    return updates;
  }
  /**
   * Add or update multiples documents in a string format to an index. It only
   * supports csv, ndjson and json formats.
   *
   * @param documents - Documents provided in a string to add/update
   * @param contentType - Content type of your document:
   *   'text/csv'|'application/x-ndjson'|'application/json'
   * @param queryParams - Options on raw document addition
   * @returns Promise containing an EnqueuedTask
   */
  async updateDocumentsFromString(documents, contentType, queryParams) {
    const url = `indexes/${this.uid}/documents`;
    const task = await this.httpRequest.put(url, documents, queryParams, {
      headers: {
        "Content-Type": contentType
      }
    });
    return new EnqueuedTask(task);
  }
  /**
   * Delete one document
   *
   * @param documentId - Id of Document to delete
   * @returns Promise containing an EnqueuedTask
   */
  async deleteDocument(documentId) {
    const url = `indexes/${this.uid}/documents/${documentId}`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  /**
   * Delete multiples documents of an index.
   *
   * @param params - Params value can be:
   *
   *   - DocumentsDeletionQuery: An object containing the parameters to customize
   *       your document deletion. Only available in Meilisearch v1.2 and newer
   *   - DocumentsIds: An array of document ids to delete
   *
   * @returns Promise containing an EnqueuedTask
   */
  async deleteDocuments(params) {
    const isDocumentsDeletionQuery = !Array.isArray(params) && typeof params === "object";
    const endpoint = isDocumentsDeletionQuery ? "documents/delete" : "documents/delete-batch";
    const url = `indexes/${this.uid}/${endpoint}`;
    try {
      const task = await this.httpRequest.post(url, params);
      return new EnqueuedTask(task);
    } catch (e) {
      if (e instanceof MeiliSearchCommunicationError && isDocumentsDeletionQuery) {
        e.message = versionErrorHintMessage(e.message, "deleteDocuments");
      } else if (e instanceof MeiliSearchApiError) {
        e.message = versionErrorHintMessage(e.message, "deleteDocuments");
      }
      throw e;
    }
  }
  /**
   * Delete all documents of an index
   *
   * @returns Promise containing an EnqueuedTask
   */
  async deleteAllDocuments() {
    const url = `indexes/${this.uid}/documents`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// SETTINGS
  ///
  /**
   * Retrieve all settings
   *
   * @returns Promise containing Settings object
   */
  async getSettings() {
    const url = `indexes/${this.uid}/settings`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update all settings Any parameters not provided will be left unchanged.
   *
   * @param settings - Object containing parameters with their updated values
   * @returns Promise containing an EnqueuedTask
   */
  async updateSettings(settings) {
    const url = `indexes/${this.uid}/settings`;
    const task = await this.httpRequest.patch(url, settings);
    task.enqueued = new Date(task.enqueuedAt);
    return task;
  }
  /**
   * Reset settings.
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetSettings() {
    const url = `indexes/${this.uid}/settings`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// PAGINATION SETTINGS
  ///
  /**
   * Get the pagination settings.
   *
   * @returns Promise containing object of pagination settings
   */
  async getPagination() {
    const url = `indexes/${this.uid}/settings/pagination`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the pagination settings.
   *
   * @param pagination - Pagination object
   * @returns Promise containing an EnqueuedTask
   */
  async updatePagination(pagination) {
    const url = `indexes/${this.uid}/settings/pagination`;
    const task = await this.httpRequest.patch(url, pagination);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the pagination settings.
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetPagination() {
    const url = `indexes/${this.uid}/settings/pagination`;
    const task = await this.httpRequest.delete(url);
    return new EnqueuedTask(task);
  }
  ///
  /// SYNONYMS
  ///
  /**
   * Get the list of all synonyms
   *
   * @returns Promise containing object of synonym mappings
   */
  async getSynonyms() {
    const url = `indexes/${this.uid}/settings/synonyms`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the list of synonyms. Overwrite the old list.
   *
   * @param synonyms - Mapping of synonyms with their associated words
   * @returns Promise containing an EnqueuedTask
   */
  async updateSynonyms(synonyms) {
    const url = `indexes/${this.uid}/settings/synonyms`;
    const task = await this.httpRequest.put(url, synonyms);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the synonym list to be empty again
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetSynonyms() {
    const url = `indexes/${this.uid}/settings/synonyms`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// STOP WORDS
  ///
  /**
   * Get the list of all stop-words
   *
   * @returns Promise containing array of stop-words
   */
  async getStopWords() {
    const url = `indexes/${this.uid}/settings/stop-words`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the list of stop-words. Overwrite the old list.
   *
   * @param stopWords - Array of strings that contains the stop-words.
   * @returns Promise containing an EnqueuedTask
   */
  async updateStopWords(stopWords) {
    const url = `indexes/${this.uid}/settings/stop-words`;
    const task = await this.httpRequest.put(url, stopWords);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the stop-words list to be empty again
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetStopWords() {
    const url = `indexes/${this.uid}/settings/stop-words`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// RANKING RULES
  ///
  /**
   * Get the list of all ranking-rules
   *
   * @returns Promise containing array of ranking-rules
   */
  async getRankingRules() {
    const url = `indexes/${this.uid}/settings/ranking-rules`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the list of ranking-rules. Overwrite the old list.
   *
   * @param rankingRules - Array that contain ranking rules sorted by order of
   *   importance.
   * @returns Promise containing an EnqueuedTask
   */
  async updateRankingRules(rankingRules) {
    const url = `indexes/${this.uid}/settings/ranking-rules`;
    const task = await this.httpRequest.put(url, rankingRules);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the ranking rules list to its default value
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetRankingRules() {
    const url = `indexes/${this.uid}/settings/ranking-rules`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// DISTINCT ATTRIBUTE
  ///
  /**
   * Get the distinct-attribute
   *
   * @returns Promise containing the distinct-attribute of the index
   */
  async getDistinctAttribute() {
    const url = `indexes/${this.uid}/settings/distinct-attribute`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the distinct-attribute.
   *
   * @param distinctAttribute - Field name of the distinct-attribute
   * @returns Promise containing an EnqueuedTask
   */
  async updateDistinctAttribute(distinctAttribute) {
    const url = `indexes/${this.uid}/settings/distinct-attribute`;
    const task = await this.httpRequest.put(url, distinctAttribute);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the distinct-attribute.
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetDistinctAttribute() {
    const url = `indexes/${this.uid}/settings/distinct-attribute`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// FILTERABLE ATTRIBUTES
  ///
  /**
   * Get the filterable-attributes
   *
   * @returns Promise containing an array of filterable-attributes
   */
  async getFilterableAttributes() {
    const url = `indexes/${this.uid}/settings/filterable-attributes`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the filterable-attributes.
   *
   * @param filterableAttributes - Array of strings containing the attributes
   *   that can be used as filters at query time
   * @returns Promise containing an EnqueuedTask
   */
  async updateFilterableAttributes(filterableAttributes) {
    const url = `indexes/${this.uid}/settings/filterable-attributes`;
    const task = await this.httpRequest.put(url, filterableAttributes);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the filterable-attributes.
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetFilterableAttributes() {
    const url = `indexes/${this.uid}/settings/filterable-attributes`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// SORTABLE ATTRIBUTES
  ///
  /**
   * Get the sortable-attributes
   *
   * @returns Promise containing array of sortable-attributes
   */
  async getSortableAttributes() {
    const url = `indexes/${this.uid}/settings/sortable-attributes`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the sortable-attributes.
   *
   * @param sortableAttributes - Array of strings containing the attributes that
   *   can be used to sort search results at query time
   * @returns Promise containing an EnqueuedTask
   */
  async updateSortableAttributes(sortableAttributes) {
    const url = `indexes/${this.uid}/settings/sortable-attributes`;
    const task = await this.httpRequest.put(url, sortableAttributes);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the sortable-attributes.
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetSortableAttributes() {
    const url = `indexes/${this.uid}/settings/sortable-attributes`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// SEARCHABLE ATTRIBUTE
  ///
  /**
   * Get the searchable-attributes
   *
   * @returns Promise containing array of searchable-attributes
   */
  async getSearchableAttributes() {
    const url = `indexes/${this.uid}/settings/searchable-attributes`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the searchable-attributes.
   *
   * @param searchableAttributes - Array of strings that contains searchable
   *   attributes sorted by order of importance(most to least important)
   * @returns Promise containing an EnqueuedTask
   */
  async updateSearchableAttributes(searchableAttributes) {
    const url = `indexes/${this.uid}/settings/searchable-attributes`;
    const task = await this.httpRequest.put(url, searchableAttributes);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the searchable-attributes.
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetSearchableAttributes() {
    const url = `indexes/${this.uid}/settings/searchable-attributes`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// DISPLAYED ATTRIBUTE
  ///
  /**
   * Get the displayed-attributes
   *
   * @returns Promise containing array of displayed-attributes
   */
  async getDisplayedAttributes() {
    const url = `indexes/${this.uid}/settings/displayed-attributes`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the displayed-attributes.
   *
   * @param displayedAttributes - Array of strings that contains attributes of
   *   an index to display
   * @returns Promise containing an EnqueuedTask
   */
  async updateDisplayedAttributes(displayedAttributes) {
    const url = `indexes/${this.uid}/settings/displayed-attributes`;
    const task = await this.httpRequest.put(url, displayedAttributes);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the displayed-attributes.
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetDisplayedAttributes() {
    const url = `indexes/${this.uid}/settings/displayed-attributes`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// TYPO TOLERANCE
  ///
  /**
   * Get the typo tolerance settings.
   *
   * @returns Promise containing the typo tolerance settings.
   */
  async getTypoTolerance() {
    const url = `indexes/${this.uid}/settings/typo-tolerance`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the typo tolerance settings.
   *
   * @param typoTolerance - Object containing the custom typo tolerance
   *   settings.
   * @returns Promise containing object of the enqueued update
   */
  async updateTypoTolerance(typoTolerance) {
    const url = `indexes/${this.uid}/settings/typo-tolerance`;
    const task = await this.httpRequest.patch(url, typoTolerance);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  /**
   * Reset the typo tolerance settings.
   *
   * @returns Promise containing object of the enqueued update
   */
  async resetTypoTolerance() {
    const url = `indexes/${this.uid}/settings/typo-tolerance`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// FACETING
  ///
  /**
   * Get the faceting settings.
   *
   * @returns Promise containing object of faceting index settings
   */
  async getFaceting() {
    const url = `indexes/${this.uid}/settings/faceting`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the faceting settings.
   *
   * @param faceting - Faceting index settings object
   * @returns Promise containing an EnqueuedTask
   */
  async updateFaceting(faceting) {
    const url = `indexes/${this.uid}/settings/faceting`;
    const task = await this.httpRequest.patch(url, faceting);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the faceting settings.
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetFaceting() {
    const url = `indexes/${this.uid}/settings/faceting`;
    const task = await this.httpRequest.delete(url);
    return new EnqueuedTask(task);
  }
  ///
  /// SEPARATOR TOKENS
  ///
  /**
   * Get the list of all separator tokens.
   *
   * @returns Promise containing array of separator tokens
   */
  async getSeparatorTokens() {
    const url = `indexes/${this.uid}/settings/separator-tokens`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the list of separator tokens. Overwrite the old list.
   *
   * @param separatorTokens - Array that contains separator tokens.
   * @returns Promise containing an EnqueuedTask or null
   */
  async updateSeparatorTokens(separatorTokens) {
    const url = `indexes/${this.uid}/settings/separator-tokens`;
    const task = await this.httpRequest.put(url, separatorTokens);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the separator tokens list to its default value
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetSeparatorTokens() {
    const url = `indexes/${this.uid}/settings/separator-tokens`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// NON-SEPARATOR TOKENS
  ///
  /**
   * Get the list of all non-separator tokens.
   *
   * @returns Promise containing array of non-separator tokens
   */
  async getNonSeparatorTokens() {
    const url = `indexes/${this.uid}/settings/non-separator-tokens`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the list of non-separator tokens. Overwrite the old list.
   *
   * @param nonSeparatorTokens - Array that contains non-separator tokens.
   * @returns Promise containing an EnqueuedTask or null
   */
  async updateNonSeparatorTokens(nonSeparatorTokens) {
    const url = `indexes/${this.uid}/settings/non-separator-tokens`;
    const task = await this.httpRequest.put(url, nonSeparatorTokens);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the non-separator tokens list to its default value
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetNonSeparatorTokens() {
    const url = `indexes/${this.uid}/settings/non-separator-tokens`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// DICTIONARY
  ///
  /**
   * Get the dictionary settings of a Meilisearch index.
   *
   * @returns Promise containing the dictionary settings
   */
  async getDictionary() {
    const url = `indexes/${this.uid}/settings/dictionary`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the dictionary settings. Overwrite the old settings.
   *
   * @param dictionary - Array that contains the new dictionary settings.
   * @returns Promise containing an EnqueuedTask or null
   */
  async updateDictionary(dictionary) {
    const url = `indexes/${this.uid}/settings/dictionary`;
    const task = await this.httpRequest.put(url, dictionary);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the dictionary settings to its default value
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetDictionary() {
    const url = `indexes/${this.uid}/settings/dictionary`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// PROXIMITY PRECISION
  ///
  /**
   * Get the proximity precision settings of a Meilisearch index.
   *
   * @returns Promise containing the proximity precision settings
   */
  async getProximityPrecision() {
    const url = `indexes/${this.uid}/settings/proximity-precision`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the proximity precision settings. Overwrite the old settings.
   *
   * @param proximityPrecision - String that contains the new proximity
   *   precision settings.
   * @returns Promise containing an EnqueuedTask or null
   */
  async updateProximityPrecision(proximityPrecision) {
    const url = `indexes/${this.uid}/settings/proximity-precision`;
    const task = await this.httpRequest.put(url, proximityPrecision);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the proximity precision settings to its default value
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetProximityPrecision() {
    const url = `indexes/${this.uid}/settings/proximity-precision`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// EMBEDDERS
  ///
  /**
   * Get the embedders settings of a Meilisearch index.
   *
   * @returns Promise containing the embedders settings
   */
  async getEmbedders() {
    const url = `indexes/${this.uid}/settings/embedders`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the embedders settings. Overwrite the old settings.
   *
   * @param embedders - Object that contains the new embedders settings.
   * @returns Promise containing an EnqueuedTask or null
   */
  async updateEmbedders(embedders) {
    const url = `indexes/${this.uid}/settings/embedders`;
    const task = await this.httpRequest.patch(url, embedders);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the embedders settings to its default value
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetEmbedders() {
    const url = `indexes/${this.uid}/settings/embedders`;
    const task = await this.httpRequest.delete(url);
    task.enqueuedAt = new Date(task.enqueuedAt);
    return task;
  }
  ///
  /// SEARCHCUTOFFMS SETTINGS
  ///
  /**
   * Get the SearchCutoffMs settings.
   *
   * @returns Promise containing object of SearchCutoffMs settings
   */
  async getSearchCutoffMs() {
    const url = `indexes/${this.uid}/settings/search-cutoff-ms`;
    return await this.httpRequest.get(url);
  }
  /**
   * Update the SearchCutoffMs settings.
   *
   * @param searchCutoffMs - Object containing SearchCutoffMsSettings
   * @returns Promise containing an EnqueuedTask
   */
  async updateSearchCutoffMs(searchCutoffMs) {
    const url = `indexes/${this.uid}/settings/search-cutoff-ms`;
    const task = await this.httpRequest.put(url, searchCutoffMs);
    return new EnqueuedTask(task);
  }
  /**
   * Reset the SearchCutoffMs settings.
   *
   * @returns Promise containing an EnqueuedTask
   */
  async resetSearchCutoffMs() {
    const url = `indexes/${this.uid}/settings/search-cutoff-ms`;
    const task = await this.httpRequest.delete(url);
    return new EnqueuedTask(task);
  }
}
class Client {
  /**
   * Creates new MeiliSearch instance
   *
   * @param config - Configuration object
   */
  constructor(config2) {
    __publicField(this, "config");
    __publicField(this, "httpRequest");
    __publicField(this, "tasks");
    this.config = config2;
    this.httpRequest = new HttpRequests(config2);
    this.tasks = new TaskClient(config2);
  }
  /**
   * Return an Index instance
   *
   * @param indexUid - The index UID
   * @returns Instance of Index
   */
  index(indexUid) {
    return new Index(this.config, indexUid);
  }
  /**
   * Gather information about an index by calling MeiliSearch and return an
   * Index instance with the gathered information
   *
   * @param indexUid - The index UID
   * @returns Promise returning Index instance
   */
  async getIndex(indexUid) {
    return new Index(this.config, indexUid).fetchInfo();
  }
  /**
   * Gather information about an index by calling MeiliSearch and return the raw
   * JSON response
   *
   * @param indexUid - The index UID
   * @returns Promise returning index information
   */
  async getRawIndex(indexUid) {
    return new Index(this.config, indexUid).getRawInfo();
  }
  /**
   * Get all the indexes as Index instances.
   *
   * @param parameters - Parameters to browse the indexes
   * @returns Promise returning array of raw index information
   */
  async getIndexes(parameters = {}) {
    const rawIndexes = await this.getRawIndexes(parameters);
    const indexes = rawIndexes.results.map((index2) => new Index(this.config, index2.uid, index2.primaryKey));
    return { ...rawIndexes, results: indexes };
  }
  /**
   * Get all the indexes in their raw value (no Index instances).
   *
   * @param parameters - Parameters to browse the indexes
   * @returns Promise returning array of raw index information
   */
  async getRawIndexes(parameters = {}) {
    const url = `indexes`;
    return await this.httpRequest.get(url, parameters);
  }
  /**
   * Create a new index
   *
   * @param uid - The index UID
   * @param options - Index options
   * @returns Promise returning Index instance
   */
  async createIndex(uid, options2 = {}) {
    return await Index.create(uid, options2, this.config);
  }
  /**
   * Update an index
   *
   * @param uid - The index UID
   * @param options - Index options to update
   * @returns Promise returning Index instance after updating
   */
  async updateIndex(uid, options2 = {}) {
    return await new Index(this.config, uid).update(options2);
  }
  /**
   * Delete an index
   *
   * @param uid - The index UID
   * @returns Promise which resolves when index is deleted successfully
   */
  async deleteIndex(uid) {
    return await new Index(this.config, uid).delete();
  }
  /**
   * Deletes an index if it already exists.
   *
   * @param uid - The index UID
   * @returns Promise which resolves to true when index exists and is deleted
   *   successfully, otherwise false if it does not exist
   */
  async deleteIndexIfExists(uid) {
    try {
      await this.deleteIndex(uid);
      return true;
    } catch (e) {
      if (e.code === ErrorStatusCode.INDEX_NOT_FOUND) {
        return false;
      }
      throw e;
    }
  }
  /**
   * Swaps a list of index tuples.
   *
   * @param params - List of indexes tuples to swap.
   * @returns Promise returning object of the enqueued task
   */
  async swapIndexes(params) {
    const url = "/swap-indexes";
    return await this.httpRequest.post(url, params);
  }
  ///
  /// Multi Search
  ///
  /**
   * Perform multiple search queries.
   *
   * It is possible to make multiple search queries on the same index or on
   * different ones
   *
   * @example
   *
   * ```ts
   * client.multiSearch({
   *   queries: [
   *     { indexUid: 'movies', q: 'wonder' },
   *     { indexUid: 'books', q: 'flower' },
   *   ],
   * });
   * ```
   *
   * @param queries - Search queries
   * @param config - Additional request configuration options
   * @returns Promise containing the search responses
   */
  async multiSearch(queries, config2) {
    const url = `multi-search`;
    return await this.httpRequest.post(url, queries, void 0, config2);
  }
  ///
  /// TASKS
  ///
  /**
   * Get the list of all client tasks
   *
   * @param parameters - Parameters to browse the tasks
   * @returns Promise returning all tasks
   */
  async getTasks(parameters = {}) {
    return await this.tasks.getTasks(parameters);
  }
  /**
   * Get one task on the client scope
   *
   * @param taskUid - Task identifier
   * @returns Promise returning a task
   */
  async getTask(taskUid) {
    return await this.tasks.getTask(taskUid);
  }
  /**
   * Wait for multiple tasks to be finished.
   *
   * @param taskUids - Tasks identifier
   * @param waitOptions - Options on timeout and interval
   * @returns Promise returning an array of tasks
   */
  async waitForTasks(taskUids, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    return await this.tasks.waitForTasks(taskUids, {
      timeOutMs,
      intervalMs
    });
  }
  /**
   * Wait for a task to be finished.
   *
   * @param taskUid - Task identifier
   * @param waitOptions - Options on timeout and interval
   * @returns Promise returning an array of tasks
   */
  async waitForTask(taskUid, { timeOutMs = 5e3, intervalMs = 50 } = {}) {
    return await this.tasks.waitForTask(taskUid, {
      timeOutMs,
      intervalMs
    });
  }
  /**
   * Cancel a list of enqueued or processing tasks.
   *
   * @param parameters - Parameters to filter the tasks.
   * @returns Promise containing an EnqueuedTask
   */
  async cancelTasks(parameters) {
    return await this.tasks.cancelTasks(parameters);
  }
  /**
   * Delete a list of tasks.
   *
   * @param parameters - Parameters to filter the tasks.
   * @returns Promise containing an EnqueuedTask
   */
  async deleteTasks(parameters = {}) {
    return await this.tasks.deleteTasks(parameters);
  }
  ///
  /// KEYS
  ///
  /**
   * Get all API keys
   *
   * @param parameters - Parameters to browse the indexes
   * @returns Promise returning an object with keys
   */
  async getKeys(parameters = {}) {
    const url = `keys`;
    const keys = await this.httpRequest.get(url, parameters);
    keys.results = keys.results.map((key) => ({
      ...key,
      createdAt: new Date(key.createdAt),
      updatedAt: new Date(key.updatedAt)
    }));
    return keys;
  }
  /**
   * Get one API key
   *
   * @param keyOrUid - Key or uid of the API key
   * @returns Promise returning a key
   */
  async getKey(keyOrUid) {
    const url = `keys/${keyOrUid}`;
    return await this.httpRequest.get(url);
  }
  /**
   * Create one API key
   *
   * @param options - Key options
   * @returns Promise returning a key
   */
  async createKey(options2) {
    const url = `keys`;
    return await this.httpRequest.post(url, options2);
  }
  /**
   * Update one API key
   *
   * @param keyOrUid - Key
   * @param options - Key options
   * @returns Promise returning a key
   */
  async updateKey(keyOrUid, options2) {
    const url = `keys/${keyOrUid}`;
    return await this.httpRequest.patch(url, options2);
  }
  /**
   * Delete one API key
   *
   * @param keyOrUid - Key
   * @returns
   */
  async deleteKey(keyOrUid) {
    const url = `keys/${keyOrUid}`;
    return await this.httpRequest.delete(url);
  }
  ///
  /// HEALTH
  ///
  /**
   * Checks if the server is healthy, otherwise an error will be thrown.
   *
   * @returns Promise returning an object with health details
   */
  async health() {
    const url = `health`;
    return await this.httpRequest.get(url);
  }
  /**
   * Checks if the server is healthy, return true or false.
   *
   * @returns Promise returning a boolean
   */
  async isHealthy() {
    try {
      const url = `health`;
      await this.httpRequest.get(url);
      return true;
    } catch (e) {
      return false;
    }
  }
  ///
  /// STATS
  ///
  /**
   * Get the stats of all the database
   *
   * @returns Promise returning object of all the stats
   */
  async getStats() {
    const url = `stats`;
    return await this.httpRequest.get(url);
  }
  ///
  /// VERSION
  ///
  /**
   * Get the version of MeiliSearch
   *
   * @returns Promise returning object with version details
   */
  async getVersion() {
    const url = `version`;
    return await this.httpRequest.get(url);
  }
  ///
  /// DUMPS
  ///
  /**
   * Creates a dump
   *
   * @returns Promise returning object of the enqueued task
   */
  async createDump() {
    const url = `dumps`;
    const task = await this.httpRequest.post(url);
    return new EnqueuedTask(task);
  }
  ///
  /// SNAPSHOTS
  ///
  /**
   * Creates a snapshot
   *
   * @returns Promise returning object of the enqueued task
   */
  async createSnapshot() {
    const url = `snapshots`;
    const task = await this.httpRequest.post(url);
    return new EnqueuedTask(task);
  }
  ///
  /// TOKENS
  ///
  /**
   * Generate a tenant token
   *
   * @param apiKeyUid - The uid of the api key used as issuer of the token.
   * @param searchRules - Search rules that are applied to every search.
   * @param options - Token options to customize some aspect of the token.
   * @returns The token in JWT format.
   */
  generateTenantToken(_apiKeyUid, _searchRules, _options) {
    const error = new Error();
    error.message = `Meilisearch: failed to generate a tenant token. Generation of a token only works in a node environment 
 ${error.stack}.`;
    return Promise.reject(error);
  }
}
function encode64(data) {
  return Buffer2.from(JSON.stringify(data)).toString("base64");
}
async function sign(apiKey, encodedHeader, encodedPayload) {
  const { createHmac } = await __vitePreload(async () => {
    const { createHmac: createHmac2 } = await import("./index-DU1IfKY5.js").then((n) => n._);
    return { createHmac: createHmac2 };
  }, true ? __vite__mapDeps([0,1]) : void 0);
  return createHmac("sha256", apiKey).update(`${encodedHeader}.${encodedPayload}`).digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function createHeader() {
  const header = {
    alg: "HS256",
    typ: "JWT"
  };
  return encode64(header).replace(/=/g, "");
}
function validateTokenParameters(tokenParams) {
  const { searchRules, uid, apiKey, expiresAt } = tokenParams;
  if (expiresAt) {
    if (!(expiresAt instanceof Date)) {
      throw new MeiliSearchError(`Meilisearch: The expiredAt field must be an instance of Date.`);
    } else if (expiresAt.getTime() < Date.now()) {
      throw new MeiliSearchError(`Meilisearch: The expiresAt field must be a date in the future.`);
    }
  }
  if (searchRules) {
    if (!(typeof searchRules === "object" || Array.isArray(searchRules))) {
      throw new MeiliSearchError(`Meilisearch: The search rules added in the token generation must be of type array or object.`);
    }
  }
  if (!apiKey || typeof apiKey !== "string") {
    throw new MeiliSearchError(`Meilisearch: The API key used for the token generation must exist and be of type string.`);
  }
  if (!uid || typeof uid !== "string") {
    throw new MeiliSearchError(`Meilisearch: The uid of the api key used for the token generation must exist, be of type string and comply to the uuid4 format.`);
  }
  if (!validateUuid4(uid)) {
    throw new MeiliSearchError(`Meilisearch: The uid of your key is not a valid uuid4. To find out the uid of your key use getKey().`);
  }
}
function createPayload(payloadParams) {
  const { searchRules, uid, expiresAt } = payloadParams;
  const payload = {
    searchRules,
    apiKeyUid: uid,
    exp: expiresAt ? Math.floor(expiresAt.getTime() / 1e3) : void 0
  };
  return encode64(payload).replace(/=/g, "");
}
class Token2 {
  constructor(config2) {
    __publicField(this, "config");
    this.config = config2;
  }
  /**
   * Generate a tenant token
   *
   * @param apiKeyUid - The uid of the api key used as issuer of the token.
   * @param searchRules - Search rules that are applied to every search.
   * @param options - Token options to customize some aspect of the token.
   * @returns The token in JWT format.
   */
  async generateTenantToken(apiKeyUid, searchRules, options2) {
    const apiKey = (options2 == null ? void 0 : options2.apiKey) || this.config.apiKey || "";
    const uid = apiKeyUid || "";
    const expiresAt = options2 == null ? void 0 : options2.expiresAt;
    validateTokenParameters({ apiKey, uid, expiresAt, searchRules });
    const encodedHeader = createHeader();
    const encodedPayload = createPayload({ searchRules, uid, expiresAt });
    const signature = await sign(apiKey, encodedHeader, encodedPayload);
    return `${encodedHeader}.${encodedPayload}.${signature}`;
  }
}
class MeiliSearch extends Client {
  constructor(config2) {
    super(config2);
    __publicField(this, "tokens");
    this.tokens = new Token2(config2);
  }
  /**
   * Generate a tenant token
   *
   * @param apiKeyUid - The uid of the api key used as issuer of the token.
   * @param searchRules - Search rules that are applied to every search.
   * @param options - Token options to customize some aspect of the token.
   * @returns The token in JWT format.
   */
  async generateTenantToken(apiKeyUid, searchRules, options2) {
    if (typeof window === "undefined") {
      return await this.tokens.generateTenantToken(apiKeyUid, searchRules, options2);
    }
    return await super.generateTenantToken(apiKeyUid, searchRules, options2);
  }
}
new MeiliSearch({ host: "http://melli:7700" });
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
[
  { value: 0, label: "All Times" },
  { value: subDays(/* @__PURE__ */ new Date(), 1), label: "1d ago" },
  { value: subDays(/* @__PURE__ */ new Date(), 7), label: "7d ago" },
  { value: subDays(/* @__PURE__ */ new Date(), 15), label: "15d ago" },
  { value: subMonths(/* @__PURE__ */ new Date(), 1), label: "1m ago" },
  { value: subMonths(/* @__PURE__ */ new Date(), 6), label: "6m ago" },
  { value: subYears(/* @__PURE__ */ new Date(), 1), label: "1y ago" }
];
const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
const Button = reactExports.forwardRef(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Comp,
      {
        className: cn(buttonVariants({ variant, size, className })),
        ref,
        ...props
      }
    );
  }
);
Button.displayName = "Button";
const IPFS_SERVICE_ID = "ipfs";
var DataType = /* @__PURE__ */ ((DataType2) => {
  DataType2[DataType2["Raw"] = 0] = "Raw";
  DataType2[DataType2["Directory"] = 1] = "Directory";
  DataType2[DataType2["File"] = 2] = "File";
  DataType2[DataType2["Metadata"] = 3] = "Metadata";
  DataType2[DataType2["Symlink"] = 4] = "Symlink";
  DataType2[DataType2["HAMTShard"] = 5] = "HAMTShard";
  return DataType2;
})(DataType || {});
class FileTree {
  constructor(restProvider, authHeaders, concurrency = 100, batchSize = 50) {
    this.datastore = new IDBDatastore(`${SERVICE_ID}-meta-cache`);
    this.queue = new PQueue({ concurrency });
    this.restProvider = restProvider;
    this.authHeaders = authHeaders;
    this.batchSize = batchSize;
    this.pendingBatchFetches = /* @__PURE__ */ new Map();
  }
  async initialize() {
    await this.datastore.open();
  }
  async getNodesForPins(pins, parentCid, offset, limit) {
    const cidsToFetch = parentCid ? [parentCid] : pins.map((pin) => pin.pin.cid);
    for (let i = 0; i < cidsToFetch.length; i += this.batchSize) {
      const batch2 = cidsToFetch.slice(i, i + this.batchSize);
      await this.batchFetchBlockMeta(batch2);
    }
    if (parentCid === null) {
      return this.getTopLevelNodes(pins, offset, limit);
    } else {
      return this.getChildNodes(parentCid, pins, offset, limit);
    }
  }
  async getTopLevelNodes(pins, offset, limit) {
    const topLevelPins = await this.identifyTopLevelPins(pins);
    const sortedNodes = await this.sortNodesFoldersFirst(topLevelPins);
    return this.paginateNodes(sortedNodes, offset, limit);
  }
  async identifyTopLevelPins(pins) {
    const cidSet = new Set(pins.map((pin) => pin.pin.cid));
    const topLevelPins = [];
    const childrenSet = /* @__PURE__ */ new Set();
    for (const pin of pins) {
      const blockMeta = await this.getBlockMeta(pin.pin.cid);
      for (const childCid of blockMeta.child_cid) {
        if (cidSet.has(childCid)) {
          childrenSet.add(childCid);
        }
      }
    }
    for (const pin of pins) {
      if (!childrenSet.has(pin.pin.cid)) {
        topLevelPins.push(pin);
      }
    }
    return topLevelPins;
  }
  async getChildNodes(parentCid, pins, offset, limit) {
    const parentMeta = await this.getBlockMeta(parentCid);
    const childCids = parentMeta.child_cid.filter(
      (cid) => pins.some(
        (pin) => CID.parse(pin.pin.cid).toV1().equals(CID.parse(cid).toV1())
      )
    );
    const childNodes = await Promise.all(
      childCids.map((cid) => {
        const matchingPin = pins.find(
          (pin) => CID.parse(pin.pin.cid).toV1().equals(CID.parse(cid).toV1())
        );
        return matchingPin ? this.constructNode(cid, matchingPin) : null;
      })
    );
    const validChildNodes = childNodes.filter(
      (node) => node !== null
    );
    const sortedNodes = await this.sortNodesFoldersFirst(validChildNodes);
    return this.paginateNodes(sortedNodes, offset, limit);
  }
  async sortNodesFoldersFirst(nodes) {
    const constructedNodes = await Promise.all(
      nodes.map(async (node) => {
        if ("type" in node) {
          return node;
        } else {
          return await this.constructNode(node.pin.cid, node);
        }
      })
    );
    return constructedNodes.sort((a, b) => {
      if (a.type === 1 && b.type !== 1) {
        return -1;
      }
      if (a.type !== 1 && b.type === 1) {
        return 1;
      }
      return a.name.localeCompare(b.name);
    });
  }
  paginateNodes(nodes, offset, limit) {
    if (offset === void 0 || limit === void 0) {
      return nodes;
    }
    return nodes.slice(offset, offset + limit);
  }
  async constructNode(cid, pinStatus) {
    const blockMeta = await this.getBlockMeta(cid);
    cid = CID.parse(cid).toV1().toString();
    return {
      cid,
      name: blockMeta.name || cid,
      type: blockMeta.type,
      size: blockMeta.block_size,
      children: this.isDirectory(blockMeta.type) ? [] : void 0,
      pinStatus
    };
  }
  isDirectory(type) {
    return type === 1 || type === 5;
  }
  async getBlockMeta(cid) {
    const cachedMeta = await this.getCachedBlockMeta(cid);
    if (cachedMeta) {
      return cachedMeta;
    }
    const pendingFetch = this.pendingBatchFetches.get(cid);
    if (pendingFetch) {
      return pendingFetch;
    }
    return this.queue.add(async () => {
      try {
        const response = await this.restProvider.getOne({
          resource: "api/block/meta",
          id: cid,
          meta: {
            headers: this.authHeaders
          }
        });
        if (!response.data) {
          throw new Error(`No metadata found for CID ${cid}`);
        }
        const blockMeta = response.data;
        await this.cacheBlockMeta(cid, blockMeta);
        return blockMeta;
      } catch (error) {
        if (error.statusCode === 404) {
          return {
            name: cid,
            type: 0,
            block_size: 0,
            child_cid: []
          };
        }
        console.error(`Error fetching batch block meta:`, error);
        throw error;
      }
    });
  }
  async batchFetchBlockMeta(cids) {
    const uncachedCids = await this.filterUncachedCids(cids);
    if (uncachedCids.length === 0) {
      return;
    }
    const batchPromise = this.queue.add(async () => {
      try {
        const response = await this.restProvider.create({
          resource: "api/block/meta/batch",
          variables: { cid: uncachedCids },
          meta: {
            headers: this.authHeaders
          }
        });
        if (!response.data) {
          throw new Error("No data returned from batch fetch");
        }
        return response.data;
      } catch (error) {
        if (error.statusCode === 404) {
          return uncachedCids.map((cid) => {
            return {
              [cid]: {
                name: cid,
                type: 0,
                block_size: 0,
                child_cid: []
              }
            };
          });
        }
        console.error(`Error fetching batch block meta:`, error);
        throw error;
      }
    });
    try {
      const batchResults = await batchPromise;
      if (!batchResults || typeof batchResults !== "object") {
        throw new Error("Invalid batch results format");
      }
      for (const cid of uncachedCids) {
        if (batchResults.hasOwnProperty(cid)) {
          const blockMeta = batchResults[cid];
          if (this.isValidBlockMetaResponse(blockMeta)) {
            await this.cacheBlockMeta(cid, blockMeta);
            this.pendingBatchFetches.set(cid, Promise.resolve(blockMeta));
          } else {
            console.warn(`Invalid metadata format for CID ${cid}`);
            this.pendingBatchFetches.delete(cid);
          }
        } else {
          console.warn(`No metadata found for CID ${cid} in batch response`);
          this.pendingBatchFetches.delete(cid);
        }
      }
    } catch (error) {
      console.error("Error processing batch results:", error);
      for (const cid of uncachedCids) {
        this.pendingBatchFetches.delete(cid);
      }
    }
  }
  isValidBlockMetaResponse(data) {
    return typeof data === "object" && data !== null && typeof data.type === "number" && typeof data.block_size === "number" && Array.isArray(data.child_cid);
  }
  async filterUncachedCids(cids) {
    const uncachedCids = [];
    for (const cid of cids) {
      const cachedMeta = await this.getCachedBlockMeta(cid);
      if (!cachedMeta) {
        uncachedCids.push(cid);
      }
    }
    return uncachedCids;
  }
  async getCachedBlockMeta(cid) {
    const key = new Key(`block-meta:${cid}`);
    try {
      const cachedData = await this.datastore.get(key);
      return JSON.parse(new TextDecoder().decode(cachedData));
    } catch (error) {
      return null;
    }
  }
  async cacheBlockMeta(cid, meta) {
    const key = new Key(`block-meta:${cid}`);
    await this.datastore.put(
      key,
      new TextEncoder().encode(JSON.stringify(meta))
    );
  }
  async searchNodes(query, pins) {
    const matchingPins = pins.filter(
      (pin) => {
        var _a3;
        return ((_a3 = pin.pin.name) == null ? void 0 : _a3.toLowerCase().includes(query.toLowerCase())) || pin.pin.cid.includes(query);
      }
    );
    return Promise.all(
      matchingPins.map((pin) => this.constructNode(pin.pin.cid, pin))
    );
  }
  async close() {
    await this.datastore.close();
  }
}
function useCopy(initialDelay = 500) {
  const [copied, setCopied] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (copied) {
      const timer = setTimeout(() => setCopied(false), initialDelay);
      return () => clearTimeout(timer);
    }
  }, [copied, initialDelay]);
  const copyToClipboard = reactExports.useCallback(async (text) => {
    await navigator.clipboard.writeText(text);
    setCopied(true);
  }, []);
  return { copied, copyToClipboard };
}
function BareCopyButton({
  copied,
  useButton = true,
  ...props
}) {
  const Icon = copied ? Check : Copy;
  const iconProps = {
    className: copied ? "h-4 w-4 text-green-500" : "h-4 w-4"
  };
  if (useButton) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "ghost", size: "sm", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...iconProps }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ...iconProps });
}
function CIDTooltip({ cid }) {
  const [open, setOpen] = reactExports.useState(false);
  const v1Cid = cid.toV1().toString();
  const v0Cid = cid.toString();
  const { copied, copyToClipboard } = useCopy(500);
  const handleCopy = async (text) => {
    await copyToClipboard(text);
    setOpen(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "cursor-help", children: [
        v1Cid.slice(0, 20),
        "..."
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: v1Cid }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Popover, { open, onOpenChange: setOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PopoverTrigger,
        {
          className: cn$1(buttonVariants$1({ variant: "ghost", size: "sm" })),
          children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsx(BareCopyButton, { copied: true, useButton: false }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BareCopyButton, { copied: false, useButton: false })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContent, { className: "w-48", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            className: "w-full justify-start",
            variant: "ghost",
            onClick: () => handleCopy(v0Cid),
            children: "Copy v0 CID"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            className: "w-full justify-start",
            variant: "ghost",
            onClick: () => handleCopy(v1Cid),
            children: "Copy v1 CID"
          }
        )
      ] }) })
    ] })
  ] });
}
const native = globalThis.showSaveFilePicker;
async function showSaveFilePicker(options2 = {}) {
  if (native && !options2._preferPolyfill) {
    return native(options2);
  }
  if (options2._name) {
    console.warn("deprecated _name, spec now have `suggestedName`");
    options2.suggestedName = options2._name;
  }
  const { FileSystemFileHandle: FileSystemFileHandle2 } = await __vitePreload(async () => {
    const { FileSystemFileHandle: FileSystemFileHandle3 } = await Promise.resolve().then(() => FileSystemFileHandle$1);
    return { FileSystemFileHandle: FileSystemFileHandle3 };
  }, true ? void 0 : void 0);
  const { FileHandle } = await __vitePreload(async () => {
    const { FileHandle: FileHandle2 } = await import("./downloader-C-_U3ak8.js");
    return { FileHandle: FileHandle2 };
  }, true ? __vite__mapDeps([2,1,0,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]) : void 0);
  return new FileSystemFileHandle2(new FileHandle(options2.suggestedName));
}
if (globalThis.DataTransferItem && !DataTransferItem.prototype.getAsFileSystemHandle) {
  DataTransferItem.prototype.getAsFileSystemHandle = async function() {
    const entry = this.webkitGetAsEntry();
    const [
      { FileHandle, FolderHandle },
      { FileSystemDirectoryHandle: FileSystemDirectoryHandle3 },
      { FileSystemFileHandle: FileSystemFileHandle2 }
    ] = await Promise.all([
      __vitePreload(() => import("./sandbox-DrWkn_pL.js"), true ? __vite__mapDeps([28,1,0,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]) : void 0),
      __vitePreload(() => Promise.resolve().then(() => FileSystemDirectoryHandle$2), true ? void 0 : void 0),
      __vitePreload(() => Promise.resolve().then(() => FileSystemFileHandle$1), true ? void 0 : void 0)
    ]);
    return entry.isFile ? new FileSystemFileHandle2(new FileHandle(entry, false)) : new FileSystemDirectoryHandle3(new FolderHandle(entry, false));
  };
}
const config = {
  ReadableStream: globalThis.ReadableStream,
  WritableStream: globalThis.WritableStream,
  TransformStream: globalThis.TransformStream,
  DOMException: globalThis.DOMException,
  Blob: globalThis.Blob,
  File: globalThis.File
};
const { WritableStream } = config;
const _FileSystemWritableFileStream = class _FileSystemWritableFileStream extends WritableStream {
  constructor(writer) {
    super(writer);
    __privateAdd(this, _writer);
    __privateSet(this, _writer, writer);
    Object.setPrototypeOf(this, _FileSystemWritableFileStream.prototype);
    this._closed = false;
  }
  async close() {
    this._closed = true;
    const w2 = this.getWriter();
    const p = w2.close();
    w2.releaseLock();
    return p;
  }
  /** @param {number} position */
  seek(position) {
    return this.write({ type: "seek", position });
  }
  /** @param {number} size */
  truncate(size) {
    return this.write({ type: "truncate", size });
  }
  // The write(data) method steps are:
  write(data) {
    if (this._closed) {
      return Promise.reject(new TypeError("Cannot write to a CLOSED writable stream"));
    }
    const writer = this.getWriter();
    const result = writer.write(data);
    writer.releaseLock();
    return result;
  }
};
_writer = new WeakMap();
let FileSystemWritableFileStream = _FileSystemWritableFileStream;
Object.defineProperty(FileSystemWritableFileStream.prototype, Symbol.toStringTag, {
  value: "FileSystemWritableFileStream",
  writable: false,
  enumerable: false,
  configurable: true
});
Object.defineProperties(FileSystemWritableFileStream.prototype, {
  close: { enumerable: true },
  seek: { enumerable: true },
  truncate: { enumerable: true },
  write: { enumerable: true }
});
if (globalThis.FileSystemFileHandle && !globalThis.FileSystemFileHandle.prototype.createWritable && !globalThis.FileSystemWritableFileStream) {
  globalThis.FileSystemWritableFileStream = FileSystemWritableFileStream;
}
const kAdapter$2 = Symbol("adapter");
_i = kAdapter$2;
class FileSystemHandle {
  /** @param {FileSystemHandle & {writable}} adapter */
  constructor(adapter) {
    /** @type {FileSystemHandle} */
    __publicField(this, _i);
    /** @type {string} */
    __publicField(this, "name");
    /** @type {('file'|'directory')} */
    __publicField(this, "kind");
    this.kind = adapter.kind;
    this.name = adapter.name;
    this[kAdapter$2] = adapter;
  }
  /** @param {FileSystemHandlePermissionDescriptor} descriptor */
  async queryPermission(descriptor = {}) {
    const { mode = "read" } = descriptor;
    const handle = this[kAdapter$2];
    if (handle.queryPermission) {
      return handle.queryPermission({ mode });
    }
    if (mode === "read") {
      return "granted";
    } else if (mode === "readwrite") {
      return handle.writable ? "granted" : "denied";
    } else {
      throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);
    }
  }
  async requestPermission({ mode = "read" } = {}) {
    const handle = this[kAdapter$2];
    if (handle.requestPermission) {
      return handle.requestPermission({ mode });
    }
    if (mode === "read") {
      return "granted";
    } else if (mode === "readwrite") {
      return handle.writable ? "granted" : "denied";
    } else {
      throw new TypeError(`Mode ${mode} must be 'read' or 'readwrite'`);
    }
  }
  /**
   * Attempts to remove the entry represented by handle from the underlying file system.
   *
   * @param {object} options
   * @param {boolean} [options.recursive=false]
   */
  async remove(options2 = {}) {
    await this[kAdapter$2].remove(options2);
  }
  /**
   * @param {FileSystemHandle} other
   */
  async isSameEntry(other) {
    if (this === other) return true;
    if (!other || typeof other !== "object" || this.kind !== other.kind || !other[kAdapter$2]) return false;
    return this[kAdapter$2].isSameEntry(other[kAdapter$2]);
  }
}
Object.defineProperty(FileSystemHandle.prototype, Symbol.toStringTag, {
  value: "FileSystemHandle",
  writable: false,
  enumerable: false,
  configurable: true
});
if (globalThis.FileSystemHandle) {
  (_j = globalThis.FileSystemHandle.prototype).queryPermission ?? (_j.queryPermission = function(descriptor) {
    return "granted";
  });
}
const errors = {
  INVALID: ["seeking position failed.", "InvalidStateError"],
  GONE: ["A requested file or directory could not be found at the time an operation was processed.", "NotFoundError"],
  MISMATCH: ["The path supplied exists, but was not an entry of requested type.", "TypeMismatchError"],
  MOD_ERR: ["The object can not be modified in this way.", "InvalidModificationError"],
  SYNTAX: (m2) => [`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${m2}`, "SyntaxError"],
  SECURITY: ["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.", "SecurityError"],
  DISALLOWED: ["The request is not allowed by the user agent or the platform in the current context.", "NotAllowedError"]
};
const { GONE: GONE$1, MOD_ERR } = errors;
const kAdapter$1 = Symbol("adapter");
let FileSystemDirectoryHandle$1 = class FileSystemDirectoryHandle2 extends FileSystemHandle {
  constructor(adapter) {
    super(adapter);
    /** @type {FileSystemDirectoryHandle} */
    __publicField(this, _k);
    this[kAdapter$1] = adapter;
  }
  /**
   * @param {string} name Name of the directory
   * @param {object} [options]
   * @param {boolean} [options.create] create the directory if don't exist
   * @returns {Promise<FileSystemDirectoryHandle>}
   */
  async getDirectoryHandle(name2, options2 = {}) {
    if (name2 === "") {
      throw new TypeError(`Name can't be an empty string.`);
    }
    if (name2 === "." || name2 === ".." || name2.includes("/")) {
      throw new TypeError(`Name contains invalid characters.`);
    }
    options2.create = !!options2.create;
    const handle = await this[kAdapter$1].getDirectoryHandle(name2, options2);
    return new FileSystemDirectoryHandle2(handle);
  }
  /** @returns {AsyncGenerator<[string, FileSystemHandle | FileSystemDirectoryHandle]>} */
  async *entries() {
    const { FileSystemFileHandle: FileSystemFileHandle2 } = await __vitePreload(async () => {
      const { FileSystemFileHandle: FileSystemFileHandle3 } = await Promise.resolve().then(() => FileSystemFileHandle$1);
      return { FileSystemFileHandle: FileSystemFileHandle3 };
    }, true ? void 0 : void 0);
    for await (const [_, entry] of this[kAdapter$1].entries())
      yield [entry.name, entry.kind === "file" ? new FileSystemFileHandle2(entry) : new FileSystemDirectoryHandle2(entry)];
  }
  /** @deprecated use .entries() instead */
  async *getEntries() {
    const { FileSystemFileHandle: FileSystemFileHandle2 } = await __vitePreload(async () => {
      const { FileSystemFileHandle: FileSystemFileHandle3 } = await Promise.resolve().then(() => FileSystemFileHandle$1);
      return { FileSystemFileHandle: FileSystemFileHandle3 };
    }, true ? void 0 : void 0);
    console.warn("deprecated, use .entries() instead");
    for await (let entry of this[kAdapter$1].entries())
      yield entry.kind === "file" ? new FileSystemFileHandle2(entry) : new FileSystemDirectoryHandle2(entry);
  }
  /**
   * @param {string} name Name of the file
   * @param {object} [options]
   * @param {boolean} [options.create] create the file if don't exist
   */
  async getFileHandle(name2, options2 = {}) {
    const { FileSystemFileHandle: FileSystemFileHandle2 } = await __vitePreload(async () => {
      const { FileSystemFileHandle: FileSystemFileHandle3 } = await Promise.resolve().then(() => FileSystemFileHandle$1);
      return { FileSystemFileHandle: FileSystemFileHandle3 };
    }, true ? void 0 : void 0);
    if (name2 === "") throw new TypeError(`Name can't be an empty string.`);
    if (name2 === "." || name2 === ".." || name2.includes("/")) {
      throw new TypeError(`Name contains invalid characters.`);
    }
    options2.create = !!options2.create;
    const handle = await this[kAdapter$1].getFileHandle(name2, options2);
    return new FileSystemFileHandle2(handle);
  }
  /**
   * @param {string} name
   * @param {object} [options]
   * @param {boolean} [options.recursive]
   */
  async removeEntry(name2, options2 = {}) {
    if (name2 === "") {
      throw new TypeError(`Name can't be an empty string.`);
    }
    if (name2 === "." || name2 === ".." || name2.includes("/")) {
      throw new TypeError(`Name contains invalid characters.`);
    }
    options2.recursive = !!options2.recursive;
    return this[kAdapter$1].removeEntry(name2, options2);
  }
  async resolve(possibleDescendant) {
    if (await possibleDescendant.isSameEntry(this)) {
      return [];
    }
    const openSet = [{ handle: this, path: [] }];
    while (openSet.length) {
      let { handle: current, path } = openSet.pop();
      for await (const entry of current.values()) {
        if (await entry.isSameEntry(possibleDescendant)) {
          return [...path, entry.name];
        }
        if (entry.kind === "directory") {
          openSet.push({ handle: entry, path: [...path, entry.name] });
        }
      }
    }
    return null;
  }
  async *keys() {
    for await (const [name2] of this[kAdapter$1].entries())
      yield name2;
  }
  async *values() {
    for await (const [_, entry] of this)
      yield entry;
  }
  [(_k = kAdapter$1, Symbol.asyncIterator)]() {
    return this.entries();
  }
};
Object.defineProperty(FileSystemDirectoryHandle$1.prototype, Symbol.toStringTag, {
  value: "FileSystemDirectoryHandle",
  writable: false,
  enumerable: false,
  configurable: true
});
Object.defineProperties(FileSystemDirectoryHandle$1.prototype, {
  getDirectoryHandle: { enumerable: true },
  entries: { enumerable: true },
  getFileHandle: { enumerable: true },
  removeEntry: { enumerable: true }
});
if (globalThis.FileSystemDirectoryHandle) {
  const proto = globalThis.FileSystemDirectoryHandle.prototype;
  proto.resolve = async function resolve2(possibleDescendant) {
    if (await possibleDescendant.isSameEntry(this)) {
      return [];
    }
    const openSet = [{ handle: this, path: [] }];
    while (openSet.length) {
      let { handle: current, path } = openSet.pop();
      for await (const entry of current.values()) {
        if (await entry.isSameEntry(possibleDescendant)) {
          return [...path, entry.name];
        }
        if (entry.kind === "directory") {
          openSet.push({ handle: entry, path: [...path, entry.name] });
        }
      }
    }
    return null;
  };
  async function ensureDoActuallyStillExist(handle) {
    const root2 = await navigator.storage.getDirectory();
    const path = await root2.resolve(handle);
    if (path === null) {
      throw new DOMException(...GONE$1);
    }
  }
  const entries = proto.entries;
  proto.entries = async function* () {
    await ensureDoActuallyStillExist(this);
    yield* entries.call(this);
  };
  proto[Symbol.asyncIterator] = async function* () {
    yield* this.entries();
  };
  const removeEntry = proto.removeEntry;
  proto.removeEntry = async function(name2, options2 = {}) {
    return removeEntry.call(this, name2, options2).catch(async (err) => {
      const unknown = err instanceof DOMException && err.name === "UnknownError";
      if (unknown && !options2.recursive) {
        const empty = (await entries.call(this).next()).done;
        if (!empty) {
          throw new DOMException(...MOD_ERR);
        }
      }
      throw err;
    });
  };
}
const FileSystemDirectoryHandle$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FileSystemDirectoryHandle: FileSystemDirectoryHandle$1,
  default: FileSystemDirectoryHandle$1
}, Symbol.toStringTag, { value: "Module" }));
const { INVALID, SYNTAX, GONE } = errors;
const kAdapter = Symbol("adapter");
class FileSystemFileHandle extends (_m = FileSystemHandle, _l = kAdapter, _m) {
  constructor(adapter) {
    super(adapter);
    /** @type {FileSystemFileHandle} */
    __publicField(this, _l);
    this[kAdapter] = adapter;
  }
  /**
   * @param  {Object} [options={}]
   * @param  {boolean} [options.keepExistingData]
   * @returns {Promise<FileSystemWritableFileStream>}
   */
  async createWritable(options2 = {}) {
    return new FileSystemWritableFileStream(
      await this[kAdapter].createWritable(options2)
    );
  }
  /**
   * @returns {Promise<File>}
   */
  async getFile() {
    return this[kAdapter].getFile();
  }
}
Object.defineProperty(FileSystemFileHandle.prototype, Symbol.toStringTag, {
  value: "FileSystemFileHandle",
  writable: false,
  enumerable: false,
  configurable: true
});
Object.defineProperties(FileSystemFileHandle.prototype, {
  createWritable: { enumerable: true },
  getFile: { enumerable: true }
});
if (globalThis.FileSystemFileHandle && !globalThis.FileSystemFileHandle.prototype.createWritable) {
  const wm = /* @__PURE__ */ new WeakMap();
  let workerUrl;
  const code2 = () => {
    let fileHandle, handle;
    onmessage = async (evt) => {
      const port2 = evt.ports[0];
      const cmd = evt.data;
      switch (cmd.type) {
        case "open":
          const file = cmd.name;
          let dir = await navigator.storage.getDirectory();
          for (const folder of cmd.path) {
            dir = await dir.getDirectoryHandle(folder);
          }
          fileHandle = await dir.getFileHandle(file);
          handle = await fileHandle.createSyncAccessHandle();
          break;
        case "write":
          handle.write(cmd.data, { at: cmd.position });
          handle.flush();
          break;
        case "truncate":
          handle.truncate(cmd.size);
          break;
        case "abort":
        case "close":
          handle.close();
          break;
      }
      port2.postMessage(0);
    };
  };
  globalThis.FileSystemFileHandle.prototype.createWritable = async function(options2) {
    if (!workerUrl) {
      const stringCode = `(${code2.toString()})()`;
      const blob = new Blob([stringCode], {
        type: "text/javascript"
      });
      workerUrl = URL.createObjectURL(blob);
    }
    const worker = new Worker(workerUrl, { type: "module" });
    let position = 0;
    const textEncoder2 = new TextEncoder();
    let size = await this.getFile().then((file) => file.size);
    const send = (message2) => new Promise((resolve2, reject) => {
      const mc = new MessageChannel();
      mc.port1.onmessage = (evt) => {
        if (evt.data instanceof Error) reject(evt.data);
        else resolve2(evt.data);
        mc.port1.close();
        mc.port2.close();
        mc.port1.onmessage = null;
      };
      worker.postMessage(message2, [mc.port2]);
    });
    const root2 = await navigator.storage.getDirectory();
    const parent = await wm.get(this);
    const path = await root2.resolve(parent);
    if (path === null) throw new DOMException(...GONE);
    await send({ type: "open", path, name: this.name });
    if ((options2 == null ? void 0 : options2.keepExistingData) === false) {
      await send({ type: "truncate", size: 0 });
      size = 0;
    }
    const ws = new FileSystemWritableFileStream({
      start: (ctrl) => {
      },
      async write(chunk) {
        const isPlainObject = (chunk == null ? void 0 : chunk.constructor) === Object;
        if (isPlainObject) {
          chunk = { ...chunk };
        } else {
          chunk = { type: "write", data: chunk, position };
        }
        if (chunk.type === "write") {
          if (!("data" in chunk)) {
            await send({ type: "close" });
            throw new DOMException(...SYNTAX("write requires a data argument"));
          }
          chunk.position ?? (chunk.position = position);
          if (typeof chunk.data === "string") {
            chunk.data = textEncoder2.encode(chunk.data);
          } else if (chunk.data instanceof ArrayBuffer) {
            chunk.data = new Uint8Array(chunk.data);
          } else if (!(chunk.data instanceof Uint8Array) && ArrayBuffer.isView(chunk.data)) {
            chunk.data = new Uint8Array(chunk.data.buffer, chunk.data.byteOffset, chunk.data.byteLength);
          } else if (!(chunk.data instanceof Uint8Array)) {
            const ab = await new Response(chunk.data).arrayBuffer();
            chunk.data = new Uint8Array(ab);
          }
          if (Number.isInteger(chunk.position) && chunk.position >= 0) {
            position = chunk.position;
          }
          position += chunk.data.byteLength;
          size += chunk.data.byteLength;
        } else if (chunk.type === "seek") {
          if (Number.isInteger(chunk.position) && chunk.position >= 0) {
            if (size < chunk.position) {
              throw new DOMException(...INVALID);
            }
            console.log("seeking", chunk);
            position = chunk.position;
            return;
          } else {
            await send({ type: "close" });
            throw new DOMException(...SYNTAX("seek requires a position argument"));
          }
        } else if (chunk.type === "truncate") {
          if (Number.isInteger(chunk.size) && chunk.size >= 0) {
            size = chunk.size;
            if (position > size) {
              position = size;
            }
          } else {
            await send({ type: "close" });
            throw new DOMException(...SYNTAX("truncate requires a size argument"));
          }
        }
        await send(chunk);
      },
      async close() {
        await send({ type: "close" });
        worker.terminate();
      },
      async abort(reason) {
        await send({ type: "abort", reason });
        worker.terminate();
      }
    });
    return ws;
  };
  const orig = FileSystemDirectoryHandle.prototype.getFileHandle;
  FileSystemDirectoryHandle.prototype.getFileHandle = async function(...args) {
    const handle = await orig.call(this, ...args);
    wm.set(handle, this);
    return handle;
  };
}
const FileSystemFileHandle$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FileSystemFileHandle,
  default: FileSystemFileHandle
}, Symbol.toStringTag, { value: "Module" }));
function ItemActions({
  cid,
  isFolder,
  suggestedDownloadName
}) {
  const svc = useActiveService();
  const [isDownloading, setIsDownloading] = reactExports.useState(false);
  const [isUnpinning, setIsUnpinning] = reactExports.useState(false);
  Pe();
  const { mutate } = xo();
  const handleDownload = async () => {
    setIsDownloading(true);
    try {
      const file = await (svc == null ? void 0 : svc.downloadFile(cid));
      const fileHandle = await showSaveFilePicker({
        _preferPolyfill: false,
        suggestedName: suggestedDownloadName ?? (file == null ? void 0 : file.name)
      });
      const writer = await fileHandle.createWritable();
      await writer.write(file == null ? void 0 : file.blob);
      await writer.close();
    } catch (error) {
      console.error("Download failed:", error);
    } finally {
      setIsDownloading(false);
    }
  };
  const handleUnpin = async () => {
    setIsUnpinning(true);
    try {
      await mutate({
        resource: svc == null ? void 0 : svc.id(),
        id: cid.toString(),
        successNotification() {
          return {
            message: "Item successfully unpinned",
            type: "success"
          };
        },
        errorNotification(error) {
          if (error) {
            return {
              message: "Failed to unpin item",
              description: error.message,
              type: "error"
            };
          }
          return false;
        }
      });
    } catch (error) {
      console.error("Unpin failed:", error);
    } finally {
      setIsUnpinning(false);
    }
  };
  const taskInProgress = isDownloading || isUnpinning;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end items-center", children: taskInProgress ? /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, {}) : /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenu, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "ghost", className: "h-8 w-8 p-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(EllipsisVertical, { className: "h-4 w-4" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenuContent, { align: "end", children: [
      !isFolder && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DropdownMenuItem,
        {
          onClick: handleDownload,
          disabled: isDownloading,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "mr-2 h-4 w-4" }),
            "Download"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenuItem, { onClick: handleUnpin, disabled: isUnpinning, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Trash, { className: "mr-2 h-4 w-4" }),
        "Unpin"
      ] })
    ] })
  ] }) });
}
function Loading() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex space-x-1 h-8 w-8 items-center justify-center",
      role: "status",
      "aria-label": "Loading",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "w-2 h-2 bg-primary rounded-full animate-bounce",
            style: { animationDelay: "0s" }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "w-2 h-2 bg-primary rounded-full animate-bounce",
            style: { animationDelay: "0.2s" }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "w-2 h-2 bg-primary rounded-full animate-bounce",
            style: { animationDelay: "0.4s" }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Loading..." })
      ]
    }
  );
}
class Node {
  constructor(value) {
    __publicField(this, "value");
    __publicField(this, "next");
    this.value = value;
  }
}
class Queue2 {
  constructor() {
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _size);
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    return current.value;
  }
  peek() {
    if (!__privateGet(this, _head)) {
      return;
    }
    return __privateGet(this, _head).value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
}
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();
class Mutex {
  constructor() {
    __privateAdd(this, _queue5, new Queue2());
    __privateAdd(this, _isLocked, false);
  }
  async lock() {
    if (!__privateGet(this, _isLocked)) {
      __privateSet(this, _isLocked, true);
      return;
    }
    return new Promise((resolve2) => {
      __privateGet(this, _queue5).enqueue(resolve2);
    });
  }
  unlock() {
    if (__privateGet(this, _queue5).size > 0) {
      const resolve2 = __privateGet(this, _queue5).dequeue();
      resolve2();
    } else {
      __privateSet(this, _isLocked, false);
    }
  }
  async withLock(task) {
    try {
      await this.lock();
      return await task();
    } finally {
      this.unlock();
    }
  }
  get isLocked() {
    return __privateGet(this, _isLocked);
  }
}
_queue5 = new WeakMap();
_isLocked = new WeakMap();
const CopyButton = ({
  text,
  animate = true,
  showText = true
}) => {
  const { copied, copyToClipboard } = useCopy(animate ? 500 : 0);
  const handleCopy = () => copyToClipboard(text);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
    showText && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: text.length > 20 ? `${text.slice(0, 20)}...` : text }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BareCopyButton, { onClick: handleCopy, copied })
  ] });
};
const SERVICE_ID = IPFS_SERVICE_ID;
const SERVICE_NAME = "IPFS";
const defaultPinMeta = {
  folder: false,
  contentType: ""
};
class IPFS extends BaseService {
  constructor() {
    super(...arguments);
    __privateAdd(this, _IPFS_instances);
    __privateAdd(this, _helia);
    __privateAdd(this, _pinner);
    __privateAdd(this, _remoteClient);
    __privateAdd(this, _restProvider);
    __privateAdd(this, _fileTree);
    __privateAdd(this, _lastPinSet);
    __privateAdd(this, _lastPinSetDefer, pDefer());
    __privateAdd(this, _lastPinSetMutex, new Mutex());
  }
  id() {
    return SERVICE_ID;
  }
  name() {
    return SERVICE_NAME;
  }
  register() {
    (async () => {
      const protocolDomain = await getProtocolDomain(SERVICE_ID);
      const apiDomain = `https://${protocolDomain}`;
      getUploadManager().registerService({
        id: SERVICE_ID,
        name: SERVICE_NAME,
        largeFilePlugin: {
          plugin: Tus,
          options: {
            endpoint: `${apiDomain}/api/upload/tus`,
            withCredentials: true,
            headers: __privateMethod(this, _IPFS_instances, getAuthHeaders_fn).call(this),
            storeFingerprintForResuming: false
          }
        },
        smallFilePlugin: {
          plugin: XHRUpload,
          options: {
            withCredentials: true,
            endpoint: `${apiDomain}/api/upload`,
            method: "POST",
            headers: __privateMethod(this, _IPFS_instances, getAuthHeaders_fn).call(this),
            shouldRetry: (xhr) => xhr.status !== 507 && xhr.status !== 403
          }
        }
      });
      getUploadManager().usePlugin(CarPreprocessorPlugin);
    })();
  }
  async getRestProvider() {
    if (!__privateGet(this, _restProvider)) {
      const apiDomain = await getProtocolDomain(SERVICE_ID);
      const baseUrl = `https://${apiDomain}`;
      __privateSet(this, _restProvider, N(baseUrl));
    }
    return __privateGet(this, _restProvider);
  }
  async getFileTree() {
    if (!__privateGet(this, _fileTree)) {
      __privateSet(this, _fileTree, new FileTree(
        await this.getRestProvider(),
        __privateMethod(this, _IPFS_instances, getAuthHeaders_fn).call(this)
      ));
      await __privateGet(this, _fileTree).initialize();
    }
    return __privateGet(this, _fileTree);
  }
  async dataProvider() {
    const that = this;
    const restProvider = await this.getRestProvider();
    return {
      ...restProvider,
      async getList(params) {
        const { pagination = {}, filters, meta } = params;
        const { current = 1, pageSize = 50 } = pagination;
        const offset = (current - 1) * pageSize;
        const { count: count2, results: resultsSet } = await getListViaPinner(
          params,
          that
        );
        let pinStatuses = Array.from(resultsSet).map((result) => ({
          ...result,
          info: {
            ...defaultPinMeta,
            ...result.info
          }
        }));
        if (meta == null ? void 0 : meta.fileManager) {
          const parentCid = meta.parentCid || null;
          const fileTree = await that.getFileTree();
          let nodes = await fileTree.getNodesForPins(
            pinStatuses,
            parentCid,
            offset,
            pageSize
          );
          __privateSet(that, _lastPinSet, pinStatuses);
          __privateGet(that, _lastPinSetDefer).resolve();
          pinStatuses = nodesToPins(nodes);
        }
        if (filters == null ? void 0 : filters.length) {
          pinStatuses = applyFilters(pinStatuses, filters);
        }
        if (!(meta == null ? void 0 : meta.fileManager)) {
          pinStatuses = pinStatuses.slice(offset, offset + pageSize);
        }
        return {
          data: pinStatuses,
          total: (meta == null ? void 0 : meta.fileManager) ? pinStatuses.length : count2
        };
      },
      async create(params) {
        if (params.resource !== SERVICE_ID) {
          return restProvider.create(params);
        }
        const cids = params.variables.cid.map((tag) => tag.text);
        const remoteClient = await that.getRemoteClient();
        for (const cid of cids) {
          await (remoteClient == null ? void 0 : remoteClient.pinsPost({ pin: { cid } }));
        }
        return {};
      },
      async deleteOne(params) {
        const pinSet = await that.getCachedPinSet();
        const cid = CID.parse(params.id);
        const pin = pinSet.find(
          (pin2) => CID.parse(pin2.pin.cid).toV1().equals(cid)
        );
        if (!pin) {
          throw new Error("Pin not found");
        }
        const remote = await that.getRemoteClient();
        await (remote == null ? void 0 : remote.pinsRequestidDelete({ requestid: pin.requestid }));
        return {};
      }
    };
  }
  resources() {
    return [
      {
        name: SERVICE_ID,
        meta: {
          headers: __privateMethod(this, _IPFS_instances, getAuthHeaders_fn).call(this)
        }
      },
      {
        name: IPFS_SUBFOLDER_ROUTE,
        show: `/service/${SERVICE_ID}/folder/:id`,
        meta: {
          serviceId: SERVICE_ID
        }
      }
    ];
  }
  UIUploadQueueColumns() {
    const columnHelper = createColumnHelper();
    return [
      columnHelper.accessor("pin.name", {
        cell: (info) => {
          return info.getValue() || CID.parse(info.row.original.pin.cid).toV1().toString();
        },
        header: "Name"
      }),
      columnHelper.accessor("pin.cid", {
        cell: (info) => info.getValue(),
        header: "CID"
      }),
      columnHelper.accessor("created", {
        cell: (info) => new Date(info.getValue()).toLocaleString(),
        header: "Created"
      }),
      columnHelper.accessor("status", {
        cell: (info) => getPinLabel(info.getValue()),
        header: "Status"
      })
    ];
  }
  UIUploadQueueResource() {
    return SERVICE_NAME;
  }
  async getHelia() {
    if (!__privateGet(this, _helia)) {
      const meta = await fetchPortalMeta(getPortalUrl());
      const protocolDomain = await getProtocolDomain(SERVICE_ID);
      const blockstore = new IDBBlockstore(meta.domain);
      const datastore = new IDBDatastore(meta.domain);
      await blockstore.open();
      await datastore.open();
      __privateSet(this, _helia, await createHeliaHTTP({
        blockBrokers: [
          trustlessGateway({
            headers: __privateMethod(this, _IPFS_instances, getAuthHeaders_fn).call(this)
          })
        ],
        routers: [
          httpGatewayRouting({
            gateways: [`https://${protocolDomain}`]
          })
        ],
        blockstore,
        datastore
      }));
    }
    return __privateGet(this, _helia);
  }
  async getPinner() {
    if (!__privateGet(this, _pinner)) {
      const helia = await this.getHelia();
      const remotePinningClient = await this.getRemoteClient();
      __privateSet(this, _pinner, createRemotePinner(helia, remotePinningClient));
    }
    return __privateGet(this, _pinner);
  }
  async getRemoteClient() {
    if (!__privateGet(this, _remoteClient)) {
      const domain = await getProtocolDomain(SERVICE_ID);
      const pinServiceConfig = new Configuration2({
        endpointUrl: `https://${domain}`,
        accessToken: `${getSdk().account().jwtToken}`
      });
      __privateSet(this, _remoteClient, new PinsApi(pinServiceConfig));
    }
    return __privateGet(this, _remoteClient);
  }
  UIFileManagerColumns() {
    const columnHelper = createColumnHelper();
    const nav = Pe();
    const navigateToFolder = (file) => {
      nav.show(IPFS_SUBFOLDER_ROUTE, file.pin.cid);
    };
    return [
      columnHelper.accessor("pin.name", {
        cell: (info) => {
          const name2 = info.getValue() || info.row.original.pin.cid;
          const isFolder = info.row.original.info.folder;
          return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            isFolder ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                variant: "ghost",
                className: "p-0 hover:bg-transparent",
                onClick: () => navigateToFolder(info.row.original),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Folder, { className: "inline mr-2" }),
                  name2
                ]
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FileIcon, { className: "inline mr-2" }),
              name2
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CopyButton, { text: name2, showText: false })
          ] }) });
        },
        header: "Name"
      }),
      columnHelper.accessor("pin.cid", {
        cell: (info) => /* @__PURE__ */ jsxRuntimeExports.jsx(CIDTooltip, { cid: CID.parse(info.getValue()) }),
        header: "CID"
      }),
      columnHelper.accessor("created", {
        cell: (info) => new Date(info.getValue()).toLocaleString(),
        header: "Created"
      }),
      columnHelper.display({
        header: "Actions",
        id: "actions",
        cell: (info) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          ItemActions,
          {
            cid: CID.parse(info.row.original.pin.cid),
            isFolder: info.row.original.info.folder,
            suggestedDownloadName: info.row.original.pin.name
          }
        ),
        meta: {
          className: "text-right"
        },
        size: 50
      })
    ];
  }
  validateCid(cid) {
    try {
      CID.parse(cid);
      return true;
    } catch (e) {
      return false;
    }
  }
  async downloadFile(cid) {
    const fs = unixfs(await this.getHelia());
    const chunks = [];
    let totalLength = 0;
    for await (const chunk of fs.cat(cid)) {
      chunks.push(chunk);
      totalLength += chunk.length;
    }
    const content = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      content.set(chunk, offset);
      offset += chunk.length;
    }
    const tree = await this.getFileTree();
    let meta;
    try {
      meta = await tree.getBlockMeta(cid.toString());
    } catch {
    }
    return {
      name: (meta == null ? void 0 : meta.name) || cid.toV1().toString(),
      mimeType: "application/octet-stream",
      blob: new Blob([content], { type: "application/octet-stream" })
    };
  }
  UIFileManagerCurrentBreadcrumbPathHook() {
    const parsed = Te();
    return async () => {
      var _a3, _b2;
      const getName = async (pin) => {
        const fileTree2 = await this.getFileTree();
        const meta = await fileTree2.getBlockMeta(pin.pin.cid);
        return pin.pin.name || meta.name || pin.pin.cid;
      };
      if (((_a3 = __privateGet(this, _lastPinSet)) == null ? void 0 : _a3.length) === 0 || !parsed.id) {
        return [];
      }
      const parts = [];
      const fileTree = await this.getFileTree();
      let lastCid;
      try {
        lastCid = CID.parse(parsed.id).toV1();
      } catch (e) {
        return [];
      }
      const pinSet = await this.getCachedPinSet();
      const lastFiltered = (_b2 = __privateGet(this, _lastPinSet)) == null ? void 0 : _b2.filter((pin) => {
        return CID.parse(pin.pin.cid).toV1().equals(lastCid);
      });
      if (!(lastFiltered == null ? void 0 : lastFiltered.length)) {
        return [];
      }
      let lastPin = lastFiltered[0];
      let isFirstIteration = true;
      while (lastPin) {
        let found = false;
        for (const pin of pinSet) {
          try {
            const meta = await fileTree.getBlockMeta(pin.pin.cid.toString());
            if (meta.child_cid.includes(lastPin.pin.cid)) {
              if (!isFirstIteration || parts.length === 0) {
                parts.unshift({
                  name: await getName(lastPin),
                  cid: CID.parse(lastPin.pin.cid).toV1()
                });
              }
              lastPin = pin;
              found = true;
              break;
            }
          } catch {
          }
        }
        if (!found) {
          if (parts.length === 0 || !CID.parse(lastPin.pin.cid).toV1().equals(parts[0].cid)) {
            parts.unshift({
              name: await getName(lastPin),
              cid: CID.parse(lastPin.pin.cid).toV1()
            });
          }
          break;
        }
        isFirstIteration = false;
      }
      return parts;
    };
  }
  UIGetSearchFilters(searchQuery) {
    if (!searchQuery) return [];
    return [
      {
        operator: "or",
        value: [
          {
            field: "pin.name",
            operator: "contains",
            value: searchQuery
          },
          {
            field: "pin.cid",
            operator: "contains",
            value: searchQuery
          }
        ]
      }
    ];
  }
  UINavigateToCIDHook() {
    const nav = Pe();
    return (cid) => {
      nav.show(IPFS_SUBFOLDER_ROUTE, cid.toString());
    };
  }
  async getCachedPinSet() {
    var _a3;
    if (!__privateGet(this, _lastPinSet)) {
      await __privateGet(this, _lastPinSetDefer).promise;
    }
    __privateGet(this, _lastPinSetMutex).lock();
    const pinSet = (_a3 = __privateGet(this, _lastPinSet)) == null ? void 0 : _a3.slice();
    __privateGet(this, _lastPinSetMutex).unlock();
    return pinSet;
  }
  UIGetHasActiveUploads() {
    var _a3;
    const list = zt({
      resource: SERVICE_ID,
      filters: [
        {
          operator: "or",
          value: [
            {
              field: "status",
              operator: "eq",
              value: "queued"
            },
            {
              field: "status",
              operator: "eq",
              value: "pinning"
            }
          ]
        }
      ],
      queryOptions: {
        refetchInterval: 5e3
      }
    });
    if (list == null ? void 0 : list.isFetching) {
      return false;
    }
    return (((_a3 = list == null ? void 0 : list.data) == null ? void 0 : _a3.total) ?? 0) > 0;
  }
}
_helia = new WeakMap();
_pinner = new WeakMap();
_remoteClient = new WeakMap();
_restProvider = new WeakMap();
_fileTree = new WeakMap();
_lastPinSet = new WeakMap();
_lastPinSetDefer = new WeakMap();
_lastPinSetMutex = new WeakMap();
_IPFS_instances = new WeakSet();
getAuthHeaders_fn = function() {
  var _a3;
  return {
    Authorization: `Bearer ${(_a3 = getSdk()) == null ? void 0 : _a3.account().jwtToken}`
  };
};
function getPinLabel(status) {
  switch (status) {
    case "queued":
      return "Queued";
    case "pinning":
      return "Pinning";
    case "pinned":
      return "Pinned";
    case "failed":
      return "Failed";
  }
  return "Unknown";
}
async function getListViaPinner(params, svc) {
  const client = await svc.getRemoteClient();
  const { pagination = {}, filters, meta } = params;
  const { pageSize = 50 } = pagination;
  let allResults = [];
  let hasMoreResults = true;
  let oldestTimestamp;
  let totalCount = 0;
  let status;
  if (filters == null ? void 0 : filters.length) {
    status = extractStatusFilters(filters);
  }
  while (hasMoreResults) {
    const { count: count2, results: resultsSet } = await client.pinsGet({
      status,
      ...oldestTimestamp && { before: oldestTimestamp },
      limit: totalCount ?? pageSize
    });
    totalCount = count2;
    const results = Array.from(resultsSet).map((result) => ({
      ...result,
      info: {
        ...defaultPinMeta,
        ...result.info
      }
    }));
    allResults = [...allResults, ...results];
    if (results.length > 0) {
      const oldestInBatch = results.reduce(
        (oldest, current) => current.created < oldest.created ? current : oldest
      );
      oldestTimestamp = oldestInBatch.created;
    }
    hasMoreResults = totalCount > allResults.length && results.length > 0;
  }
  return {
    results: new Set(allResults),
    count: totalCount
  };
}
function applyFilters(pinStatuses, filters) {
  return pinStatuses.filter((pinStatus) => {
    return filters.every((filter2) => applyFilter(pinStatus, filter2));
  });
}
function applyFilter(pinStatus, filter2) {
  if ("field" in filter2) {
    return applyLogicalFilter(pinStatus, filter2);
  } else if ("operator" in filter2) {
    if (filter2.operator === "or") {
      return filter2.value.some(
        (subFilter) => applyFilter(pinStatus, subFilter)
      );
    } else if (filter2.operator === "and") {
      return filter2.value.every(
        (subFilter) => applyFilter(pinStatus, subFilter)
      );
    }
  }
  return true;
}
function applyLogicalFilter(pinStatus, filter2) {
  const value = getNestedValue(pinStatus, filter2.field);
  switch (filter2.operator) {
    case "eq":
      return value === filter2.value;
    case "ne":
      return value !== filter2.value;
    case "lt":
      return value < filter2.value;
    case "gt":
      return value > filter2.value;
    case "lte":
      return value <= filter2.value;
    case "gte":
      return value >= filter2.value;
    case "in":
      return Array.isArray(filter2.value) && filter2.value.includes(value);
    case "nin":
      return Array.isArray(filter2.value) && !filter2.value.includes(value);
    case "contains":
      return typeof value === "string" && value.toLowerCase().includes(String(filter2.value).toLowerCase());
    case "ncontains":
      return typeof value === "string" && !value.toLowerCase().includes(String(filter2.value).toLowerCase());
    default:
      return true;
  }
}
function getNestedValue(obj, path) {
  return path.split(".").reduce((acc, part) => acc && acc[part], obj);
}
function nodesToPins(nodes) {
  return nodes.map((node) => {
    const pinStatus = {
      ...node.pinStatus,
      info: {
        ...defaultPinMeta,
        ...node.pinStatus.info,
        folder: node.type === DataType.Directory || node.type === DataType.HAMTShard
      },
      pin: {
        ...node.pinStatus.pin,
        name: node.name || node.pinStatus.pin.name || node.pinStatus.pin.cid
      }
    };
    return pinStatus;
  });
}
function extractStatusFilters(filters) {
  const statusSet = /* @__PURE__ */ new Set();
  function processFilter(filter2) {
    if ("field" in filter2 && filter2.field === "status" && filter2.operator === "eq") {
      statusSet.add(filter2.value);
    } else if ("operator" in filter2 && (filter2.operator === "or" || filter2.operator === "and")) {
      filter2.value.forEach(processFilter);
    }
  }
  filters.forEach(processFilter);
  return statusSet;
}
const SERVICE_MENU_KEY = "service";
const menuConfig = [
  {
    key: "main",
    label: "Dashboard",
    icon: ClockIcon,
    path: "/"
  },
  {
    key: SERVICE_MENU_KEY,
    label: "Services",
    icon: ClockIcon
  },
  {
    key: "account",
    label: "My Account",
    icon: CircleLockIcon,
    path: "/account",
    children: [
      {
        key: "subscription",
        label: "Subscription",
        path: "/account/subscription"
      },
      {
        key: "api-keys",
        label: "API Keys",
        path: "/account/api-keys"
      },
      {
        key: "security",
        label: "Security",
        path: "/account/security"
      }
    ]
  },
  {
    key: "uploads",
    label: "Uploads",
    icon: CloudUploadSolidIcon,
    path: "/uploads"
  }
];
function useRegisterServiceMenuItem() {
  const addMenuItem = useBaseStore((state) => state.addMenuItem);
  return (svc) => {
    addMenuItem(
      {
        key: `service-${svc.id()}`,
        label: svc.name(),
        path: `/service/${svc.id()}`
      },
      SERVICE_MENU_KEY
    );
  };
}
function useAppInitialization(sdk, authProvider) {
  const [isInitialized, setIsInitialized] = reactExports.useState(false);
  const [providers, setProviders] = reactExports.useState({});
  const [resources, setResources] = reactExports.useState([]);
  const checkAuth = useCheckAuth(authProvider);
  const addService = getAddService();
  const getServices = getGetServices();
  const initializeProviders = useInitializeProviders();
  const initializeResources = useInitializeResources();
  const registerServiceMenuItem = useRegisterServiceMenuItem();
  const baseStore2 = useBaseStore((state) => state);
  const initializeApp = reactExports.useCallback(async () => {
    var _a3;
    if (!sdk || !authProvider || isInitialized) return;
    const isAuth = await checkAuth();
    if (isAuth) {
      registerServices(addService, getServices);
      if (!((_a3 = getServices()) == null ? void 0 : _a3.length)) {
        return;
      }
      const newProviders = await initializeProviders(isAuth);
      const newResources = initializeResources(isAuth);
      setProviders(newProviders);
      setResources(newResources);
      menuConfig.forEach((menu) => {
        registerMenuItem(menu, baseStore2);
      });
      getServices().forEach(registerServiceMenuItem);
    }
    setIsInitialized(true);
  }, [
    sdk,
    authProvider,
    isInitialized,
    checkAuth,
    initializeProviders,
    initializeResources
  ]);
  reactExports.useEffect(() => {
    let isMounted = true;
    const init = async () => {
      if (sdk && isMounted && !isInitialized) {
        await initializeApp();
      }
    };
    init();
    return () => {
      isMounted = false;
    };
  }, [sdk, isInitialized, initializeApp]);
  return {
    isInitialized,
    providers,
    resources,
    setIsInitialized
  };
}
function registerServices(addFunc, getFunc) {
  [new IPFS()].forEach((svc) => {
    if (!getFunc().find((s2) => s2.id() === svc.id())) {
      addFunc(svc);
    }
  });
}
function registerMenuItem(menu, baseStore2) {
  var _a3;
  baseStore2.addMenuItem(menu);
  (_a3 = menu.children) == null ? void 0 : _a3.forEach((item) => {
    baseStore2.addMenuItem(item, menu.key);
  });
}
const createServiceProvider = () => {
  return {
    create(params) {
      return Promise.resolve(void 0);
    },
    deleteOne(params) {
      return Promise.resolve(void 0);
    },
    getApiUrl() {
      return "";
    },
    async getList(params) {
      const services = [];
      dashboardStore.getState().getServices().forEach((service) => {
        services.push({
          id: service.id(),
          name: service.name()
        });
      });
      return {
        data: services,
        total: services.length
      };
    },
    getOne(params) {
      return Promise.resolve(void 0);
    },
    update(params) {
      return Promise.resolve(void 0);
    }
  };
};
const links = () => [{
  rel: "stylesheet",
  href: stylesheet
}];
function Layout({
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("html", {
    lang: "en",
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("head", {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Meta, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(Links, {})]
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs("body", {
      className: "max-h-screen",
      children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollRestoration, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(Scripts, {})]
    })]
  });
}
function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {})]
  });
}
function Root() {
  var _a3, _b2, _c2;
  const sdk = useSdk();
  const resetServices = getResetServices();
  const uploader = useUploader();
  const authProvider = useAuthProvider(sdk);
  const {
    isInitialized,
    providers,
    resources,
    setIsInitialized
  } = useAppInitialization(sdk, authProvider);
  const wrappedAuthProvider = reactExports.useMemo(() => {
    if (!authProvider) return null;
    return {
      ...authProvider,
      login: async (params) => {
        const result = await authProvider.login(params);
        setIsInitialized(false);
        return result;
      },
      logout: async (params) => {
        const result = await authProvider.logout(params);
        setIsInitialized(false);
        resetServices();
        uploader.reset();
        return result;
      }
    };
  }, [authProvider, setIsInitialized, resetServices, uploader]);
  if (!isInitialized) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonLoader, {});
  }
  const resourceAuthHeaders = {
    Authorization: `Bearer ${(_a3 = sdk == null ? void 0 : sdk.account()) == null ? void 0 : _a3.jwtToken}`
  };
  const allResources = [...resources, {
    name: "account/keys",
    meta: {
      headers: resourceAuthHeaders
    }
  }, {
    name: "account"
  }, {
    name: SERVICE_ROUTE,
    show: "/service/:id"
  }, {
    name: "account/subscription/billing/countries",
    meta: {
      headers: resourceAuthHeaders
    }
  }, {
    name: "account/subscription/billing/states",
    meta: {
      headers: resourceAuthHeaders
    }
  }, {
    name: "account/subscription/billing/cities",
    meta: {
      headers: resourceAuthHeaders
    }
  }];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ic, {
    authProvider: wrappedAuthProvider,
    routerProvider: E,
    dataProvider: {
      ...providers,
      default: createAccountProvider(sdk, N(
        // @ts-ignore
        ((_c2 = (_b2 = sdk.account()) == null ? void 0 : _b2.apiUrl) == null ? void 0 : _c2.replace(/\/+$/, "")) + "/api"
      )),
      // @ts-ignore
      service: createServiceProvider()
    },
    notificationProvider,
    resources: allResources,
    options: {
      disableTelemetry: true,
      warnWhenUnsavedChanges: true
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
  });
}
const root = withTheme(Root);
function HydrateFallback() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonLoader, {});
}
const SkeletonLoader = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    className: "flex items-start justify-center min-h-screen p-4 pt-60",
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
      className: "w-full max-w-md space-y-2",
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {
        className: "h-4 w-3/4 mx-auto"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {
        className: "h-4 w-full"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {
        className: "h-4 w-5/6 mx-auto"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {
        className: "h-4 w-2/3 mx-auto"
      })]
    })
  });
};
export {
  HydrateFallback as H,
  Layout as L,
  config as c,
  errors as e,
  links as l,
  root as r
};
